{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#nim-typestates","title":"nim-typestates","text":"<p>Compile-time typestate validation for Nim.</p>"},{"location":"#what-is-this","title":"What is this?","text":"<p>nim-typestates is a Nim library that enforces state machine patterns at compile time. Define your valid states and transitions, and the compiler ensures your code follows them.</p> <pre><code>import typestates\n\ntype\n  File = object\n    path: string\n  Closed = distinct File\n  Open = distinct File\n\ntypestate File:\n  states Closed, Open\n  transitions:\n    Closed -&gt; Open\n    Open -&gt; Closed\n\nproc open(f: Closed): Open {.transition.} =\n  result = Open(f)\n\nproc close(f: Open): Closed {.transition.} =\n  result = Closed(f)\n\n# This works:\nlet f = Closed(File(path: \"/tmp/test\"))\nlet opened = f.open()\nlet closed = opened.close()\n\n# This won't compile - Open can't transition to Open!\n# let bad = opened.open()\n</code></pre> <p>The compiler verifies that your code follows the declared protocol. If it compiles, invalid state transitions are impossible. See Formal Guarantees for details.</p>"},{"location":"#why-typestates","title":"Why typestates?","text":"<p>Traditional runtime state machines have problems:</p> <ul> <li>Runtime errors: Invalid transitions cause crashes or bugs</li> <li>Defensive code: You write <code>if state == X</code> checks everywhere</li> <li>Documentation drift: State diagrams don't match code</li> </ul> <p>Typestates solve this by encoding states in the type system:</p> <ul> <li>Compile-time errors: Invalid transitions don't compile</li> <li>Self-documenting: Types show valid operations</li> <li>Zero runtime cost: It's just types</li> </ul>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Compile-time validation \u2014 Invalid transitions fail at compile time with clear error messages</li> <li>Zero runtime cost \u2014 All validation happens during compilation, no runtime overhead</li> <li>Branching transitions \u2014 <code>Closed -&gt; (Open | Errored) as OpenResult</code> with user-named branch types</li> <li>Wildcard transitions \u2014 <code>* -&gt; Closed</code> (any state can transition to a specific state)</li> <li>Generic typestates \u2014 <code>Container[T]</code> with states like <code>Empty[T]</code>, <code>Full[T]</code></li> <li>Cross-typestate bridges \u2014 Connect independent state machines with validated handoffs</li> <li>Generated helpers \u2014 <code>FileState</code> enum, <code>FileStates</code> union type, branch constructors</li> <li>Visualization \u2014 Export to GraphViz DOT format for diagrams</li> </ul>"},{"location":"#state-machine-visualization","title":"State Machine Visualization","text":"<p>Generate diagrams directly from your typestate definitions:</p> <pre><code>typestates dot src/ | dot -Tsvg -o states.svg\n</code></pre> <p></p>"},{"location":"#installation","title":"Installation","text":"<pre><code>nimble install typestates\n</code></pre> <p>Or add to your <code>.nimble</code> file:</p> <pre><code>requires \"typestates &gt;= 0.1.0\"\n</code></pre> <p>Nim &lt; 2.2.8 with Static Generics</p> <p>If you use <code>static</code> generic parameters (e.g., <code>Buffer[N: static int]</code>) with ARC/ORC/AtomicARC, you may hit a Nim codegen bug fixed in Nim 2.2.8. The library detects this and shows workarounds. Options:</p> <ol> <li>Upgrade to Nim &gt;= 2.2.8</li> <li>Use <code>--mm:refc</code> instead</li> <li>Add <code>consumeOnTransition = false</code> to your typestate</li> <li>Make your base type inherit from <code>RootObj</code> and add <code>inheritsFromRootObj = true</code></li> </ol> <p>Regular generics (<code>Container[T]</code>) are not affected.</p>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>Getting Started - Tutorial walkthrough</li> <li>DSL Reference - Complete syntax documentation</li> <li>Examples - Real-world patterns</li> <li>API Reference - Generated API docs</li> </ul>"},{"location":"#references","title":"References","text":""},{"location":"#foundational-papers","title":"Foundational Papers","text":"<ul> <li>Typestate: A Programming Language Concept (Strom &amp; Yemini, 1986) - The original paper introducing typestates as a compile-time mechanism for tracking object state</li> <li>Typestates for Objects (Aldrich et al., 2009) - Extends typestates to object-oriented programming with practical implementation strategies</li> </ul>"},{"location":"#tutorials-and-introductions","title":"Tutorials and Introductions","text":"<ul> <li>The Typestate Pattern in Rust - Accessible introduction to encoding typestates using Rust's type system</li> <li>Typestate Analysis (Wikipedia) - Overview of typestate analysis concepts and history</li> <li>Formal Verification (Wikipedia) - Background on formal methods that typestates relate to</li> </ul>"},{"location":"#related-projects","title":"Related Projects","text":"<ul> <li>typestate crate for Rust - Procedural macro approach to typestates in Rust, similar design philosophy to nim-typestates</li> <li>Plaid Programming Language - Research language from CMU with first-class typestate support built into the language</li> </ul>"},{"location":"#license","title":"License","text":"<p>MIT</p>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#api-reference","title":"API Reference","text":"<p>Auto-generated API documentation from source code.</p>"},{"location":"api/#main-module","title":"Main Module","text":""},{"location":"api/#typestates","title":"typestates","text":"<p>Compile-time state machine verification for Nim.</p> <p>This library enforces state machine protocols at compile time through Nim's type system. Programs that compile have been verified to contain no invalid state transitions.</p> <p>This approach is known as correctness by construction: invalid states become unrepresentable rather than checked at runtime.</p> <p>Exports:</p> <ul> <li><code>typestate</code> macro - Declare states and transitions</li> <li><code>{.transition.}</code> pragma - Mark and validate transition procs</li> <li><code>{.notATransition.}</code> pragma - Mark non-transition procs</li> </ul>"},{"location":"api/#typestate","title":"typestate","text":"<pre><code>macro typestate(name: untyped; body: untyped): untyped</code></pre> <p>Define a typestate with states and valid transitions.</p> <p>The typestate block declares:</p> <ul> <li>states: The distinct types that represent each state</li> <li>transitions: Which state changes are allowed</li> </ul> <p>Basic syntax:</p> <pre><code>typestate File:\n  states Closed, Open, Errored\n  transitions:\n    Closed -&gt; Open | Errored    # Branching\n    Open -&gt; Closed\n    * -&gt; Closed                 # Wildcard\n</code></pre> <p>What it generates:</p> <ul> <li><code>FileState</code> enum with <code>fsClosed</code>, <code>fsOpen</code>, <code>fsErrored</code></li> <li><code>FileStates</code> union type for generic procs</li> <li><code>state()</code> procs for runtime inspection</li> </ul> <p>Transition syntax:</p> <ul> <li><code>A -&gt; B</code> - Simple transition</li> <li><code>A -&gt; B | C</code> - Branching (can go to B or C)</li> <li><code>* -&gt; X</code> - Wildcard (any state can go to X)</li> </ul> <p>See also: <code>{.transition.}</code> pragma for implementing transitions</p> <p>:param name: The base type name (must match your type definition) :param body: The states and transitions declarations :returns: Generated helper types (enum, union, state procs)</p> Parameters <ul> <li> <code>name</code>               (<code>untyped</code>)                \u2013 The base type name (must match your type definition)             </li> <li> <code>body</code>               (<code>untyped</code>)                \u2013 The states and transitions declarations             </li> </ul> Returns <p><code>untyped</code> \u2013 Generated helper types (enum, union, state procs)</p> Source:              src/typestates.nim:21"},{"location":"api/#submodules","title":"Submodules","text":""},{"location":"api/#types_1","title":"Types","text":"<p>Core type definitions.</p>"},{"location":"api/#types","title":"types","text":"<p>Core type definitions for the typestate system.</p> <p>This module defines the internal representation of typestates, states, and transitions used during compile-time validation.</p> <p>These types are primarily used internally by the <code>typestate</code> macro and <code>{.transition.}</code> pragma. Most users won't interact with them directly.</p>"},{"location":"api/#extractBaseName","title":"extractBaseName","text":"<pre><code>proc extractBaseName(stateRepr: string): string</code></pre> <p>Extract the base type name from a state repr string.</p> <p>Used for comparing state names when generic parameters may differ:</p> <ul> <li><code>\"Empty\"</code> -&gt; <code>\"Empty\"</code></li> <li><code>\"Empty[T]\"</code> -&gt; <code>\"Empty\"</code></li> <li><code>\"Container[K, V]\"</code> -&gt; <code>\"Container\"</code></li> <li><code>\"ref Closed\"</code> -&gt; <code>\"Closed\"</code></li> </ul> <p>:param stateRepr: Full state repr string :returns: Base name without generic parameters</p> Parameters <ul> <li> <code>stateRepr</code>               (<code>string</code>)                \u2013 Full state repr string             </li> </ul> Returns <p><code>string</code> \u2013 Base name without generic parameters</p> Source:              src/typestates/types.nim:11"},{"location":"api/#State","title":"State","text":"<pre><code>type State</code></pre> Source:              src/typestates/types.nim:40"},{"location":"api/#Transition","title":"Transition","text":"<pre><code>type Transition</code></pre> Source:              src/typestates/types.nim:59"},{"location":"api/#Bridge","title":"Bridge","text":"<pre><code>type Bridge</code></pre> Source:              src/typestates/types.nim:95"},{"location":"api/#TypestateGraph","title":"TypestateGraph","text":"<pre><code>type TypestateGraph</code></pre> Source:              src/typestates/types.nim:125"},{"location":"api/#==","title":"==","text":"<pre><code>proc ==(a, b: Transition): bool</code></pre> <p>Compare two transitions for equality.</p> <p>Two transitions are equal if they have the same source state, destination states, and wildcard status. The declaration location is not considered for equality.</p> <p>:param a: First transition to compare :param b: Second transition to compare :returns: <code>true</code> if transitions are semantically equivalent</p> Parameters <ul> <li> <code>a</code>               (<code>Transition</code>)                \u2013 First transition to compare             </li> <li> <code>b</code>               (<code>Transition</code>)                \u2013 Second transition to compare             </li> </ul> Returns <p><code>bool</code> \u2013 `true` if transitions are semantically equivalent</p> Source:              src/typestates/types.nim:167"},{"location":"api/#==","title":"==","text":"<pre><code>proc ==(a, b: Bridge): bool</code></pre> <p>Compare two bridges for equality.</p> <p>Two bridges are equal if they have the same source state, destination typestate, and destination state. The declaration location is not considered for equality.</p> <p>:param a: First bridge to compare :param b: Second bridge to compare :returns: <code>true</code> if bridges are semantically equivalent</p> Parameters <ul> <li> <code>a</code>               (<code>Bridge</code>)                \u2013 First bridge to compare             </li> <li> <code>b</code>               (<code>Bridge</code>)                \u2013 Second bridge to compare             </li> </ul> Returns <p><code>bool</code> \u2013 `true` if bridges are semantically equivalent</p> Source:              src/typestates/types.nim:181"},{"location":"api/#hasTransition","title":"hasTransition","text":"<pre><code>proc hasTransition(graph: TypestateGraph; fromState, toState: string): bool</code></pre> <p>Check if a transition from <code>fromState</code> to <code>toState</code> is valid.</p> <p>This proc checks both explicit transitions and wildcard transitions. A transition is valid if there's an explicit transition <code>fromState -&gt; toState</code>, or there's a wildcard transition <code>* -&gt; toState</code>.</p> <p>Comparisons use base names to support generic types: - <code>hasTransition(g, \"Empty\", \"Full\")</code> matches <code>Empty[T] -&gt; Full[T]</code></p> <p>Example:</p> <pre><code># Given: Closed -&gt; Open, * -&gt; Closed\ngraph.hasTransition(\"Closed\", \"Open\")   # true\ngraph.hasTransition(\"Open\", \"Closed\")   # true (via wildcard)\ngraph.hasTransition(\"Closed\", \"Closed\") # true (via wildcard)\ngraph.hasTransition(\"Open\", \"Open\")     # false (not declared)\n</code></pre> <p>:param graph: The typestate graph to check :param fromState: The source state name (base name or full repr) :param toState: The destination state name (base name or full repr) :returns: <code>true</code> if the transition is allowed, <code>false</code> otherwise</p> Parameters <ul> <li> <code>graph</code>               (<code>TypestateGraph</code>)                \u2013 The typestate graph to check             </li> <li> <code>fromState</code>               (<code>string</code>)                \u2013 The source state name (base name or full repr)             </li> <li> <code>toState</code>               (<code>string</code>)                \u2013 The destination state name (base name or full repr)             </li> </ul> Returns <p><code>bool</code> \u2013 `true` if the transition is allowed, `false` otherwise</p> Source:              src/typestates/types.nim:195"},{"location":"api/#validDestinations","title":"validDestinations","text":"<pre><code>proc validDestinations(graph: TypestateGraph; fromState: string): seq[string]</code></pre> <p>Get all valid destination states from a given state.</p> <p>This includes both explicit transitions from <code>fromState</code> and destinations reachable via wildcard transitions.</p> <p>Comparisons use base names to support generic types. Returns base names for clearer error messages.</p> <p>Example:</p> <pre><code># Given: Closed -&gt; Open | Errored, * -&gt; Closed\ngraph.validDestinations(\"Closed\")  # @[\"Open\", \"Errored\", \"Closed\"]\ngraph.validDestinations(\"Open\")    # @[\"Closed\"]\n</code></pre> <p>:param graph: The typestate graph to query :param fromState: The source state to check transitions from :returns: A sequence of state base names that can be transitioned to</p> Parameters <ul> <li> <code>graph</code>               (<code>TypestateGraph</code>)                \u2013 The typestate graph to query             </li> <li> <code>fromState</code>               (<code>string</code>)                \u2013 The source state to check transitions from             </li> </ul> Returns <p><code>seq[string]</code> \u2013 A sequence of state base names that can be transitioned to</p> Source:              src/typestates/types.nim:229"},{"location":"api/#hasBridge","title":"hasBridge","text":"<pre><code>proc hasBridge(graph: TypestateGraph; fromState, toTypestate, toState: string): bool</code></pre> <p>Check if a bridge from <code>fromState</code> to <code>toTypestate.toState</code> is declared.</p> <p>Comparisons use base names to support generic types.</p> <p>Example:</p> <pre><code># Given: Authenticated -&gt; Session.Active\ngraph.hasBridge(\"Authenticated\", \"Session\", \"Active\")  # true\ngraph.hasBridge(\"Failed\", \"Session\", \"Active\")         # false\n</code></pre> <p>:param graph: The typestate graph to check :param fromState: The source state name :param toTypestate: The destination typestate name :param toState: The destination state name :returns: <code>true</code> if the bridge is declared, <code>false</code> otherwise</p> Parameters <ul> <li> <code>graph</code>               (<code>TypestateGraph</code>)                \u2013 The typestate graph to check             </li> <li> <code>fromState</code>               (<code>string</code>)                \u2013 The source state name             </li> <li> <code>toTypestate</code>               (<code>string</code>)                \u2013 The destination typestate name             </li> <li> <code>toState</code>               (<code>string</code>)                \u2013 The destination state name             </li> </ul> Returns <p><code>bool</code> \u2013 `true` if the bridge is declared, `false` otherwise</p> Source:              src/typestates/types.nim:259"},{"location":"api/#validBridges","title":"validBridges","text":"<pre><code>proc validBridges(graph: TypestateGraph; fromState: string): seq[string]</code></pre> <p>Get all valid bridge destinations from a given state.</p> <p>Returns dotted notation strings like \"Session.Active\".</p> <p>Example:</p> <pre><code># Given: Authenticated -&gt; Session.Active, Failed -&gt; ErrorLog.Entry\ngraph.validBridges(\"Authenticated\")  # @[\"Session.Active\"]\ngraph.validBridges(\"Failed\")         # @[\"ErrorLog.Entry\"]\n</code></pre> <p>:param graph: The typestate graph to query :param fromState: The source state to check bridges from :returns: A sequence of dotted destination names</p> Parameters <ul> <li> <code>graph</code>               (<code>TypestateGraph</code>)                \u2013 The typestate graph to query             </li> <li> <code>fromState</code>               (<code>string</code>)                \u2013 The source state to check bridges from             </li> </ul> Returns <p><code>seq[string]</code> \u2013 A sequence of dotted destination names</p> Source:              src/typestates/types.nim:287"},{"location":"api/#isInitialState","title":"isInitialState","text":"<pre><code>proc isInitialState(graph: TypestateGraph; stateName: string): bool</code></pre> <p>Check if a state is declared as initial.</p> <p>Initial states can only be constructed, not transitioned to. Comparisons use base names to support generic types.</p> <p>Example:</p> <pre><code># Given: initial: Disconnected\ngraph.isInitialState(\"Disconnected\")  # true\ngraph.isInitialState(\"Connected\")     # false\n</code></pre> <p>:param graph: The typestate graph to check :param stateName: The state name to check :returns: <code>true</code> if the state is initial, <code>false</code> otherwise</p> Parameters <ul> <li> <code>graph</code>               (<code>TypestateGraph</code>)                \u2013 The typestate graph to check             </li> <li> <code>stateName</code>               (<code>string</code>)                \u2013 The state name to check             </li> </ul> Returns <p><code>bool</code> \u2013 `true` if the state is initial, `false` otherwise</p> Source:              src/typestates/types.nim:311"},{"location":"api/#isTerminalState","title":"isTerminalState","text":"<pre><code>proc isTerminalState(graph: TypestateGraph; stateName: string): bool</code></pre> <p>Check if a state is declared as terminal.</p> <p>Terminal states are end states with no outgoing transitions. Comparisons use base names to support generic types.</p> <p>Example:</p> <pre><code># Given: terminal: Closed\ngraph.isTerminalState(\"Closed\")  # true\ngraph.isTerminalState(\"Open\")    # false\n</code></pre> <p>:param graph: The typestate graph to check :param stateName: The state name to check :returns: <code>true</code> if the state is terminal, <code>false</code> otherwise</p> Parameters <ul> <li> <code>graph</code>               (<code>TypestateGraph</code>)                \u2013 The typestate graph to check             </li> <li> <code>stateName</code>               (<code>string</code>)                \u2013 The state name to check             </li> </ul> Returns <p><code>bool</code> \u2013 `true` if the state is terminal, `false` otherwise</p> Source:              src/typestates/types.nim:334"},{"location":"api/#parser_1","title":"Parser","text":"<p>DSL parser for typestate blocks.</p>"},{"location":"api/#parser","title":"parser","text":"<p>Parser for the typestate DSL.</p> <p>This module transforms the AST from a <code>typestate</code> macro invocation into a <code>TypestateGraph</code> structure. It handles parsing of:</p> <ul> <li>State declarations (<code>states Closed, Open, Errored</code>)</li> <li>Transition declarations (<code>Closed -&gt; Open | Errored</code>)</li> <li>Wildcard transitions (<code>* -&gt; Closed</code>)</li> </ul> <p>The parser operates at compile-time within macro context.</p> <p>Internal module - most users won't interact with this directly.</p>"},{"location":"api/#parseStates","title":"parseStates","text":"<pre><code>proc parseStates(graph: var TypestateGraph; node: NimNode)</code></pre> <p>Parse a states declaration and add states to the graph.</p> <p>Accepts multiple syntax forms:</p> <ul> <li>Inline: <code>states Closed, Open, Errored</code></li> <li>Multiline block:   <pre><code>states:\n  Closed\n  Open\n  Errored\n</code></pre></li> <li>Multiline with commas:   <pre><code>states:\n  Closed,\n  Open,\n  Errored\n</code></pre></li> </ul> <p>States can be any valid Nim type expression:</p> <ul> <li>Simple identifiers: <code>Closed</code>, <code>Open</code></li> <li>Generic types: <code>Container[T]</code>, <code>Map[K, V]</code></li> <li>Ref types: <code>ref Closed</code></li> <li>Qualified names: <code>mymodule.State</code></li> </ul> <p>Example AST inputs:</p> <pre><code># Simple: states Closed, Open\nCommand\n  Ident \"states\"\n  Ident \"Closed\"\n  Ident \"Open\"\n\n# Generic: states Empty[T], Full[T]\nCommand\n  Ident \"states\"\n  BracketExpr\n    Ident \"Empty\"\n    Ident \"T\"\n  BracketExpr\n    Ident \"Full\"\n    Ident \"T\"\n\n# Multiline: states:\n#             Closed\n#             Open\nCall\n  Ident \"states\"\n  StmtList\n    Ident \"Closed\"\n    Ident \"Open\"\n</code></pre> <p>:param graph: The typestate graph to populate :param node: AST node of the states declaration :raises: Compile-time error if syntax is invalid</p> Parameters <ul> <li> <code>graph</code>               (<code>var TypestateGraph</code>)                \u2013 The typestate graph to populate             </li> <li> <code>node</code>               (<code>NimNode</code>)                \u2013 AST node of the states declaration             </li> </ul> Source:              src/typestates/parser.nim:45"},{"location":"api/#parseTransition","title":"parseTransition","text":"<pre><code>proc parseTransition(node: NimNode): Transition</code></pre> <p>Parse a single transition declaration.</p> <p>Supports three forms:</p> <ul> <li>Simple: <code>Closed -&gt; Open</code></li> <li>Branching: <code>Closed -&gt; Open | Errored</code></li> <li>Wildcard: <code>* -&gt; Closed</code></li> </ul> <p>Example AST for <code>Closed -&gt; Open | Errored</code>:</p> <pre><code>Infix\n  Ident \"-&gt;\"\n  Ident \"Closed\"\n  Infix\n    Ident \"|\"\n    Ident \"Open\"\n    Ident \"Errored\"\n</code></pre> <p>Example AST for <code>* -&gt; Closed</code> (wildcard parsed as nested prefix):</p> <pre><code>Prefix\n  Ident \"*\"\n  Prefix\n    Ident \"-&gt;\"\n    Ident \"Closed\"\n</code></pre> <p>:param node: AST node of the transition expression :returns: A <code>Transition</code> object :raises: Compile-time error if syntax is invalid</p> Parameters <ul> <li> <code>node</code>               (<code>NimNode</code>)                \u2013 AST node of the transition expression             </li> </ul> Returns <p><code>Transition</code> \u2013 A `Transition` object</p> Source:              src/typestates/parser.nim:171"},{"location":"api/#parseBridgesBlock","title":"parseBridgesBlock","text":"<pre><code>proc parseBridgesBlock(graph: var TypestateGraph; node: NimNode)</code></pre> <p>Parse the bridges block and add all bridges to the graph.</p> <p>Example input:</p> <pre><code>bridges:\n  Authenticated -&gt; Session.Active\n  Failed -&gt; ErrorLog.Entry\n  * -&gt; Shutdown.Terminal\n</code></pre> <p>:param graph: The typestate graph to populate :param node: AST node of the bridges block :raises: Compile-time error if block is malformed</p> Parameters <ul> <li> <code>graph</code>               (<code>var TypestateGraph</code>)                \u2013 The typestate graph to populate             </li> <li> <code>node</code>               (<code>NimNode</code>)                \u2013 AST node of the bridges block             </li> </ul> Source:              src/typestates/parser.nim:363"},{"location":"api/#parseInitialBlock","title":"parseInitialBlock","text":"<pre><code>proc parseInitialBlock(graph: var TypestateGraph; node: NimNode)</code></pre> <p>Parse the initial states block.</p> <p>Initial states can only be constructed, not transitioned to.</p> <p>Example input:</p> <pre><code>initial: Disconnected\n# or\ninitial: Disconnected, Starting\n# or\ninitial:\n  Disconnected\n  Starting\n</code></pre> <p>:param graph: The typestate graph to populate :param node: AST node of the initial block</p> Parameters <ul> <li> <code>graph</code>               (<code>var TypestateGraph</code>)                \u2013 The typestate graph to populate             </li> <li> <code>node</code>               (<code>NimNode</code>)                \u2013 AST node of the initial block             </li> </ul> Source:              src/typestates/parser.nim:472"},{"location":"api/#parseTerminalBlock","title":"parseTerminalBlock","text":"<pre><code>proc parseTerminalBlock(graph: var TypestateGraph; node: NimNode)</code></pre> <p>Parse the terminal states block.</p> <p>Terminal states are end states with no outgoing transitions.</p> <p>Example input:</p> <pre><code>terminal: Closed\n# or\nterminal: Closed, Failed\n# or\nterminal:\n  Closed\n  Failed\n</code></pre> <p>:param graph: The typestate graph to populate :param node: AST node of the terminal block</p> Parameters <ul> <li> <code>graph</code>               (<code>var TypestateGraph</code>)                \u2013 The typestate graph to populate             </li> <li> <code>node</code>               (<code>NimNode</code>)                \u2013 AST node of the terminal block             </li> </ul> Source:              src/typestates/parser.nim:493"},{"location":"api/#parseTypestateBody","title":"parseTypestateBody","text":"<pre><code>proc parseTypestateBody(name: NimNode; body: NimNode): TypestateGraph</code></pre> <p>Parse a complete typestate block body into a TypestateGraph.</p> <p>This is the main entry point for parsing. It processes the full body of a <code>typestate</code> macro invocation.</p> <p>The typestate name can be a simple identifier or a generic type:</p> <ul> <li>Simple: <code>typestate File:</code></li> <li>Generic: <code>typestate Container[T]:</code></li> </ul> <p>Examples:</p> <pre><code>typestate File:          # name = \"File\"\n  states Closed, Open\n  transitions:\n    Closed -&gt; Open\n\ntypestate Container[T]:  # name = \"Container\", with type param T\n  states Empty[T], Full[T]\n  transitions:\n    Empty[T] -&gt; Full[T]\n</code></pre> <p>:param name: The typestate name (identifier or bracket expression) :param body: The statement list containing states and transitions :returns: A fully populated <code>TypestateGraph</code> :raises: Compile-time error for invalid syntax</p> Parameters <ul> <li> <code>name</code>               (<code>NimNode</code>)                \u2013 The typestate name (identifier or bracket expression)             </li> <li> <code>body</code>               (<code>NimNode</code>)                \u2013 The statement list containing states and transitions             </li> </ul> Returns <p><code>TypestateGraph</code> \u2013 A fully populated `TypestateGraph`</p> Source:              src/typestates/parser.nim:651"},{"location":"api/#registry_1","title":"Registry","text":"<p>Compile-time typestate storage.</p>"},{"location":"api/#registry","title":"registry","text":"<p>Compile-time registry for typestate definitions.</p> <p>This module provides a global compile-time registry that stores all declared typestates. The registry enables:</p> <ul> <li>Looking up typestates by name</li> <li>Finding which typestate a state type belongs to</li> <li>Extending typestates across modules</li> </ul> <p>The registry is used by the <code>{.transition.}</code> pragma to validate that transitions are allowed.</p> <p>Internal module - most users won't interact with this directly.</p>"},{"location":"api/#registerTypestate","title":"registerTypestate","text":"<pre><code>template registerTypestate(graph: TypestateGraph)</code></pre> <p>Register a typestate graph in the compile-time registry.</p> <p>Each typestate can only be defined once. Attempting to register a typestate with the same name twice results in a compile error.</p> <p>Example:</p> <pre><code>typestate File:\n  states Closed, Open\n  transitions:\n    Closed -&gt; Open\n    Open -&gt; Closed\n</code></pre> <p>:param graph: The typestate graph to register</p> Parameters <ul> <li> <code>graph</code>               (<code>TypestateGraph</code>)                \u2013 The typestate graph to register             </li> </ul> Source:              src/typestates/registry.nim:61"},{"location":"api/#hasTypestate","title":"hasTypestate","text":"<pre><code>template hasTypestate(name: string): bool</code></pre> <p>Check if a typestate with the given name exists in the registry.</p> <p>:param name: The typestate name to look up :returns: <code>true</code> if registered, <code>false</code> otherwise</p> Parameters <ul> <li> <code>name</code>               (<code>string</code>)                \u2013 The typestate name to look up             </li> </ul> Returns <p><code>bool</code> \u2013 `true` if registered, `false` otherwise</p> Source:              src/typestates/registry.nim:87"},{"location":"api/#getTypestate","title":"getTypestate","text":"<pre><code>template getTypestate(name: string): TypestateGraph</code></pre> <p>Retrieve a typestate graph by name.</p> <p>:param name: The typestate name to look up :returns: The <code>TypestateGraph</code> for the typestate :raises: Compile-time error if not found</p> Parameters <ul> <li> <code>name</code>               (<code>string</code>)                \u2013 The typestate name to look up             </li> </ul> Returns <p><code>TypestateGraph</code> \u2013 The `TypestateGraph` for the typestate</p> Source:              src/typestates/registry.nim:94"},{"location":"api/#findTypestateForState","title":"findTypestateForState compileTime","text":"<pre><code>proc findTypestateForState(stateName: string): Option[TypestateGraph]</code></pre> <p>Find which typestate a given state belongs to.</p> <p>Searches all registered typestates to find one containing the specified state. Used by the <code>{.transition.}</code> pragma to determine which typestate graph to validate against.</p> <p>Lookups use base names to support generic types: - <code>findTypestateForState(\"Empty\")</code> finds <code>typestate Container</code> with <code>Empty[T]</code></p> <p>Example:</p> <pre><code># If File typestate has states Closed, Open:\nfindTypestateForState(\"Closed\")  # some(FileGraph)\nfindTypestateForState(\"Unknown\") # none\n\n# If Container typestate has states Empty[T], Full[T]:\nfindTypestateForState(\"Empty\")   # some(ContainerGraph)\n</code></pre> <p>:param stateName: The state type name (base name, e.g., \"Closed\", \"Empty\") :returns: <code>some(graph)</code> if found, <code>none</code> if state is not in any typestate</p> Parameters <ul> <li> <code>stateName</code>               (<code>string</code>)                \u2013 The state type name (base name, e.g., \"Closed\", \"Empty\")             </li> </ul> Returns <p><code>Option[TypestateGraph]</code> \u2013 `some(graph)` if found, `none` if state is not in any typestate</p> Source:              src/typestates/registry.nim:105"},{"location":"api/#BranchTypeInfo","title":"BranchTypeInfo","text":"<pre><code>type BranchTypeInfo</code></pre> Source:              src/typestates/registry.nim:136"},{"location":"api/#findBranchTypeInfo","title":"findBranchTypeInfo compileTime","text":"<pre><code>proc findBranchTypeInfo(typeName: string): Option[BranchTypeInfo]</code></pre> <p>Check if a type name is a user-defined branch type.</p> <p>Branch types are named by the user via <code>as TypeName</code> syntax in branching transitions.</p> <p>This function searches all registered typestates for branching transitions that declare the given branch type name.</p> <p>Example:</p> <pre><code># If typestate has: Created -&gt; (Approved | Declined) as ProcessResult\nfindBranchTypeInfo(\"ProcessResult\")\n# Returns: some(BranchTypeInfo(sourceState: \"Created\",\n#                              destinations: @[\"Approved\", \"Declined\"]))\n\nfindBranchTypeInfo(\"NotABranch\")\n# Returns: none(BranchTypeInfo)\n</code></pre> <p>:param typeName: The type name to check :returns: <code>some(info)</code> if it's a branch type, <code>none</code> otherwise</p> Parameters <ul> <li> <code>typeName</code>               (<code>string</code>)                \u2013 The type name to check             </li> </ul> Returns <p><code>Option[BranchTypeInfo]</code> \u2013 `some(info)` if it's a branch type, `none` otherwise</p> Source:              src/typestates/registry.nim:145"},{"location":"api/#pragmas_1","title":"Pragmas","text":"<p>Pragma implementations for transition validation.</p>"},{"location":"api/#pragmas","title":"pragmas","text":"<p>Pragmas for marking and validating state transitions.</p> <p>This module provides the pragmas that users apply to their procs:</p> <ul> <li><code>{.transition.}</code> - Mark a proc as a state transition (validated)</li> <li><code>{.notATransition.}</code> - Mark a proc as intentionally not a transition</li> </ul> <p>The <code>{.transition.}</code> pragma performs compile-time validation to ensure that only declared transitions are implemented.</p>"},{"location":"api/#registerSealedStates","title":"registerSealedStates compileTime","text":"<pre><code>proc registerSealedStates(modulePath: string; stateNames: seq[string])</code></pre> <p>Register states from a sealed typestate for external checking.</p> <p>:param modulePath: The module filename where the typestate is defined :param stateNames: List of state type names to register</p> Parameters <ul> <li> <code>modulePath</code>               (<code>string</code>)                \u2013 The module filename where the typestate is defined             </li> <li> <code>stateNames</code>               (<code>seq[string]</code>)                \u2013 List of state type names to register             </li> </ul> Source:              src/typestates/pragmas.nim:20"},{"location":"api/#isStateFromSealedTypestate","title":"isStateFromSealedTypestate compileTime","text":"<pre><code>proc isStateFromSealedTypestate(stateName: string; currentModule: string): Option[string]</code></pre> <p>Check if a state is from a sealed typestate defined in another module.</p> <p>:param stateName: The state type name to check :param currentModule: The current module's filename :returns: <code>some(modulePath)</code> if from external sealed typestate, <code>none</code> otherwise</p> Parameters <ul> <li> <code>stateName</code>               (<code>string</code>)                \u2013 The state type name to check             </li> <li> <code>currentModule</code>               (<code>string</code>)                \u2013 The current module's filename             </li> </ul> Returns <p><code>Option[string]</code> \u2013 `some(modulePath)` if from external sealed typestate, `none` otherwise</p> Source:              src/typestates/pragmas.nim:31"},{"location":"api/#transition","title":"transition","text":"<pre><code>macro transition(procDef: untyped): untyped</code></pre> <p>Mark a proc as a state transition and verify it at compile time.</p> <p>The compiler checks that the transition from the input state type to the return state type is declared in the corresponding typestate. If not, compilation fails with a diagnostic.</p> <p>This provides compile-time protocol enforcement: only declared transitions can be implemented.</p> <p>Example:</p> <pre><code>proc open(f: Closed): Open {.transition.} =\n  result = Open(f)\n\nproc close(f: Open): Closed {.transition.} =\n  result = Closed(f)\n</code></pre> <p>Error example:</p> <pre><code>Error: Undeclared transition: Open -&gt; Locked\n  Typestate 'File' does not declare this transition.\n  Valid transitions from 'Open': @[\"Closed\"]\n  Hint: Add 'Open -&gt; Locked' to the transitions block.\n</code></pre> Parameters <ul> <li> <code>procDef</code>               (<code>untyped</code>)                            </li> </ul> Returns <p><code>untyped</code></p> Source:              src/typestates/pragmas.nim:111"},{"location":"api/#notATransition","title":"notATransition pragma","text":"<pre><code>template notATransition()</code></pre> <p>Mark a proc as intentionally not a state transition.</p> <p>Use this pragma for procs that operate on state types but don't change the state. This is required when <code>strictTransitions</code> is enabled on the typestate.</p> <p>When to use:</p> <ul> <li>Procs that read from a state type</li> <li>Procs that perform I/O without changing state</li> <li>Procs that modify the underlying data without state transition</li> </ul> <p>Example:</p> <pre><code># Side effects without state change\nproc write(f: Open, data: string) {.notATransition.} =\n  rawWrite(f.handle, data)\n\n# Pure functions don't need this (use `func` instead)\nfunc path(f: Open): string = f.File.path\n</code></pre> Source:              src/typestates/pragmas.nim:265"},{"location":"api/#code-generation","title":"Code Generation","text":"<p>Code generation for helper types.</p>"},{"location":"api/#codegen","title":"codegen","text":"<p>Code generation for typestate helper types.</p> <p>This module generates the helper types and procs that make typestates easier to use at runtime:</p> <ul> <li>State enum: <code>FileState = enum fsClosed, fsOpen, ...</code></li> <li>Union type: <code>FileStates = Closed | Open | ...</code></li> <li>State procs: <code>proc state(f: Closed): FileState</code></li> <li>Branch types: <code>CreatedBranch</code> variant for <code>Created -&gt; Approved | Declined</code></li> <li>Branch constructors: <code>toCreatedBranch(s: Approved): CreatedBranch</code></li> </ul> <p>These are generated automatically by the <code>typestate</code> macro.</p>"},{"location":"api/#buildGenericParams","title":"buildGenericParams","text":"<pre><code>proc buildGenericParams(typeParams: seq[NimNode]): NimNode</code></pre> <p>Build a generic params node for proc/type definitions.</p> <p>For <code>@[T]</code>, generates: <code>[T]</code> For <code>@[K, V]</code>, generates: <code>[K, V]</code> For <code>@[N: static int]</code>, generates: <code>[N: static int]</code> For <code>@[T: SomeInteger]</code>, generates: <code>[T: SomeInteger]</code> For <code>@[]</code>, returns empty node (non-generic)</p> <p>:param typeParams: Sequence of type parameter nodes :returns: nnkGenericParams node or newEmptyNode()</p> Parameters <ul> <li> <code>typeParams</code>               (<code>seq[NimNode]</code>)                \u2013 Sequence of type parameter nodes             </li> </ul> Returns <p><code>NimNode</code> \u2013 nnkGenericParams node or newEmptyNode()</p> Source:              src/typestates/codegen.nim:17"},{"location":"api/#extractTypeParams","title":"extractTypeParams","text":"<pre><code>proc extractTypeParams(node: NimNode): seq[NimNode]</code></pre> <p>Extract type parameters from a type node.</p> <p>For <code>FillResult[T]</code>, returns <code>@[T]</code> For <code>Map[K, V]</code>, returns <code>@[K, V]</code> For <code>Simple</code>, returns <code>@[]</code></p> <p>:param node: A type AST node (ident or bracket expr) :returns: Sequence of type parameter nodes</p> Parameters <ul> <li> <code>node</code>               (<code>NimNode</code>)                \u2013 A type AST node (ident or bracket expr)             </li> </ul> Returns <p><code>seq[NimNode]</code> \u2013 Sequence of type parameter nodes</p> Source:              src/typestates/codegen.nim:45"},{"location":"api/#generateStateEnum","title":"generateStateEnum","text":"<pre><code>proc generateStateEnum(graph: TypestateGraph): NimNode</code></pre> <p>Generate a runtime enum representing all states.</p> <p>For a typestate named <code>File</code> with states <code>Closed</code>, <code>Open</code>, <code>Errored</code>, generates:</p> <pre><code>type FileState* = enum\n  fsClosed, fsOpen, fsErrored\n</code></pre> <p>For generic typestates like <code>Container[T]</code> with states <code>Empty[T]</code>, <code>Full[T]</code>:</p> <pre><code>type ContainerState* = enum\n  fsEmpty, fsFull\n</code></pre> <p>The enum values use base names (without type params) prefixed with <code>fs</code>.</p> <p>:param graph: The typestate graph to generate from :returns: AST for the enum type definition</p> Parameters <ul> <li> <code>graph</code>               (<code>TypestateGraph</code>)                \u2013 The typestate graph to generate from             </li> </ul> Returns <p><code>NimNode</code> \u2013 AST for the enum type definition</p> Source:              src/typestates/codegen.nim:59"},{"location":"api/#generateUnionType","title":"generateUnionType","text":"<pre><code>proc generateUnionType(graph: TypestateGraph): NimNode</code></pre> <p>Generate a type alias for \"any state\" using Nim's union types.</p> <p>For a typestate named <code>File</code> with states <code>Closed</code>, <code>Open</code>, <code>Errored</code>, generates:</p> <pre><code>type FileStates* = Closed | Open | Errored\n</code></pre> <p>For generic typestates like <code>Container[T]</code>:</p> <pre><code>type ContainerStates*[T] = Empty[T] | Full[T]\n</code></pre> <p>This union type is useful for procs that can accept any state.</p> <p>:param graph: The typestate graph to generate from :returns: AST for the union type definition</p> Parameters <ul> <li> <code>graph</code>               (<code>TypestateGraph</code>)                \u2013 The typestate graph to generate from             </li> </ul> Returns <p><code>NimNode</code> \u2013 AST for the union type definition</p> Source:              src/typestates/codegen.nim:97"},{"location":"api/#generateStateProcs","title":"generateStateProcs","text":"<pre><code>proc generateStateProcs(graph: TypestateGraph): NimNode</code></pre> <p>Generate <code>state()</code> procs for runtime state inspection.</p> <p>For each state, generates a proc that returns the enum value:</p> <pre><code>proc state*(f: Closed): FileState = fsClosed\nproc state*(f: Open): FileState = fsOpen\n</code></pre> <p>For generic types:</p> <pre><code>proc state*[T](f: Empty[T]): ContainerState = fsEmpty\nproc state*[T](f: Full[T]): ContainerState = fsFull\n</code></pre> <p>:param graph: The typestate graph to generate from :returns: AST for all state() proc definitions</p> Parameters <ul> <li> <code>graph</code>               (<code>TypestateGraph</code>)                \u2013 The typestate graph to generate from             </li> </ul> Returns <p><code>NimNode</code> \u2013 AST for all state() proc definitions</p> Source:              src/typestates/codegen.nim:150"},{"location":"api/#hasGenericStates","title":"hasGenericStates","text":"<pre><code>proc hasGenericStates(graph: TypestateGraph): bool</code></pre> <p>Check if any states use generic type parameters.</p> Parameters <ul> <li> <code>graph</code>               (<code>TypestateGraph</code>)                            </li> </ul> Returns <p><code>bool</code></p> Source:              src/typestates/codegen.nim:203"},{"location":"api/#getBranchingTransitions","title":"getBranchingTransitions","text":"<pre><code>proc getBranchingTransitions(graph: TypestateGraph): seq[Transition]</code></pre> <p>Get all transitions that have multiple destinations (branching).</p> <p>A branching transition is one where <code>toStates.len &gt; 1</code>, like: <code>Created -&gt; (Approved | Declined)</code></p> <p>:param graph: The typestate graph to query :returns: Sequence of branching transitions</p> Parameters <ul> <li> <code>graph</code>               (<code>TypestateGraph</code>)                \u2013 The typestate graph to query             </li> </ul> Returns <p><code>seq[Transition]</code> \u2013 Sequence of branching transitions</p> Source:              src/typestates/codegen.nim:210"},{"location":"api/#generateBranchTypes","title":"generateBranchTypes","text":"<pre><code>proc generateBranchTypes(graph: TypestateGraph): NimNode</code></pre> <p>Generate variant types for branching transitions.</p> <p>For a transition like <code>Created -&gt; (Approved | Declined) as ProcessResult</code>, generates:</p> <pre><code>type\n  ProcessResultKind* = enum pApproved, pDeclined\n  ProcessResult* = object\n    case kind*: ProcessResultKind\n    of pApproved: approved*: Approved\n    of pDeclined: declined*: Declined\n</code></pre> <p>For generic types like <code>Empty[T] -&gt; Full[T] | Error[T] as FillResult[T]</code>:</p> <pre><code>type\n  FillResultKind* = enum fFull, fError\n  FillResult*[T] = object\n    case kind*: FillResultKind\n    of fFull: full*: Full[T]\n    of fError: error*: Error[T]\n</code></pre> <p>The type name comes from the <code>as TypeName</code> syntax in the DSL. Enum prefixes are derived from the first letter of the type name.</p> <p>:param graph: The typestate graph to generate from :returns: AST for all branch type definitions</p> Parameters <ul> <li> <code>graph</code>               (<code>TypestateGraph</code>)                \u2013 The typestate graph to generate from             </li> </ul> Returns <p><code>NimNode</code> \u2013 AST for all branch type definitions</p> Source:              src/typestates/codegen.nim:232"},{"location":"api/#generateBranchConstructors","title":"generateBranchConstructors","text":"<pre><code>proc generateBranchConstructors(graph: TypestateGraph): NimNode</code></pre> <p>Generate constructor procs for branch types.</p> <p>For <code>Created -&gt; (Approved | Declined) as ProcessResult</code>, generates:</p> <pre><code>proc toProcessResult*(s: Approved): ProcessResult =\n  ProcessResult(kind: pApproved, approved: s)\n\nproc toProcessResult*(s: Declined): ProcessResult =\n  ProcessResult(kind: pDeclined, declined: s)\n</code></pre> <p>For generic types:</p> <pre><code>proc toFillResult*[T](s: Full[T]): FillResult[T] =\n  FillResult[T](kind: fFull, full: s)\n</code></pre> <p>:param graph: The typestate graph to generate from :returns: AST for all constructor proc definitions</p> Parameters <ul> <li> <code>graph</code>               (<code>TypestateGraph</code>)                \u2013 The typestate graph to generate from             </li> </ul> Returns <p><code>NimNode</code> \u2013 AST for all constructor proc definitions</p> Source:              src/typestates/codegen.nim:339"},{"location":"api/#generateCopyHooks","title":"generateCopyHooks","text":"<pre><code>proc generateCopyHooks(graph: TypestateGraph): NimNode</code></pre> <p>Generate <code>=copy</code> error hooks to prevent state copying.</p> <p>When <code>consumeOnTransition = true</code>, generates:</p> <pre><code>proc `=copy`*(dest: var Closed, src: Closed) {.error: \"State 'Closed' cannot be copied. Transitions consume the input state.\".}\n</code></pre> <p>This enforces linear/affine typing - each state value can only be used once.</p> <p>:param graph: The typestate graph to generate from :returns: AST for all copy hook definitions</p> Parameters <ul> <li> <code>graph</code>               (<code>TypestateGraph</code>)                \u2013 The typestate graph to generate from             </li> </ul> Returns <p><code>NimNode</code> \u2013 AST for all copy hook definitions</p> Source:              src/typestates/codegen.nim:414"},{"location":"api/#hasStaticGenericParam","title":"hasStaticGenericParam","text":"<pre><code>proc hasStaticGenericParam(graph: TypestateGraph): bool</code></pre> <p>Check if typestate has any static generic parameters (e.g., <code>N: static int</code>).</p> <p>These are vulnerable to a codegen bug in Nim &lt; 2.2.8 when combined with <code>=copy</code> hooks on distinct types. Affects ARC, ORC, AtomicARC, and any memory manager using hooks.</p> <p>:param graph: The typestate graph to check :returns: <code>true</code> if any type parameter uses <code>static</code></p> Parameters <ul> <li> <code>graph</code>               (<code>TypestateGraph</code>)                \u2013 The typestate graph to check             </li> </ul> Returns <p><code>bool</code> \u2013 `true` if any type parameter uses `static`</p> Source:              src/typestates/codegen.nim:466"},{"location":"api/#hasHookCodegenBugConditions","title":"hasHookCodegenBugConditions","text":"<pre><code>proc hasHookCodegenBugConditions(graph: TypestateGraph): bool</code></pre> <p>Check if this typestate has conditions that trigger a codegen bug in Nim &lt; 2.2.8.</p> <p>The bug occurs when all these conditions are met: 1. Distinct types (implicit - all typestate states are distinct) 2. Plain object (not inheriting from RootObj) 3. Generic with <code>static</code> parameter (e.g., <code>N: static int</code>) 4. Lifecycle hooks are generated (<code>consumeOnTransition = true</code>)</p> <p>Note: Condition 1 is always true for typestates. Condition 2 is checked via the <code>inheritsFromRootObj</code> flag (we can't detect inheritance at macro time).</p> <p>Affects ARC, ORC, AtomicARC, and any memory manager using hooks. Fixed in Nim commit 099ee1ce4a308024781f6f39ddfcb876f4c3629c (&gt;= 2.2.8). See: https://github.com/nim-lang/Nim/issues/25341</p> <p>:param graph: The typestate graph to check :returns: <code>true</code> if vulnerable conditions are present</p> Parameters <ul> <li> <code>graph</code>               (<code>TypestateGraph</code>)                \u2013 The typestate graph to check             </li> </ul> Returns <p><code>bool</code> \u2013 `true` if vulnerable conditions are present</p> Source:              src/typestates/codegen.nim:484"},{"location":"api/#generateBranchOperators","title":"generateBranchOperators","text":"<pre><code>proc generateBranchOperators(graph: TypestateGraph): NimNode</code></pre> <p>Generate <code>-&gt;</code> operator templates for branch types.</p> <p>The <code>-&gt;</code> operator provides syntactic sugar for branch construction. It takes the branch type on the left and the state value on the right:</p> <pre><code># Usage (for: Created -&gt; Approved | Declined as ProcessResult):\nProcessResult -&gt; Approved(c.Payment)\n\n# Equivalent to:\ntoProcessResult(Approved(c.Payment))\n</code></pre> <p>For generic types:</p> <pre><code>FillResult[int] -&gt; Full[int](container)\n</code></pre> <p>Generated templates:</p> <pre><code>template `-&gt;`*(T: typedesc[ProcessResult], s: Approved): ProcessResult =\n  toProcessResult(s)\n\ntemplate `-&gt;`*[T](T: typedesc[FillResult[T]], s: Full[T]): FillResult[T] =\n  toFillResult(s)\n</code></pre> <p>The <code>typedesc</code> parameter disambiguates when the same state appears in multiple branch types.</p> <p>:param graph: The typestate graph to generate from :returns: AST for all operator template definitions</p> Parameters <ul> <li> <code>graph</code>               (<code>TypestateGraph</code>)                \u2013 The typestate graph to generate from             </li> </ul> Returns <p><code>NimNode</code> \u2013 AST for all operator template definitions</p> Source:              src/typestates/codegen.nim:506"},{"location":"api/#generateAll","title":"generateAll","text":"<pre><code>proc generateAll(graph: TypestateGraph): NimNode</code></pre> <p>Generate all helper types and procs for a typestate.</p> <p>This is the main entry point called by the <code>typestate</code> macro. It generates:</p> <ol> <li>State enum (<code>FileState</code>)</li> <li>Union type (<code>FileStates</code> or <code>ContainerStates[T]</code>)</li> <li>State procs (<code>state()</code> for each state)</li> <li>Copy hooks (<code>=copy</code> error hooks when consumeOnTransition = true)</li> <li>Branch types for branching transitions (user-named via <code>as TypeName</code>)</li> <li>Branch constructors (<code>toTypeName</code>)</li> <li>Branch operators (<code>-&gt;</code>)</li> </ol> <p>For generic typestates like <code>Container[T]</code>, all generated types and procs include proper type parameters.</p> <p>:param graph: The typestate graph to generate from :returns: AST containing all generated definitions</p> Parameters <ul> <li> <code>graph</code>               (<code>TypestateGraph</code>)                \u2013 The typestate graph to generate from             </li> </ul> Returns <p><code>NimNode</code> \u2013 AST containing all generated definitions</p> Source:              src/typestates/codegen.nim:597"},{"location":"api/#cli_1","title":"CLI","text":"<p>Command-line tool functionality.</p>"},{"location":"api/#cli","title":"cli","text":"<p>Command-line tool for typestates.</p> <p>Usage:</p> <pre><code>typestates verify [paths...]\ntypestates dot [paths...]\n</code></pre> <p>Parses source files using Nim's AST parser and verifies typestate rules or generates DOT output.</p> <p>Note: Files must be valid Nim syntax. Parse errors cause verification to fail loudly with a clear error message.</p>"},{"location":"api/#SplineMode","title":"SplineMode","text":"<pre><code>type SplineMode</code></pre> Source:              src/typestates/cli.nim:23"},{"location":"api/#VerifyResult","title":"VerifyResult","text":"<pre><code>type VerifyResult</code></pre> Source:              src/typestates/cli.nim:36"},{"location":"api/#parseTypestates","title":"parseTypestates","text":"<pre><code>proc parseTypestates(paths: seq[string]): ParseResult</code></pre> <p>Parse all Nim files in the given paths for typestates.</p> <p>Uses Nim's AST parser for accurate extraction. Fails loudly on files with syntax errors.</p> <p>:param paths: List of file or directory paths to scan :returns: All parsed typestates and total file count :raises ParseError: on syntax errors</p> Parameters <ul> <li> <code>paths</code>               (<code>seq[string]</code>)                \u2013 List of file or directory paths to scan             </li> </ul> Returns <p><code>ParseResult</code> \u2013 All parsed typestates and total file count</p> Source:              src/typestates/cli.nim:48"},{"location":"api/#generateDot","title":"generateDot","text":"<pre><code>proc generateDot(ts: ParsedTypestate; noStyle: bool = false; splineMode: SplineMode = smSpline): string</code></pre> <p>Generate GraphViz DOT output for a typestate.</p> <p>Creates a directed graph representation suitable for rendering with <code>dot</code>, <code>neato</code>, or other GraphViz tools.</p> <p>:param ts: The parsed typestate to visualize :param noStyle: If true, output bare DOT structure with no styling :param splineMode: Edge routing mode (spline, ortho, polyline, line) :returns: DOT format string</p> Parameters <ul> <li> <code>ts</code>               (<code>ParsedTypestate</code>)                \u2013 The parsed typestate to visualize             </li> <li> <code>noStyle</code>               (<code>bool</code>)                \u2013 If true, output bare DOT structure with no styling             </li> <li> <code>splineMode</code>               (<code>SplineMode</code>)                \u2013 Edge routing mode (spline, ortho, polyline, line)             </li> </ul> Returns <p><code>string</code> \u2013 DOT format string</p> Source:              src/typestates/cli.nim:148"},{"location":"api/#generateUnifiedDot","title":"generateUnifiedDot","text":"<pre><code>proc generateUnifiedDot(typestates: seq[ParsedTypestate]; noStyle: bool = false; splineMode: SplineMode = smSpline): string</code></pre> <p>Generate a unified GraphViz DOT output showing all typestates.</p> <p>Creates subgraphs for each typestate with cross-cluster edges for bridges.</p> <p>:param typestates: List of parsed typestates to visualize :param noStyle: If true, output bare DOT structure with no styling :param splineMode: Edge routing mode (spline, ortho, polyline, line) :returns: DOT format string</p> Parameters <ul> <li> <code>typestates</code>               (<code>seq[ParsedTypestate]</code>)                \u2013 List of parsed typestates to visualize             </li> <li> <code>noStyle</code>               (<code>bool</code>)                \u2013 If true, output bare DOT structure with no styling             </li> <li> <code>splineMode</code>               (<code>SplineMode</code>)                \u2013 Edge routing mode (spline, ortho, polyline, line)             </li> </ul> Returns <p><code>string</code> \u2013 DOT format string</p> Source:              src/typestates/cli.nim:195"},{"location":"api/#generateSeparateDot","title":"generateSeparateDot","text":"<pre><code>proc generateSeparateDot(ts: ParsedTypestate; noStyle: bool = false; splineMode: SplineMode = smSpline): string</code></pre> <p>Generate GraphViz DOT output for a single typestate.</p> <p>Bridges are shown as terminal nodes with dashed edges.</p> <p>:param ts: The parsed typestate to visualize :param noStyle: If true, output bare DOT structure with no styling :param splineMode: Edge routing mode (spline, ortho, polyline, line) :returns: DOT format string</p> Parameters <ul> <li> <code>ts</code>               (<code>ParsedTypestate</code>)                \u2013 The parsed typestate to visualize             </li> <li> <code>noStyle</code>               (<code>bool</code>)                \u2013 If true, output bare DOT structure with no styling             </li> <li> <code>splineMode</code>               (<code>SplineMode</code>)                \u2013 Edge routing mode (spline, ortho, polyline, line)             </li> </ul> Returns <p><code>string</code> \u2013 DOT format string</p> Source:              src/typestates/cli.nim:290"},{"location":"api/#verify","title":"verify","text":"<pre><code>proc verify(paths: seq[string]): VerifyResult</code></pre> <p>Verify all Nim files in the given paths.</p> <p>Uses Nim's AST parser to extract typestates, then checks that all procs operating on state types are properly marked with <code>{.transition.}</code> or <code>{.notATransition.}</code>.</p> <p>Note: Files with syntax errors cause verification to fail immediately with a clear error message.</p> <p>:param paths: List of file or directory paths to verify :returns: Verification results with errors, warnings, and counts :raises ParseError: on syntax errors</p> Parameters <ul> <li> <code>paths</code>               (<code>seq[string]</code>)                \u2013 List of file or directory paths to verify             </li> </ul> Returns <p><code>VerifyResult</code> \u2013 Verification results with errors, warnings, and counts</p> Source:              src/typestates/cli.nim:394"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#contributing","title":"Contributing","text":"<p>Guidelines for contributing to nim-typestates.</p>"},{"location":"contributing/#development-setup","title":"Development Setup","text":"<pre><code># Clone the repository\ngit clone https://github.com/elijahr/nim-typestates.git\ncd nim-typestates\n\n# Install dependencies\nnimble install -d\n\n# Build the CLI\nnimble build\n\n# Run tests\nnimble test\n</code></pre>"},{"location":"contributing/#running-tests","title":"Running Tests","text":"<pre><code># Run all tests\nnimble test\n\n# Run specific test file\nnim c -r tests/tbasic.nim\n</code></pre>"},{"location":"contributing/#documentation","title":"Documentation","text":""},{"location":"contributing/#local-preview","title":"Local Preview","text":"<pre><code># Install Python dependencies\npip install -r docs-requirements.txt\n\n# Serve docs locally\nmkdocs serve\n</code></pre>"},{"location":"contributing/#auto-generated-diagrams","title":"Auto-Generated Diagrams","text":"<p>The diagrams in this documentation are automatically generated from source code snippets. This ensures they stay in sync with the actual typestate definitions.</p>"},{"location":"contributing/#generating-diagrams","title":"Generating Diagrams","text":"<pre><code># Generate all diagrams from examples/snippets/\nnimble generateDocs\n\n# Or manually:\npython3 scripts/generate_diagrams.py\n</code></pre> <p>This reads <code>*_typestate.nim</code> files from <code>examples/snippets/</code> and generates SVG diagrams in <code>docs/assets/images/generated/</code>.</p>"},{"location":"contributing/#creating-new-diagram-sources","title":"Creating New Diagram Sources","text":"<p>To add a new auto-generated diagram:</p> <ol> <li>Create a snippet in <code>examples/snippets/yourname_typestate.nim</code>:</li> </ol> <pre><code>import ../../src/typestates\n\ntype\n  YourType = object\n  StateA = distinct YourType\n  StateB = distinct YourType\n\ntypestate YourType:\n  states StateA, StateB\n  transitions:\n    StateA -&gt; StateB\n</code></pre> <ol> <li> <p>Run <code>nimble generateDocs</code> to regenerate all diagrams.</p> </li> <li> <p>Reference the generated image in docs: <code>![YourType](assets/images/generated/yourtype.svg)</code></p> </li> </ol>"},{"location":"contributing/#code-style","title":"Code Style","text":"<ul> <li>Follow standard Nim style conventions</li> <li>Use <code>nimble format</code> if available</li> <li>Keep lines under 100 characters where practical</li> </ul>"},{"location":"contributing/#pull-requests","title":"Pull Requests","text":"<ol> <li>Fork the repository</li> <li>Create a feature branch</li> <li>Make your changes</li> <li>Run tests: <code>nimble test</code></li> <li>Submit a pull request</li> </ol>"},{"location":"contributing/#reporting-issues","title":"Reporting Issues","text":"<p>Please include:</p> <ul> <li>Nim version (<code>nim --version</code>)</li> <li>nim-typestates version</li> <li>Minimal reproduction case</li> <li>Expected vs actual behavior</li> </ul>"},{"location":"guide/bridges/","title":"Cross-Type Bridges","text":""},{"location":"guide/bridges/#cross-type-state-bridges","title":"Cross-Type State Bridges","text":"<p>Bridges allow terminal states of one typestate to transition into states of a completely different typestate. This enables modeling resource transformation, wrapping, and protocol handoff.</p>"},{"location":"guide/bridges/#declaration","title":"Declaration","text":"<p>Declare bridges in the source typestate using a <code>bridges:</code> block with dotted notation:</p> <pre><code>import session\n\ntypestate AuthFlow:\n  states Pending, Authenticated, Failed\n  transitions:\n    Pending -&gt; Authenticated\n    Pending -&gt; Failed\n  bridges:\n    Authenticated -&gt; Session.Active\n    Failed -&gt; ErrorLog.Entry\n</code></pre> <p>The destination typestate must be imported and exist.</p>"},{"location":"guide/bridges/#implementation","title":"Implementation","text":""},{"location":"guide/bridges/#using-procs","title":"Using Procs","text":"<p>Use procs when you need extra arguments:</p> <pre><code>proc startSession(auth: Authenticated, config: SessionConfig): Active {.transition.} =\n  result = Active(Session(\n    userId: auth.AuthFlow.userId,\n    timeout: config.timeout\n  ))\n</code></pre>"},{"location":"guide/bridges/#using-converters","title":"Using Converters","text":"<p>Use converters for simple 1:1 transforms:</p> <pre><code>converter toSession(auth: Authenticated): Active {.transition.} =\n  Active(Session(userId: auth.AuthFlow.userId))\n\n# Usage - implicit conversion works\nlet session: Active = myAuth\n</code></pre>"},{"location":"guide/bridges/#branching","title":"Branching","text":"<p>Bridges support branching like regular transitions:</p> <pre><code>bridges:\n  Authenticated -&gt; Session.Active | Session.Guest\n</code></pre>"},{"location":"guide/bridges/#wildcard-bridges","title":"Wildcard Bridges","text":"<p>Use <code>*</code> to allow any state to bridge to a destination:</p> <pre><code>bridges:\n  * -&gt; Shutdown.Terminal\n</code></pre>"},{"location":"guide/bridges/#validation","title":"Validation","text":"<p>The compiler validates:</p> <ol> <li>Bridge is declared in source typestate's <code>bridges:</code> block</li> <li>Proc/converter signature matches declaration</li> <li>Destination typestate exists</li> <li>Destination state exists in that typestate</li> <li>Destination module is imported</li> </ol>"},{"location":"guide/bridges/#error-messages","title":"Error Messages","text":""},{"location":"guide/bridges/#bridge-not-declared","title":"Bridge Not Declared","text":"<pre><code>Error: Undeclared bridge: Authenticated -&gt; Session.Active\n  Typestate 'AuthFlow' does not declare this bridge.\n  Valid bridges from 'Authenticated': @[]\n  Hint: Add 'bridges: Authenticated -&gt; Session.Active' to AuthFlow.\n</code></pre>"},{"location":"guide/bridges/#unknown-typestate","title":"Unknown Typestate","text":"<p>If you reference a typestate that doesn't exist, you'll get an error indicating that the destination type isn't part of any registered typestate.</p>"},{"location":"guide/bridges/#unknown-state","title":"Unknown State","text":"<p>If you reference a state that doesn't exist in the destination typestate, you'll get an error indicating which states are valid.</p>"},{"location":"guide/bridges/#complete-example","title":"Complete Example","text":"<pre><code># session.nim\nimport typestates\n\ntype\n  Session = object\n    userId: string\n  Active = distinct Session\n  Expired = distinct Session\n\ntypestate Session:\n  states Active, Expired\n  transitions:\n    Active -&gt; Expired\n\n# auth.nim\nimport typestates\nimport ./session\n\ntype\n  AuthFlow = object\n    userId: string\n  Pending = distinct AuthFlow\n  Authenticated = distinct AuthFlow\n\ntypestate AuthFlow:\n  states Pending, Authenticated\n  transitions:\n    Pending -&gt; Authenticated\n  bridges:\n    Authenticated -&gt; Session.Active\n\nconverter toSession(a: Authenticated): Active {.transition.} =\n  Active(Session(userId: a.AuthFlow.userId))\n</code></pre>"},{"location":"guide/bridges/#visualization","title":"Visualization","text":""},{"location":"guide/bridges/#unified-graph-default","title":"Unified Graph (default)","text":"<pre><code>typestates dot src/\n</code></pre> <p>Shows all typestates with cross-cluster dashed edges for bridges.</p>"},{"location":"guide/bridges/#separate-graphs","title":"Separate Graphs","text":"<pre><code>typestates dot --separate src/\n</code></pre> <p>Shows individual graphs per typestate with bridges as terminal nodes.</p>"},{"location":"guide/cli/","title":"CLI Reference","text":""},{"location":"guide/cli/#command-line-interface","title":"Command Line Interface","text":"<p>The <code>typestates</code> command-line tool provides project-wide verification and visualization capabilities.</p>"},{"location":"guide/cli/#installation","title":"Installation","text":"<p>The CLI is installed automatically with the library:</p> <pre><code>nimble install typestates\n</code></pre>"},{"location":"guide/cli/#usage","title":"Usage","text":"<pre><code>typestates &lt;command&gt; [paths...]\n\nCommands:\n  verify    Check that procs on state types are properly marked\n  dot       Generate GraphViz DOT output for visualization\n\nOptions:\n  -h, --help      Show help\n  -v, --version   Show version\n</code></pre>"},{"location":"guide/cli/#verify-command","title":"Verify Command","text":"<p>The <code>verify</code> command checks that all procs operating on state types are properly marked with <code>{.transition.}</code> or <code>{.notATransition.}</code>.</p>"},{"location":"guide/cli/#basic-usage","title":"Basic Usage","text":"<pre><code>typestates verify src/\ntypestates verify src/ tests/\ntypestates verify .\n</code></pre>"},{"location":"guide/cli/#example","title":"Example","text":"<p>Given this file <code>src/file_state.nim</code>:</p> <pre><code>import typestates\n\ntype\n  File = object\n    path: string\n  Closed = distinct File\n  Open = distinct File\n\ntypestate File:\n  states Closed, Open\n  transitions:\n    Closed -&gt; Open\n    Open -&gt; Closed\n\nproc open(f: Closed): Open {.transition.} =\n  result = Open(f)\n\nproc close(f: Open): Closed {.transition.} =\n  result = Closed(f)\n</code></pre> <p>Running verification:</p> <pre><code>$ typestates verify src/\nChecked 1 files, 2 transitions\n\nAll checks passed!\n</code></pre>"},{"location":"guide/cli/#error-output","title":"Error Output","text":"<p>If a proc is missing the required pragma:</p> <pre><code># Missing {.transition.} pragma!\nproc open(f: Closed): Open =\n  result = Open(f)\n</code></pre> <pre><code>$ typestates verify src/\nChecked 1 files, 1 transitions\nERROR: src/file_state.nim:15 - Unmarked proc on state 'Closed' (strictTransitions enabled)\n\n1 error(s) found\n</code></pre>"},{"location":"guide/cli/#syntax-error-handling","title":"Syntax Error Handling","text":"<p>The CLI uses Nim's AST parser for accurate extraction. Files must be valid Nim syntax:</p> <pre><code>$ typestates verify src/\nERROR: Parse error in src/broken.nim: invalid indentation\n</code></pre> <p>This is intentional - a verification tool should not silently skip files it cannot parse.</p>"},{"location":"guide/cli/#dot-command","title":"Dot Command","text":"<p>The <code>dot</code> command generates GraphViz DOT output for visualizing state machines.</p> <p>See Visualization for detailed usage and examples.</p>"},{"location":"guide/cli/#basic-usage_1","title":"Basic Usage","text":"<pre><code>typestates dot src/\ntypestates dot src/ &gt; states.dot\ntypestates dot src/ | dot -Tpng -o states.png\n</code></pre>"},{"location":"guide/cli/#options","title":"Options","text":"Option Description <code>--splines=MODE</code> Edge routing: <code>spline</code> (default), <code>ortho</code>, <code>polyline</code>, <code>line</code> <code>--separate</code> Generate separate graph per typestate <code>--no-style</code> Output minimal DOT without styling <pre><code># Curved edges (default)\ntypestates dot src/\n\n# Right-angle edges\ntypestates dot --splines=ortho src/\n\n# Minimal output for custom styling\ntypestates dot --no-style src/\n</code></pre>"},{"location":"guide/cli/#ci-integration","title":"CI Integration","text":""},{"location":"guide/cli/#github-actions","title":"GitHub Actions","text":"<pre><code>- name: Install typestates\n  run: nimble install typestates -y\n\n- name: Verify typestates\n  run: typestates verify src/\n</code></pre>"},{"location":"guide/cli/#circleci","title":"CircleCI","text":"<pre><code>- run:\n    name: Verify typestates\n    command: |\n      nimble install typestates -y\n      typestates verify src/\n</code></pre>"},{"location":"guide/cli/#nimble-task","title":"Nimble Task","text":"<p>Add a verification task to your <code>.nimble</code> file:</p> <pre><code>task verify, \"Verify typestate rules\":\n  exec \"typestates verify src/\"\n</code></pre> <p>Then run:</p> <pre><code>nimble verify\n</code></pre>"},{"location":"guide/dsl-reference/","title":"DSL Reference","text":""},{"location":"guide/dsl-reference/#dsl-reference","title":"DSL Reference","text":"<p>Complete reference for the nim-typestates DSL syntax.</p>"},{"location":"guide/dsl-reference/#typestate-block","title":"Typestate Block","text":"<pre><code>typestate TypeName:\n  states State1, State2, State3\n  transitions:\n    State1 -&gt; State2\n    State2 -&gt; State3\n</code></pre>"},{"location":"guide/dsl-reference/#states-declaration","title":"States Declaration","text":"<p>List all state types that participate in this typestate:</p> <pre><code>states Closed, Open, Reading, Writing, Errored\n</code></pre> <p>Or use multiline format for readability:</p> <pre><code>states:\n  Closed\n  Open\n  Reading\n  Writing\n  Errored\n</code></pre> <p>Each state must be a <code>distinct</code> type of the base type:</p> <pre><code>type\n  File = object\n    # ...\n  Closed = distinct File\n  Open = distinct File\n</code></pre>"},{"location":"guide/dsl-reference/#transitions-block","title":"Transitions Block","text":"<p>Declare valid state transitions using <code>-&gt;</code> syntax:</p> <pre><code>transitions:\n  Closed -&gt; Open\n  Open -&gt; Closed\n</code></pre>"},{"location":"guide/dsl-reference/#transition-syntax","title":"Transition Syntax","text":""},{"location":"guide/dsl-reference/#simple-transitions","title":"Simple Transitions","text":"<p>One source state to one destination:</p> <pre><code>Closed -&gt; Open\n</code></pre>"},{"location":"guide/dsl-reference/#branching-transitions","title":"Branching Transitions","text":"<p>One source state to multiple possible destinations using <code>|</code>, with a required result type name:</p> <pre><code>Closed -&gt; (Open | Errored) as OpenResult\n</code></pre> <p>The <code>as TypeName</code> syntax names the generated branch type. This is required for all branching transitions.</p> <p>This means a proc taking <code>Closed</code> can return either <code>Open</code> or <code>Errored</code>, wrapped in an <code>OpenResult</code> variant type.</p>"},{"location":"guide/dsl-reference/#wildcard-transitions","title":"Wildcard Transitions","text":"<p>Any state can transition to a destination using <code>*</code>:</p> <pre><code>* -&gt; Closed\n</code></pre> <p>Wildcards are useful for \"reset\" or \"cleanup\" operations that work from any state.</p>"},{"location":"guide/dsl-reference/#initial-and-terminal-states","title":"Initial and Terminal States","text":"<p>Declare entry and exit points for your typestate:</p>"},{"location":"guide/dsl-reference/#initial-states","title":"Initial States","text":"<p>States that can only be constructed, not transitioned TO:</p> <pre><code>initial: Disconnected\n</code></pre> <p>Or multiple:</p> <pre><code>initial: Disconnected, Starting\n</code></pre> <p>Attempting to transition TO an initial state produces a compile-time error:</p> <pre><code>Error: Cannot transition TO initial state 'Disconnected'.\n  Initial states can only be constructed, not transitioned to.\n</code></pre>"},{"location":"guide/dsl-reference/#terminal-states","title":"Terminal States","text":"<p>States that cannot transition FROM (end states):</p> <pre><code>terminal: Closed\n</code></pre> <p>Or multiple:</p> <pre><code>terminal: Closed, Failed\n</code></pre> <p>Attempting to transition FROM a terminal state produces a compile-time error:</p> <pre><code>Error: Cannot transition FROM terminal state 'Closed'.\n  Terminal states are end states with no outgoing transitions.\n</code></pre>"},{"location":"guide/dsl-reference/#complete-example","title":"Complete Example","text":"<pre><code>typestate Connection:\n  states Disconnected, Connected, Closed\n  initial: Disconnected\n  terminal: Closed\n  transitions:\n    Disconnected -&gt; Connected\n    Connected -&gt; Closed\n</code></pre>"},{"location":"guide/dsl-reference/#flags","title":"Flags","text":"<p>Configuration options for the typestate. Flags can appear anywhere in the block.</p>"},{"location":"guide/dsl-reference/#stricttransitions","title":"<code>strictTransitions</code>","text":"<p>When <code>true</code> (default), all procs that take a state type must be marked with either <code>{.transition.}</code> or <code>{.notATransition.}</code>.</p> <pre><code>typestate File:\n  strictTransitions = false  # Allow unmarked procs\n  states Closed, Open\n  transitions:\n    Closed -&gt; Open\n</code></pre>"},{"location":"guide/dsl-reference/#consumeontransition","title":"<code>consumeOnTransition</code>","text":"<p>When <code>true</code> (default), generates <code>=copy</code> hooks that prevent copying state values. This enforces ownership semantics - each state value can only be used once.</p> <pre><code>typestate File:\n  consumeOnTransition = false  # Allow copying states\n  states Closed, Open\n  transitions:\n    Closed -&gt; Open\n</code></pre>"},{"location":"guide/dsl-reference/#inheritsfromrootobj","title":"<code>inheritsFromRootObj</code>","text":"<p>Set to <code>true</code> if your base type inherits from <code>RootObj</code>. This suppresses a compile-time error for static generic typestates on Nim &lt; 2.2.8.</p> <pre><code>type\n  Buffer[N: static int] = object of RootObj  # Note: inherits from RootObj\n    data: array[N, byte]\n  Empty[N: static int] = distinct Buffer[N]\n  Full[N: static int] = distinct Buffer[N]\n\ntypestate Buffer[N: static int]:\n  inheritsFromRootObj = true  # Required for static generics with RootObj on Nim &lt; 2.2.8\n  states Empty[N], Full[N]\n  transitions:\n    Empty[N] -&gt; Full[N]\n</code></pre> <p>See the Nim codegen bug for details.</p>"},{"location":"guide/dsl-reference/#bridges","title":"Bridges","text":"<p>Cross-typestate transitions declared with dotted notation.</p>"},{"location":"guide/dsl-reference/#syntax","title":"Syntax","text":"<pre><code>bridges:\n  SourceState -&gt; DestTypestate.DestState\n  SourceState -&gt; (DestTypestate.State1 | DestTypestate.State2)  # Branching\n  * -&gt; DestTypestate.DestState  # Wildcard\n</code></pre>"},{"location":"guide/dsl-reference/#requirements","title":"Requirements","text":"<ul> <li>Destination typestate must be imported</li> <li>Destination typestate and state must exist</li> <li>Bridge must be declared before implementation</li> </ul>"},{"location":"guide/dsl-reference/#examples","title":"Examples","text":"<p>Simple bridge:</p> <pre><code>bridges:\n  Authenticated -&gt; Session.Active\n</code></pre> <p>Branching bridge:</p> <pre><code>bridges:\n  Authenticated -&gt; (Session.Active | Session.Guest)\n</code></pre> <p>Wildcard bridge:</p> <pre><code>bridges:\n  * -&gt; Shutdown.Terminal\n</code></pre> <p>See Bridges for full documentation.</p>"},{"location":"guide/dsl-reference/#pragmas","title":"Pragmas","text":""},{"location":"guide/dsl-reference/#transition","title":"<code>{.transition.}</code>","text":"<p>Mark a proc as a state transition. The compiler validates that the transition is declared.</p> <pre><code>proc open(f: Closed): Open {.transition.} =\n  result = Open(f)\n</code></pre> <p>Validation rules:</p> <ul> <li>First parameter must be a registered state type</li> <li>Return type must be a valid transition target</li> <li>Transition must be declared in the typestate block</li> <li>Automatically gets <code>{.raises: [].}</code> added if not specified - errors should be states, not exceptions</li> <li>If you explicitly write <code>{.raises: [SomeError].}</code>, compilation will fail</li> </ul> <p>See Error Handling for patterns on modeling errors as states.</p> <p>Error on invalid transition:</p> <pre><code>Error: Undeclared transition: Open -&gt; Locked\n  Typestate 'File' does not declare this transition.\n  Valid transitions from 'Open': @[\"Closed\"]\n  Hint: Add 'Open -&gt; Locked' to the transitions block.\n</code></pre>"},{"location":"guide/dsl-reference/#notatransition","title":"<code>{.notATransition.}</code>","text":"<p>Mark a proc as intentionally NOT a transition. Use for procs that operate on state types but don't change state:</p> <pre><code>proc write(f: Open, data: string) {.notATransition.} =\n  # Writes data but stays in Open state\n  rawWrite(f.File.handle, data)\n\nproc read(f: Open, count: int): string {.notATransition.} =\n  # Reads data but stays in Open state\n  result = rawRead(f.File.handle, count)\n</code></pre> <p>For pure functions (no side effects), use <code>func</code> instead - no pragma needed:</p> <pre><code>func path(f: Open): string =\n  f.File.path\n</code></pre>"},{"location":"guide/dsl-reference/#generated-types","title":"Generated Types","text":"<p>For <code>typestate File:</code> with states <code>Closed</code>, <code>Open</code>, <code>Errored</code>:</p>"},{"location":"guide/dsl-reference/#state-enum","title":"State Enum","text":"<pre><code>type FileState* = enum\n  fsClosed, fsOpen, fsErrored\n</code></pre> <p>Enum values are prefixed with <code>fs</code> (for \"file state\") to avoid name collisions.</p>"},{"location":"guide/dsl-reference/#union-type","title":"Union Type","text":"<pre><code>type FileStates* = Closed | Open | Errored\n</code></pre> <p>Useful for generic procs that accept any state:</p> <pre><code>proc describe[S: FileStates](f: S): string =\n  case f.state\n  of fsClosed: \"closed\"\n  of fsOpen: \"open\"\n  of fsErrored: \"errored\"\n</code></pre>"},{"location":"guide/dsl-reference/#state-procs","title":"State Procs","text":"<pre><code>proc state*(f: Closed): FileState = fsClosed\nproc state*(f: Open): FileState = fsOpen\nproc state*(f: Errored): FileState = fsErrored\n</code></pre>"},{"location":"guide/dsl-reference/#branch-types","title":"Branch Types","text":"<p>For branching transitions like <code>Created -&gt; (Approved | Declined | Review) as ProcessResult</code>, the macro generates types and helpers for returning multiple possible states.</p> <p>Usage with the <code>-&gt;</code> operator:</p> <pre><code>proc process(c: Created): ProcessResult {.transition.} =\n  if c.Payment.amount &gt; 100:\n    ProcessResult -&gt; Approved(c.Payment)\n  elif c.Payment.amount &gt; 50:\n    ProcessResult -&gt; Review(c.Payment)\n  else:\n    ProcessResult -&gt; Declined(c.Payment)\n</code></pre> <p>The <code>-&gt;</code> operator takes the branch type on the left and the destination state on the right. This mirrors the DSL syntax and is unambiguous even when the same state appears in multiple branch types.</p> <p>Pattern matching on the result:</p> <pre><code>let result = process(created)\ncase result.kind\nof pApproved: echo \"Approved: \", result.approved.Payment.amount\nof pDeclined: echo \"Declined\"\nof pReview: echo \"Needs review\"\n</code></pre> <p>What gets generated:</p> <p>The <code>-&gt;</code> operator is syntactic sugar around constructor procs. For each branching transition with <code>as TypeName</code>, the macro generates:</p> <ol> <li> <p>Enum - <code>ProcessResultKind = enum pApproved, pDeclined, pReview</code>    (prefix is first letter of type name, e.g., <code>p</code> for ProcessResult)</p> </li> <li> <p>Variant object - <code>ProcessResult</code> holding the result</p> </li> <li> <p>Constructor procs - <code>toProcessResult(s: Approved): ProcessResult</code> etc.</p> </li> <li> <p><code>-&gt;</code> operator - <code>template -&gt;(T: typedesc[ProcessResult], s: Approved)</code> etc.</p> </li> </ol> <p>You can use the constructors directly if preferred:</p> <pre><code>toProcessResult(Approved(c.Payment))  # Equivalent to: ProcessResult -&gt; Approved(c.Payment)\n</code></pre> <p>See Returning Union Types for more examples.</p>"},{"location":"guide/dsl-reference/#complete-example_1","title":"Complete Example","text":"<pre><code>import typestates\n\ntype\n  Connection = object\n    host: string\n    port: int\n    socket: int\n\n  Disconnected = distinct Connection\n  Connecting = distinct Connection\n  Connected = distinct Connection\n  Errored = distinct Connection\n\ntypestate Connection:\n  states Disconnected, Connecting, Connected, Errored\n  transitions:\n    Disconnected -&gt; Connecting\n    Connecting -&gt; (Connected | Errored) as ConnectResult\n    Connected -&gt; Disconnected\n    Errored -&gt; Disconnected\n    * -&gt; Disconnected  # Can always disconnect\n\nproc connect(c: Disconnected, host: string, port: int): Connecting {.transition.} =\n  var conn = c.Connection\n  conn.host = host\n  conn.port = port\n  result = Connecting(conn)\n\nproc waitForConnection(c: Connecting): ConnectResult {.transition.} =\n  # In real code, this would do async I/O\n  if true:  # Pretend success\n    ConnectResult -&gt; Connected(c.Connection)\n  else:\n    ConnectResult -&gt; Errored(c.Connection)\n\n# Wildcard transitions require separate procs for each source state.\n# The {.transition.} pragma validates each at compile time.\nproc disconnect(c: Disconnected): Disconnected {.transition.} =\n  result = c  # Already disconnected\n\nproc disconnect(c: Connecting): Disconnected {.transition.} =\n  var conn = c.Connection\n  conn.socket = 0\n  result = Disconnected(conn)\n\nproc disconnect(c: Connected): Disconnected {.transition.} =\n  var conn = c.Connection\n  conn.socket = 0\n  result = Disconnected(conn)\n\nproc disconnect(c: Errored): Disconnected {.transition.} =\n  var conn = c.Connection\n  conn.socket = 0\n  result = Disconnected(conn)\n\nproc send(c: Connected, data: string) {.notATransition.} =\n  # Send data, stay connected\n  discard\n</code></pre>"},{"location":"guide/dsl-reference/#tips","title":"Tips","text":""},{"location":"guide/dsl-reference/#accessing-the-base-type","title":"Accessing the Base Type","text":"<p>State types are <code>distinct</code>, so you need to convert to access fields:</p> <pre><code>proc path(f: Open): string =\n  f.File.path  # Convert Open to File to access .path\n</code></pre>"},{"location":"guide/dsl-reference/#returning-union-types","title":"Returning Union Types","text":"<p>For branching transitions, use the <code>-&gt;</code> operator with the generated branch type:</p> <pre><code># Branching transition: Connecting -&gt; (Connected | Errored) as ConnectResult\nproc waitForConnection(c: Connecting): ConnectResult {.transition.} =\n  if success:\n    ConnectResult -&gt; Connected(c.Connection)\n  else:\n    ConnectResult -&gt; Errored(c.Connection)\n</code></pre> <p>Then pattern match on the result:</p> <pre><code>let result = conn.waitForConnection()\ncase result.kind\nof cConnected:\n  echo \"Connected!\"\n  sendData(result.connected)\nof cErrored:\n  echo \"Error: \", result.errored.message\n</code></pre> <p>Why branch types? Nim's <code>A | B</code> syntax creates a generic type constraint, not a runtime sum type. You cannot actually return different types from if/else branches. The generated branch types solve this by wrapping the result in an object variant.</p>"},{"location":"guide/dsl-reference/#generic-over-all-states","title":"Generic Over All States","text":"<p>Use the generated union type for generic procs:</p> <pre><code>proc forceClose[S: FileStates](f: S): Closed =\n  Closed(f.File)\n</code></pre>"},{"location":"guide/error-handling/","title":"Error Handling","text":""},{"location":"guide/error-handling/#error-handling","title":"Error Handling","text":"<p>Typestates model errors as states, not exceptions. If an operation can fail, the failure is a state the object transitions to.</p>"},{"location":"guide/error-handling/#the-rule","title":"The Rule","text":"<p>All <code>{.transition.}</code> procs must have <code>{.raises: [].}</code> - either explicitly declared or inferred. The library enforces this at compile time.</p>"},{"location":"guide/error-handling/#why","title":"Why?","text":"<p>Exceptions bypass the state machine. If a transition raises an exception, the caller never receives the promised state. The object's logical state becomes undefined.</p> <p>Error states are explicit and trackable. The type system knows about them, and callers must handle them.</p>"},{"location":"guide/error-handling/#example","title":"Example","text":"<pre><code># Wrong: exception bypasses state machine\nproc open(f: Closed, path: string): Open {.transition.} =\n  if not fileExists(path):\n    raise newException(IOError, \"not found\")  # Compile error!\n  ...\n\n# Right: error is a state, use branch type\n# (assumes: Closed -&gt; (Open | OpenFailed) as OpenResult)\nproc open(f: Closed, path: string): OpenResult {.transition.} =\n  if not fileExists(path):\n    return OpenResult -&gt; OpenFailed(f.File)\n  OpenResult -&gt; Open(f.File)\n</code></pre>"},{"location":"guide/error-handling/#defects-vs-exceptions","title":"Defects vs Exceptions","text":"<p>Nim distinguishes between Defects (bugs) and CatchableErrors (recoverable errors).</p>"},{"location":"guide/error-handling/#defects","title":"Defects","text":"<p>Programming errors that should not be caught:</p> <ul> <li><code>IndexDefect</code> - array/seq index out of bounds</li> <li><code>DivByZeroDefect</code> - division by zero</li> <li><code>AssertionDefect</code> - failed assertion</li> </ul> <p>Defects are NOT tracked by the <code>{.raises.}</code> pragma. A proc can have <code>{.raises: [].}</code> but still trigger a Defect if there's a bug.</p>"},{"location":"guide/error-handling/#catchableerrors","title":"CatchableErrors","text":"<p>Recoverable errors that callers can handle:</p> <ul> <li><code>IOError</code> - file/network operations</li> <li><code>ValueError</code> - parsing, conversion</li> <li><code>OSError</code> - system calls</li> </ul> <p>These ARE tracked by <code>{.raises.}</code>. Our enforcement prevents transitions from raising them.</p>"},{"location":"guide/error-handling/#what-typestates-guarantee","title":"What Typestates Guarantee","text":"<p>The library guarantees protocol correctness - you cannot call operations in the wrong state. It does NOT guarantee implementation correctness - your transition body might still have bugs that trigger Defects.</p> <p>Recommendation: Avoid Defect-prone operations in transitions, or guard them:</p> <pre><code># Risky: seq[i] can raise IndexDefect\nproc getItem(c: HasItems): Item {.transition, raises: [].} =\n  result = c.items[0]  # Bug if items is empty!\n\n# Safer: check first, return error state\n# (assumes: HasItems -&gt; (Item | Empty) as GetItemResult)\nproc getItem(c: HasItems): GetItemResult {.transition, raises: [].} =\n  if c.items.len == 0:\n    return GetItemResult -&gt; Empty(c.Container)\n  GetItemResult -&gt; Item(c.items[0])\n</code></pre>"},{"location":"guide/error-handling/#patterns","title":"Patterns","text":""},{"location":"guide/error-handling/#branching-transitions","title":"Branching Transitions","text":"<p>For transitions that can result in multiple states (success or failure), use the <code>as TypeName</code> syntax to name the branch type. Given:</p> <pre><code>typestate Connection:\n  states Disconnected, Connected, ConnectionFailed\n  transitions:\n    Disconnected -&gt; (Connected | ConnectionFailed) as ConnectResult\n    Connected -&gt; Disconnected\n    ConnectionFailed -&gt; Disconnected\n</code></pre> <p>The macro generates branch types and the <code>-&gt;</code> operator for constructing results.</p> <p>Use the <code>-&gt;</code> operator in your transition:</p> <pre><code>proc connect(c: Disconnected, host: string): ConnectResult {.transition, raises: [].} =\n  try:\n    let socket = connectSocket(host)\n    var conn = Connected(c.Connection)\n    conn.Connection.socket = socket\n    ConnectResult -&gt; conn\n  except OSError:\n    ConnectResult -&gt; ConnectionFailed(c.Connection)\n</code></pre> <p>The <code>-&gt;</code> operator takes the branch type on the left and the destination state on the right.</p> <p>Then pattern match on the result:</p> <pre><code>let result = connect(disconnected, \"localhost\")\ncase result.kind\nof cConnected:\n  echo \"Connected!\"\n  use(result.connected)\nof cConnectionFailed:\n  echo \"Failed to connect\"\n  retry(result.connectionfailed)\n</code></pre>"},{"location":"guide/error-handling/#wrap-external-calls","title":"Wrap External Calls","text":"<p>Create <code>{.raises: [].}</code> wrappers for exception-throwing APIs:</p> <pre><code>proc tryReadFile(path: string): Option[string] {.raises: [].} =\n  try:\n    result = some(readFile(path))\n  except IOError:\n    result = none(string)\n\n# (assumes: Empty -&gt; (Loaded | LoadFailed) as LoadResult)\nproc load(f: Empty, path: string): LoadResult {.transition, raises: [].} =\n  let content = tryReadFile(path)\n  if content.isNone:\n    return LoadResult -&gt; LoadFailed(f.Document)\n  var loaded = Loaded(f.Document)\n  loaded.Document.content = content.get\n  LoadResult -&gt; loaded\n</code></pre>"},{"location":"guide/error-handling/#result-types","title":"Result Types","text":"<p>Use Result[T, E] for structured error handling:</p> <pre><code># (assumes: Empty -&gt; (Loaded | LoadFailed) as LoadResult)\nproc load(f: Empty, path: string): LoadResult {.transition, raises: [].} =\n  let content = readFileResult(path)  # returns Result[string, IOError]\n  if content.isErr:\n    return LoadResult -&gt; LoadFailed(f.Document)\n  var loaded = Loaded(f.Document)\n  loaded.Document.content = content.get\n  LoadResult -&gt; loaded\n</code></pre>"},{"location":"guide/examples/","title":"Examples","text":""},{"location":"guide/examples/#examples","title":"Examples","text":"<p>Real-world patterns where typestates prevent expensive bugs.</p> <p>Running the Examples</p> <p>All examples are complete, runnable files in the <code>examples/</code> directory.</p> <pre><code>nim c -r examples/payment_processing.nim\n</code></pre>"},{"location":"guide/examples/#payment-processing","title":"Payment Processing","text":"<p>Payment processing requires strict ordering: authorize before capture, capture before refund. Typestates prevent costly mistakes like double-capture or refunds before capture.</p> <p>Bugs prevented: Capturing before authorization, double-capture, refunding before capture, operations on settled payments.</p> <pre><code>## Payment Processing with Typestates\n##\n## The payment processing flow is a perfect typestate example because mistakes\n## are EXPENSIVE. Charge before authorization? Chargeback. Refund twice?\n## Money gone. Capture an expired authorization? Failed transaction.\n##\n## This example models the standard payment flow:\n##   Created -&gt; Authorized -&gt; Captured -&gt; (Refunded | Settled)\n##\n## The typestate ensures you CANNOT:\n## - Capture without authorizing first\n## - Refund before capturing\n## - Capture an already-captured payment\n## - Authorize an already-authorized payment\n\nimport ../src/typestates\n\ntype\n  Payment = object\n    id: string\n    amount: int           # cents, to avoid float issues\n    currency: string\n    cardToken: string\n    authCode: string\n    capturedAt: int64\n    refundedAmount: int\n\n  # States represent where in the lifecycle this payment is\n  Created = distinct Payment      ## Just created, not yet authorized\n  Authorized = distinct Payment   ## Card charged, funds held, not yet captured\n  Captured = distinct Payment     ## Funds transferred to merchant\n  PartiallyRefunded = distinct Payment  ## Some amount refunded\n  FullyRefunded = distinct Payment      ## Entire amount refunded\n  Settled = distinct Payment      ## Batch settled, funds in bank\n  Voided = distinct Payment       ## Authorization cancelled before capture\n\ntypestate Payment:\n  # Payments may need status checks and can be refunded after completion.\n  consumeOnTransition = false\n  states Created, Authorized, Captured, PartiallyRefunded, FullyRefunded, Settled, Voided\n  transitions:\n    Created -&gt; Authorized\n    Authorized -&gt; (Captured | Voided) as AuthResult\n    Captured -&gt; (PartiallyRefunded | FullyRefunded | Settled) as CaptureResult\n    PartiallyRefunded -&gt; (PartiallyRefunded | FullyRefunded | Settled) as RefundResult\n    FullyRefunded -&gt; Settled\n\n# ============================================================================\n# Transition procedures - each one enforces the state machine\n# ============================================================================\n\nproc authorize(p: Created, cardToken: string): Authorized {.transition.} =\n  ## Authorize payment against the card.\n  ## This places a hold on the customer's funds but doesn't transfer them.\n  ## In production, this would call your payment processor API.\n  var payment = p.Payment\n  payment.cardToken = cardToken\n  payment.authCode = \"AUTH_\" &amp; payment.id\n  echo \"  [GATEWAY] Authorized $\", payment.amount, \" on card ending in ****\"\n  result = Authorized(payment)\n\nproc capture(p: Authorized): Captured {.transition.} =\n  ## Capture the authorized funds - money moves to merchant.\n  ## Must happen within auth window (usually 7 days).\n  var payment = p.Payment\n  payment.capturedAt = 1234567890  # In real code: current timestamp\n  echo \"  [GATEWAY] Captured $\", payment.amount, \" (auth: \", payment.authCode, \")\"\n  result = Captured(payment)\n\nproc void(p: Authorized): Voided {.transition.} =\n  ## Cancel the authorization before capture.\n  ## Releases the hold on customer's card - no money moved.\n  echo \"  [GATEWAY] Voided authorization \", p.Payment.authCode\n  result = Voided(p.Payment)\n\nproc partialRefund(p: Captured, amount: int): PartiallyRefunded {.transition.} =\n  ## Refund part of the captured amount.\n  var payment = p.Payment\n  payment.refundedAmount = amount\n  echo \"  [GATEWAY] Partial refund: $\", amount, \" of $\", payment.amount\n  result = PartiallyRefunded(payment)\n\nproc fullRefund(p: Captured): FullyRefunded {.transition.} =\n  ## Refund the entire captured amount.\n  var payment = p.Payment\n  payment.refundedAmount = payment.amount\n  echo \"  [GATEWAY] Full refund: $\", payment.amount\n  result = FullyRefunded(payment)\n\nproc additionalRefund(p: PartiallyRefunded, amount: int): RefundResult {.transition.} =\n  ## Add more refund to a partially refunded payment.\n  var payment = p.Payment\n  payment.refundedAmount += amount\n  echo \"  [GATEWAY] Additional refund: $\", amount\n  if payment.refundedAmount &gt;= payment.amount:\n    result = RefundResult -&gt; FullyRefunded(payment)\n  else:\n    result = RefundResult -&gt; PartiallyRefunded(payment)\n\nproc settle(p: Captured): Settled {.transition.} =\n  ## Batch settlement - funds deposited to merchant bank.\n  echo \"  [GATEWAY] Settled $\", p.Payment.amount, \" to merchant account\"\n  result = Settled(p.Payment)\n\nproc settle(p: PartiallyRefunded): Settled {.transition.} =\n  ## Settle a partially refunded payment (net amount).\n  let net = p.Payment.amount - p.Payment.refundedAmount\n  echo \"  [GATEWAY] Settled $\", net, \" (after refunds) to merchant account\"\n  result = Settled(p.Payment)\n\nproc settle(p: FullyRefunded): Settled {.transition.} =\n  ## Settle a fully refunded payment ($0 net).\n  echo \"  [GATEWAY] Settled $0 (fully refunded) - closing payment\"\n  result = Settled(p.Payment)\n\n# ============================================================================\n# Non-transition operations - query state without changing it\n# ============================================================================\n\nfunc amount(p: PaymentStates): int =\n  ## Get the payment amount in cents.\n  p.Payment.amount\n\nfunc refundedAmount(p: PartiallyRefunded): int =\n  ## How much has been refunded so far?\n  p.Payment.refundedAmount\n\nfunc remainingAmount(p: PartiallyRefunded): int =\n  ## How much can still be refunded?\n  p.Payment.amount - p.Payment.refundedAmount\n\n# ============================================================================\n# Example usage showing compile-time safety\n# ============================================================================\n\nwhen isMainModule:\n  echo \"=== Payment Processing Demo ===\\n\"\n\n  echo \"1. Creating payment for $99.99...\"\n  var payment = Created(Payment(\n    id: \"pay_abc123\",\n    amount: 9999,  # $99.99 in cents\n    currency: \"USD\"\n  ))\n\n  echo \"\\n2. Authorizing payment...\"\n  let authorized = payment.authorize(\"card_tok_visa_4242\")\n\n  echo \"\\n3. Capturing funds...\"\n  let captured = authorized.capture()\n\n  echo \"\\n4. Customer requests $25 refund...\"\n  let refunded = captured.partialRefund(2500)\n  echo \"   Remaining: $\", refunded.remainingAmount()\n\n  echo \"\\n5. End of day settlement...\"\n  let settled = refunded.settle()\n\n  echo \"\\n=== Payment lifecycle complete! ===\\n\"\n\n  # =========================================================================\n  # COMPILE-TIME ERRORS - These are the bugs the typestate PREVENTS:\n  # =========================================================================\n\n  echo \"The following bugs are caught at COMPILE TIME:\\n\"\n\n  # BUG 1: Capturing without authorization\n  # \"Oops, we forgot to auth - charged the wrong amount!\"\n  # let oops1 = payment.capture()\n  echo \"  [PREVENTED] capture() on Created payment\"\n\n  # BUG 2: Double-capture\n  # \"Customer charged twice!\"\n  # let oops2 = captured.capture()\n  echo \"  [PREVENTED] capture() on already-Captured payment\"\n\n  # BUG 3: Refunding before capture\n  # \"Refunded money we never had!\"\n  # let oops3 = authorized.partialRefund(1000)\n  echo \"  [PREVENTED] partialRefund() on Authorized payment\"\n\n  # BUG 4: Refunding a settled payment\n  # \"Accounting nightmare - refund after books closed!\"\n  # let oops4 = settled.partialRefund(500)\n  echo \"  [PREVENTED] partialRefund() on Settled payment\"\n\n  # BUG 5: Voiding after capture\n  # \"Tried to void but money already moved!\"\n  # let oops5 = captured.void()\n  echo \"  [PREVENTED] void() on Captured payment\"\n\n  echo \"\\nUncomment any of the 'oops' lines above to see the compile error!\"\n</code></pre> <p>:material-file-code: View full source</p>"},{"location":"guide/examples/#database-connection-pool","title":"Database Connection Pool","text":"<p>Connection pools have invariants that are easy to violate: don't query pooled connections, don't return connections mid-transaction, don't commit without a transaction.</p> <p>Bugs prevented: Query on pooled connection, returning connection while in transaction, committing without transaction, nested transactions.</p> <pre><code>## Database Connection Pool with Typestates\n##\n## Connection pool bugs are among the most painful to debug:\n## - Query on a closed connection: \"connection already closed\"\n## - Return connection to pool while query is running: data corruption\n## - Use connection after returning to pool: race conditions\n## - Forget to return connection: pool exhaustion\n##\n## This example ensures compile-time safety for connection lifecycle.\n\nimport ../src/typestates\n\ntype\n  DbConnection = object\n    id: int\n    host: string\n    port: int\n    database: string\n    inTransaction: bool\n    queryCount: int\n\n  # Connection states\n  Pooled = distinct DbConnection       ## In the pool, available for checkout\n  CheckedOut = distinct DbConnection   ## Checked out, not in transaction\n  InTransaction = distinct DbConnection ## Active transaction\n  Closed = distinct DbConnection        ## Permanently closed\n\ntypestate DbConnection:\n  # Connections are pooled and reused, so we disable ownership enforcement.\n  # This allows checkout -&gt; use -&gt; release -&gt; checkout cycles.\n  consumeOnTransition = false\n  states Pooled, CheckedOut, InTransaction, Closed\n  transitions:\n    Pooled -&gt; (CheckedOut | Closed) as CheckoutResult       # Checkout or close idle connection\n    CheckedOut -&gt; (Pooled | InTransaction | Closed) as CheckoutAction  # Return, begin tx, or close\n    InTransaction -&gt; CheckedOut         # Commit/rollback ends transaction\n    * -&gt; Closed                         # Can always force-close\n\n# ============================================================================\n# Connection Pool Operations\n# ============================================================================\n\nproc checkout(conn: Pooled): CheckedOut {.transition.} =\n  ## Get a connection from the pool for exclusive use.\n  echo \"  [POOL] Checked out connection #\", conn.DbConnection.id\n  result = CheckedOut(conn.DbConnection)\n\nproc release(conn: CheckedOut): Pooled {.transition.} =\n  ## Return connection to the pool.\n  echo \"  [POOL] Released connection #\", conn.DbConnection.id, \" (\", conn.DbConnection.queryCount, \" queries)\"\n  var c = conn.DbConnection\n  c.queryCount = 0\n  result = Pooled(c)\n\nproc close(conn: Pooled): Closed {.transition.} =\n  ## Close an idle connection permanently.\n  echo \"  [POOL] Closed idle connection #\", conn.DbConnection.id\n  result = Closed(conn.DbConnection)\n\nproc close(conn: CheckedOut): Closed {.transition.} =\n  ## Close a checked-out connection (emergency/error case).\n  echo \"  [POOL] Force-closed connection #\", conn.DbConnection.id\n  result = Closed(conn.DbConnection)\n\n# ============================================================================\n# Transaction Operations\n# ============================================================================\n\nproc beginTransaction(conn: CheckedOut): InTransaction {.transition.} =\n  ## Start a database transaction.\n  echo \"  [DB] BEGIN TRANSACTION\"\n  var c = conn.DbConnection\n  c.inTransaction = true\n  result = InTransaction(c)\n\nproc commit(conn: InTransaction): CheckedOut {.transition.} =\n  ## Commit the current transaction.\n  echo \"  [DB] COMMIT\"\n  var c = conn.DbConnection\n  c.inTransaction = false\n  result = CheckedOut(c)\n\nproc rollback(conn: InTransaction): CheckedOut {.transition.} =\n  ## Rollback the current transaction.\n  echo \"  [DB] ROLLBACK\"\n  var c = conn.DbConnection\n  c.inTransaction = false\n  result = CheckedOut(c)\n\n# ============================================================================\n# Query Operations (no state change)\n# ============================================================================\n\nproc execute(conn: CheckedOut, sql: string): CheckedOut {.notATransition.} =\n  ## Execute a SQL statement (outside transaction).\n  var c = conn.DbConnection\n  c.queryCount += 1\n  echo \"  [DB] Execute: \", sql\n  result = CheckedOut(c)\n\nproc execute(conn: InTransaction, sql: string): InTransaction {.notATransition.} =\n  ## Execute a SQL statement (inside transaction).\n  var c = conn.DbConnection\n  c.queryCount += 1\n  echo \"  [DB] Execute (in tx): \", sql\n  result = InTransaction(c)\n\nfunc isInTransaction(conn: DbConnectionStates): bool =\n  ## Check if connection has active transaction.\n  conn.DbConnection.inTransaction\n\n# ============================================================================\n# Example Usage\n# ============================================================================\n\nwhen isMainModule:\n  echo \"=== Database Connection Demo ===\\n\"\n\n  # Simulate a connection pool\n  var pooledConn = Pooled(DbConnection(\n    id: 42,\n    host: \"localhost\",\n    port: 5432,\n    database: \"myapp\"\n  ))\n\n  echo \"1. Checkout connection from pool...\"\n  let conn = pooledConn.checkout()\n\n  echo \"\\n2. Execute some queries...\"\n  let conn2 = conn.execute(\"SELECT * FROM users WHERE id = 1\")\n  let conn3 = conn2.execute(\"UPDATE users SET last_login = NOW() WHERE id = 1\")\n\n  echo \"\\n3. Start a transaction for batch insert...\"\n  let tx = conn3.beginTransaction()\n\n  echo \"\\n4. Execute transactional queries...\"\n  let tx2 = tx.execute(\"INSERT INTO audit_log VALUES (1, 'login', NOW())\")\n  let tx3 = tx2.execute(\"INSERT INTO sessions VALUES (1, 'abc123', NOW())\")\n\n  echo \"\\n5. Commit the transaction...\"\n  let afterTx = tx3.commit()\n\n  echo \"\\n6. Return connection to pool...\"\n  let returned = afterTx.release()\n\n  echo \"\\n=== Connection lifecycle complete! ===\\n\"\n\n  # =========================================================================\n  # COMPILE-TIME ERRORS - These bugs are prevented:\n  # =========================================================================\n\n  echo \"The following bugs are caught at COMPILE TIME:\\n\"\n\n  # BUG 1: Query on pooled (not checked out) connection\n  # let bad1 = returned.execute(\"SELECT 1\")\n  echo \"  [PREVENTED] execute() on Pooled connection\"\n\n  # BUG 2: Return connection while in transaction\n  # let bad2 = tx.release()\n  echo \"  [PREVENTED] release() on InTransaction connection\"\n\n  # BUG 3: Commit without starting transaction\n  # let bad3 = conn.commit()\n  echo \"  [PREVENTED] commit() on CheckedOut connection (no transaction)\"\n\n  # BUG 4: Double checkout (already checked out)\n  # let bad4 = conn.checkout()\n  echo \"  [PREVENTED] checkout() on CheckedOut connection\"\n\n  # BUG 5: Begin transaction inside transaction\n  # let bad5 = tx.beginTransaction()\n  echo \"  [PREVENTED] beginTransaction() on InTransaction connection\"\n\n  echo \"\\nUncomment any of the 'bad' lines above to see the compile error!\"\n</code></pre> <p>:material-file-code: View full source</p>"},{"location":"guide/examples/#http-request-lifecycle","title":"HTTP Request Lifecycle","text":"<p>HTTP requests follow a strict sequence: set headers, send headers, send body, await response. Typestates enforce this ordering at compile time.</p> <p>Bugs prevented: Adding headers after sent, sending body before headers, reading response before request complete.</p> <pre><code>## HTTP Request Lifecycle with Typestates\n##\n## HTTP requests have a strict lifecycle that's easy to mess up:\n## - Writing body after sending headers\n## - Reading response before sending request\n## - Sending headers twice\n## - Using a connection after it's closed\n##\n## This example models the full request/response lifecycle.\n\nimport ../src/typestates\n\ntype\n  HttpRequest = object\n    meth: string\n    path: string\n    headers: seq[(string, string)]\n    body: string\n    responseCode: int\n    responseBody: string\n\n  # Request states\n  Building = distinct HttpRequest      ## Accumulating headers\n  HeadersSent = distinct HttpRequest   ## Headers sent, can send body\n  RequestSent = distinct HttpRequest   ## Full request sent, awaiting response\n  ResponseReceived = distinct HttpRequest  ## Response received, can read\n  Closed = distinct HttpRequest        ## Connection closed\n\ntypestate HttpRequest:\n  # HTTP connections support keep-alive (reuse after response).\n  consumeOnTransition = false\n  states Building, HeadersSent, RequestSent, ResponseReceived, Closed\n  transitions:\n    Building -&gt; HeadersSent\n    HeadersSent -&gt; RequestSent         # Send body/finalize request\n    RequestSent -&gt; ResponseReceived    # Receive response\n    ResponseReceived -&gt; (Closed | Building) as ResponseAction  # Close or reuse for keep-alive\n    * -&gt; Closed                        # Can always abort\n\n# ============================================================================\n# Building the request\n# ============================================================================\n\nproc newRequest(meth: string, path: string): Building =\n  ## Create a new HTTP request builder.\n  echo \"  [HTTP] \", meth, \" \", path\n  result = Building(HttpRequest(meth: meth, path: path))\n\nproc header(req: Building, key: string, value: string): Building {.notATransition.} =\n  ## Add a header to the request.\n  var r = req.HttpRequest\n  r.headers.add((key, value))\n  echo \"  [HTTP] Header: \", key, \": \", value\n  result = Building(r)\n\nproc sendHeaders(req: Building): HeadersSent {.transition.} =\n  ## Finalize and send the headers.\n  echo \"  [HTTP] &gt;&gt;&gt; Sending headers...\"\n  result = HeadersSent(req.HttpRequest)\n\n# ============================================================================\n# Sending the request\n# ============================================================================\n\nproc sendBody(req: HeadersSent, body: string): RequestSent {.transition.} =\n  ## Send the request body (for POST, PUT, etc.).\n  var r = req.HttpRequest\n  r.body = body\n  echo \"  [HTTP] &gt;&gt;&gt; Sending body (\", body.len, \" bytes)\"\n  result = RequestSent(r)\n\nproc finish(req: HeadersSent): RequestSent {.transition.} =\n  ## Finish request without body (for GET, DELETE, etc.).\n  echo \"  [HTTP] &gt;&gt;&gt; Request complete (no body)\"\n  result = RequestSent(req.HttpRequest)\n\n# ============================================================================\n# Receiving the response\n# ============================================================================\n\nproc awaitResponse(req: RequestSent): ResponseReceived {.transition.} =\n  ## Wait for and receive the response.\n  var r = req.HttpRequest\n  # Simulate response\n  r.responseCode = 200\n  r.responseBody = \"\"\"{\"status\": \"ok\", \"data\": [1, 2, 3]}\"\"\"\n  echo \"  [HTTP] &lt;&lt;&lt; Response: \", r.responseCode\n  result = ResponseReceived(r)\n\nfunc statusCode(resp: ResponseReceived): int =\n  ## Get the HTTP status code.\n  resp.HttpRequest.responseCode\n\nfunc body(resp: ResponseReceived): string =\n  ## Get the response body.\n  resp.HttpRequest.responseBody\n\nfunc isSuccess(resp: ResponseReceived): bool =\n  ## Check if response indicates success (2xx).\n  let code = resp.HttpRequest.responseCode\n  code &gt;= 200 and code &lt; 300\n\n# ============================================================================\n# Closing or reusing\n# ============================================================================\n\nproc close(resp: ResponseReceived): Closed {.transition.} =\n  ## Close the connection.\n  echo \"  [HTTP] Connection closed\"\n  result = Closed(resp.HttpRequest)\n\nproc reuse(resp: ResponseReceived): Building {.transition.} =\n  ## Reuse connection for another request (keep-alive).\n  echo \"  [HTTP] Reusing connection (keep-alive)\"\n  var r = HttpRequest()  # Fresh request on same connection\n  result = Building(r)\n\n# ============================================================================\n# Example Usage\n# ============================================================================\n\nwhen isMainModule:\n  echo \"=== HTTP Request Demo ===\\n\"\n\n  echo \"1. Building GET request...\"\n  let req1 = newRequest(\"GET\", \"/api/users\")\n    .header(\"Accept\", \"application/json\")\n    .header(\"Authorization\", \"Bearer token123\")\n\n  echo \"\\n2. Sending headers...\"\n  let headersSent = req1.sendHeaders()\n\n  echo \"\\n3. Finishing request (no body for GET)...\"\n  let sent = headersSent.finish()\n\n  echo \"\\n4. Awaiting response...\"\n  let response = sent.awaitResponse()\n\n  echo \"\\n5. Reading response...\"\n  echo \"   Status: \", response.statusCode()\n  echo \"   Body: \", response.body()\n  echo \"   Success: \", response.isSuccess()\n\n  echo \"\\n6. Closing connection...\"\n  let closed = response.close()\n\n  echo \"\\n=== Request lifecycle complete! ===\\n\"\n\n  # =========================================================================\n  # COMPILE-TIME ERRORS - These bugs are prevented:\n  # =========================================================================\n\n  echo \"The following bugs are caught at COMPILE TIME:\\n\"\n\n  # BUG 1: Adding headers after they're sent\n  # let bad1 = headersSent.header(\"X-Late\", \"header\")\n  echo \"  [PREVENTED] header() after sendHeaders()\"\n\n  # BUG 2: Sending body on GET (before sending headers)\n  # let bad2 = req1.sendBody(\"data\")\n  echo \"  [PREVENTED] sendBody() before sendHeaders()\"\n\n  # BUG 3: Reading response before request is sent\n  # let bad3 = headersSent.statusCode()\n  echo \"  [PREVENTED] statusCode() before response received\"\n\n  # BUG 4: Sending more data after request is complete\n  # let bad4 = sent.sendBody(\"more data\")\n  echo \"  [PREVENTED] sendBody() after request sent\"\n\n  # BUG 5: Using closed connection\n  # let bad5 = closed.reuse()\n  echo \"  [PREVENTED] reuse() on Closed connection\"\n\n  echo \"\\nUncomment any of the 'bad' lines above to see the compile error!\"\n</code></pre> <p>:material-file-code: View full source</p>"},{"location":"guide/examples/#oauth-authentication","title":"OAuth Authentication","text":"<p>OAuth requires authenticated tokens for API calls and refresh tokens to renew expired access. Typestates prevent calls with missing or expired credentials.</p> <p>Bugs prevented: API calls without authentication, API calls with expired token, refreshing non-expired token.</p> <pre><code>## OAuth 2.0 Authentication Flow with Typestates\n##\n## OAuth flows are notoriously easy to get wrong:\n## - Using an expired token\n## - Calling API before authenticating\n## - Refreshing with an invalid refresh token\n## - Skipping PKCE verification\n##\n## This example models the Authorization Code + PKCE flow.\n\nimport ../src/typestates\n\ntype\n  OAuthSession = object\n    clientId: string\n    redirectUri: string\n    codeVerifier: string     # PKCE\n    codeChallenge: string    # PKCE\n    authCode: string\n    accessToken: string\n    refreshToken: string\n    expiresAt: int64\n\n  # OAuth states\n  Unauthenticated = distinct OAuthSession  ## No tokens yet\n  AwaitingCallback = distinct OAuthSession ## Auth URL generated, waiting for callback\n  Authenticated = distinct OAuthSession    ## Have valid access token\n  TokenExpired = distinct OAuthSession     ## Access token expired, need refresh\n  RefreshFailed = distinct OAuthSession    ## Refresh failed, need re-auth\n\ntypestate OAuthSession:\n  # OAuth tokens may be read multiple times and refreshed.\n  consumeOnTransition = false\n  states Unauthenticated, AwaitingCallback, Authenticated, TokenExpired, RefreshFailed\n  transitions:\n    Unauthenticated -&gt; AwaitingCallback    # Start auth flow\n    AwaitingCallback -&gt; Authenticated      # Callback received, tokens exchanged\n    Authenticated -&gt; TokenExpired          # Token expired\n    TokenExpired -&gt; Authenticated          # Refresh succeeded\n    TokenExpired -&gt; RefreshFailed          # Refresh failed\n    RefreshFailed -&gt; AwaitingCallback      # Start over\n    * -&gt; Unauthenticated                   # Logout\n\n# ============================================================================\n# Starting the flow\n# ============================================================================\n\nproc startAuth(session: Unauthenticated, clientId: string, redirectUri: string): AwaitingCallback {.transition.} =\n  ## Generate authorization URL and PKCE challenge.\n  var s = session.OAuthSession\n  s.clientId = clientId\n  s.redirectUri = redirectUri\n  s.codeVerifier = \"random_verifier_string_43_chars_min\"  # In prod: secure random\n  s.codeChallenge = \"hashed_challenge\"  # In prod: SHA256(verifier)\n\n  let authUrl = \"https://auth.example.com/authorize?\" &amp;\n    \"client_id=\" &amp; clientId &amp;\n    \"&amp;redirect_uri=\" &amp; redirectUri &amp;\n    \"&amp;code_challenge=\" &amp; s.codeChallenge &amp;\n    \"&amp;code_challenge_method=S256\"\n\n  echo \"  [OAUTH] Authorization URL generated\"\n  echo \"  [OAUTH] Redirect user to: \", authUrl[0..50], \"...\"\n  result = AwaitingCallback(s)\n\n# ============================================================================\n# Handling the callback\n# ============================================================================\n\nproc handleCallback(session: AwaitingCallback, authCode: string): Authenticated {.transition.} =\n  ## Exchange authorization code for tokens.\n  var s = session.OAuthSession\n  s.authCode = authCode\n\n  # In production: POST to token endpoint with code + code_verifier\n  echo \"  [OAUTH] Exchanging auth code for tokens...\"\n  echo \"  [OAUTH] Verifying PKCE: code_verifier=\", s.codeVerifier[0..10], \"...\"\n\n  s.accessToken = \"eyJhbGc...\" &amp; authCode[0..5]\n  s.refreshToken = \"refresh_\" &amp; authCode[0..5]\n  s.expiresAt = 1234567890 + 3600\n\n  echo \"  [OAUTH] Access token received (expires in 1h)\"\n  result = Authenticated(s)\n\n# ============================================================================\n# Using the API\n# ============================================================================\n\nproc callApi(session: Authenticated, endpoint: string): string {.notATransition.} =\n  ## Make an authenticated API call.\n  echo \"  [API] GET \", endpoint\n  echo \"  [API] Authorization: Bearer \", session.OAuthSession.accessToken[0..10], \"...\"\n  result = \"\"\"{\"user\": \"alice\", \"email\": \"alice@example.com\"}\"\"\"\n\nproc getAccessToken(session: Authenticated): string =\n  ## Get the current access token for manual use.\n  session.OAuthSession.accessToken\n\n# ============================================================================\n# Token expiration and refresh\n# ============================================================================\n\nproc tokenExpired(session: Authenticated): TokenExpired {.transition.} =\n  ## Mark the access token as expired.\n  echo \"  [OAUTH] Access token expired!\"\n  result = TokenExpired(session.OAuthSession)\n\nproc refresh(session: TokenExpired): Authenticated {.transition.} =\n  ## Refresh the access token using the refresh token.\n  var s = session.OAuthSession\n\n  # In production: POST to token endpoint with refresh_token\n  echo \"  [OAUTH] Refreshing token using: \", s.refreshToken[0..10], \"...\"\n\n  s.accessToken = \"eyJhbGc...refreshed\"\n  s.expiresAt = 1234567890 + 7200\n\n  echo \"  [OAUTH] New access token received\"\n  result = Authenticated(s)\n\nproc refreshFailed(session: TokenExpired): RefreshFailed {.transition.} =\n  ## Handle refresh failure (e.g., refresh token revoked).\n  echo \"  [OAUTH] Refresh failed! Token may be revoked.\"\n  result = RefreshFailed(session.OAuthSession)\n\nproc restartAuth(session: RefreshFailed): AwaitingCallback {.transition.} =\n  ## Start authentication flow again after refresh failure.\n  var s = session.OAuthSession\n  s.accessToken = \"\"\n  s.refreshToken = \"\"\n  s.codeVerifier = \"new_verifier_for_retry\"\n  s.codeChallenge = \"new_challenge\"\n\n  echo \"  [OAUTH] Starting fresh authentication...\"\n  result = AwaitingCallback(s)\n\n# ============================================================================\n# Logout\n# ============================================================================\n\nproc logout(session: Authenticated): Unauthenticated {.transition.} =\n  ## Log out and revoke tokens.\n  echo \"  [OAUTH] Logging out, revoking tokens...\"\n  result = Unauthenticated(OAuthSession())\n\n# ============================================================================\n# Example Usage\n# ============================================================================\n\nwhen isMainModule:\n  echo \"=== OAuth 2.0 Authentication Demo ===\\n\"\n\n  echo \"1. Creating unauthenticated session...\"\n  let session = Unauthenticated(OAuthSession())\n\n  echo \"\\n2. Starting OAuth flow (PKCE)...\"\n  let awaiting = session.startAuth(\n    clientId = \"my-app-client-id\",\n    redirectUri = \"myapp://callback\"\n  )\n\n  echo \"\\n3. User authorizes, handling callback...\"\n  let authed = awaiting.handleCallback(authCode = \"abc123xyz\")\n\n  echo \"\\n4. Making authenticated API calls...\"\n  let userData = authed.callApi(\"/api/user/me\")\n  echo \"   Response: \", userData\n\n  echo \"\\n5. Simulating token expiration...\"\n  let expired = authed.tokenExpired()\n\n  echo \"\\n6. Refreshing access token...\"\n  let refreshed = expired.refresh()\n\n  echo \"\\n7. Making another API call with new token...\"\n  let moreData = refreshed.callApi(\"/api/user/settings\")\n\n  echo \"\\n8. Logging out...\"\n  let loggedOut = refreshed.logout()\n\n  echo \"\\n=== OAuth flow complete! ===\\n\"\n\n  # =========================================================================\n  # COMPILE-TIME ERRORS - These bugs are prevented:\n  # =========================================================================\n\n  echo \"The following bugs are caught at COMPILE TIME:\\n\"\n\n  # BUG 1: API call without authentication\n  # let bad1 = session.callApi(\"/api/secret\")\n  echo \"  [PREVENTED] callApi() on Unauthenticated session\"\n\n  # BUG 2: API call with expired token\n  # let bad2 = expired.callApi(\"/api/data\")\n  echo \"  [PREVENTED] callApi() on TokenExpired session\"\n\n  # BUG 3: Refresh without expiration\n  # let bad3 = authed.refresh()\n  echo \"  [PREVENTED] refresh() on Authenticated session (not expired)\"\n\n  # BUG 4: Handle callback twice\n  # let bad4 = authed.handleCallback(\"another_code\")\n  echo \"  [PREVENTED] handleCallback() on Authenticated session\"\n\n  # BUG 5: Use logged out session\n  # let bad5 = loggedOut.getAccessToken()\n  echo \"  [PREVENTED] getAccessToken() on Unauthenticated session\"\n\n  echo \"\\nUncomment any of the 'bad' lines above to see the compile error!\"\n</code></pre> <p>:material-file-code: View full source</p>"},{"location":"guide/examples/#robot-arm-controller","title":"Robot Arm Controller","text":"<p>Hardware control requires strict operation sequences. Moving without homing can crash into limits; powering off during movement can damage motors.</p> <p>Bugs prevented: Moving without homing, power off while moving, continuing after emergency stop.</p> <pre><code>## Robot Arm Controller with Typestates\n##\n## Hardware control is where typestates REALLY shine. Wrong operation order\n## can damage expensive equipment or cause safety hazards:\n## - Moving arm before homing: crash into limits\n## - Operating without calibration: inaccurate positioning\n## - Emergency stop not handled: damage or injury\n## - Power off while moving: motor damage\n##\n## This example models a robotic arm controller with safety states.\n\nimport ../src/typestates\n\ntype\n  RobotArm = object\n    x, y, z: float          # Current position\n    homeX, homeY, homeZ: float  # Home position\n    speed: float            # Movement speed\n    toolAttached: bool\n    emergencyReason: string\n\n  # Robot arm states\n  PoweredOff = distinct RobotArm     ## No power to motors\n  Initializing = distinct RobotArm   ## Powering up, running diagnostics\n  NeedsHoming = distinct RobotArm    ## Powered but position unknown\n  Homing = distinct RobotArm         ## Currently finding home position\n  Ready = distinct RobotArm          ## Homed and ready for commands\n  Moving = distinct RobotArm         ## Currently executing movement\n  EmergencyStop = distinct RobotArm  ## E-stop triggered, frozen\n\ntypestate RobotArm:\n  # Robot arm state needs to be inspected for position, calibration, etc.\n  consumeOnTransition = false\n  states PoweredOff, Initializing, NeedsHoming, Homing, Ready, Moving, EmergencyStop\n  transitions:\n    PoweredOff -&gt; Initializing\n    Initializing -&gt; NeedsHoming\n    NeedsHoming -&gt; Homing\n    Homing -&gt; Ready\n    Ready -&gt; (Moving | PoweredOff) as ReadyAction\n    Moving -&gt; (Ready | EmergencyStop) as MovementResult\n    EmergencyStop -&gt; (NeedsHoming | PoweredOff) as EmergencyAction  # Must re-home after E-stop\n\n# ============================================================================\n# Power and Initialization\n# ============================================================================\n\nproc powerOn(arm: PoweredOff): Initializing {.transition.} =\n  ## Power on the robot arm and start initialization.\n  echo \"  [ARM] Powering on...\"\n  echo \"  [ARM] Running motor diagnostics...\"\n  result = Initializing(arm.RobotArm)\n\nproc completeInit(arm: Initializing): NeedsHoming {.transition.} =\n  ## Complete initialization, now needs homing.\n  echo \"  [ARM] Diagnostics passed\"\n  echo \"  [ARM] WARNING: Position unknown - homing required!\"\n  result = NeedsHoming(arm.RobotArm)\n\nproc powerOff(arm: Ready): PoweredOff {.transition.} =\n  ## Safely power off the arm when ready.\n  echo \"  [ARM] Powering off safely...\"\n  result = PoweredOff(arm.RobotArm)\n\nproc powerOffEmergency(arm: EmergencyStop): PoweredOff {.transition.} =\n  ## Power off after emergency stop.\n  echo \"  [ARM] Emergency power off\"\n  result = PoweredOff(arm.RobotArm)\n\n# ============================================================================\n# Homing Operations\n# ============================================================================\n\nproc startHoming(arm: NeedsHoming): Homing {.transition.} =\n  ## Begin the homing sequence to find reference position.\n  echo \"  [ARM] Starting homing sequence...\"\n  echo \"  [ARM] Moving to limit switches at low speed...\"\n  result = Homing(arm.RobotArm)\n\nproc homingComplete(arm: Homing, homeX, homeY, homeZ: float): Ready {.transition.} =\n  ## Complete homing and set reference position.\n  var a = arm.RobotArm\n  a.x = homeX\n  a.y = homeY\n  a.z = homeZ\n  a.homeX = homeX\n  a.homeY = homeY\n  a.homeZ = homeZ\n  echo \"  [ARM] Homing complete. Position: (\", homeX, \", \", homeY, \", \", homeZ, \")\"\n  echo \"  [ARM] Ready for commands!\"\n  result = Ready(a)\n\nproc resetAfterEmergency(arm: EmergencyStop): NeedsHoming {.transition.} =\n  ## Reset emergency stop - position is now uncertain.\n  echo \"  [ARM] E-stop reset. Position uncertain - must re-home!\"\n  var a = arm.RobotArm\n  a.emergencyReason = \"\"\n  result = NeedsHoming(a)\n\n# ============================================================================\n# Movement Operations\n# ============================================================================\n\nproc moveTo(arm: Ready, x, y, z: float): Moving {.transition.} =\n  ## Start moving to target position.\n  echo \"  [ARM] Moving to (\", x, \", \", y, \", \", z, \")...\"\n  result = Moving(arm.RobotArm)\n\nproc moveComplete(arm: Moving, x, y, z: float): Ready {.transition.} =\n  ## Movement completed successfully.\n  var a = arm.RobotArm\n  a.x = x\n  a.y = y\n  a.z = z\n  echo \"  [ARM] Reached position (\", x, \", \", y, \", \", z, \")\"\n  result = Ready(a)\n\nproc emergencyStop(arm: Moving, reason: string): EmergencyStop {.transition.} =\n  ## Trigger emergency stop during movement!\n  var a = arm.RobotArm\n  a.emergencyReason = reason\n  echo \"  [ARM] !!! EMERGENCY STOP !!!\"\n  echo \"  [ARM] Reason: \", reason\n  echo \"  [ARM] Motors locked. Manual intervention required.\"\n  result = EmergencyStop(a)\n\n# ============================================================================\n# Status and Configuration (no state change)\n# ============================================================================\n\nfunc position(arm: Ready): tuple[x, y, z: float] =\n  ## Get current position (only valid when Ready).\n  (arm.RobotArm.x, arm.RobotArm.y, arm.RobotArm.z)\n\nproc setSpeed(arm: Ready, speed: float): Ready {.notATransition.} =\n  ## Configure movement speed.\n  var a = arm.RobotArm\n  a.speed = speed\n  echo \"  [ARM] Speed set to \", speed, \" mm/s\"\n  result = Ready(a)\n\nproc attachTool(arm: Ready, toolName: string): Ready {.notATransition.} =\n  ## Attach a tool to the arm.\n  var a = arm.RobotArm\n  a.toolAttached = true\n  echo \"  [ARM] Tool attached: \", toolName\n  result = Ready(a)\n\n# ============================================================================\n# Example Usage\n# ============================================================================\n\nwhen isMainModule:\n  echo \"=== Robot Arm Controller Demo ===\\n\"\n\n  echo \"1. Starting with powered-off arm...\"\n  var arm = PoweredOff(RobotArm())\n\n  echo \"\\n2. Powering on...\"\n  let initializing = arm.powerOn()\n\n  echo \"\\n3. Completing initialization...\"\n  let needsHoming = initializing.completeInit()\n\n  echo \"\\n4. Starting homing sequence...\"\n  let homing = needsHoming.startHoming()\n\n  echo \"\\n5. Homing complete...\"\n  let ready = homing.homingComplete(0.0, 0.0, 100.0)\n\n  echo \"\\n6. Configuring arm...\"\n  let configured = ready\n    .setSpeed(50.0)\n    .attachTool(\"gripper\")\n\n  echo \"\\n7. Moving to pick position...\"\n  let moving1 = configured.moveTo(100.0, 50.0, 20.0)\n  let atPick = moving1.moveComplete(100.0, 50.0, 20.0)\n\n  echo \"\\n8. Moving to place position...\"\n  let moving2 = atPick.moveTo(200.0, 50.0, 20.0)\n  let atPlace = moving2.moveComplete(200.0, 50.0, 20.0)\n\n  echo \"\\n9. Returning home and powering off...\"\n  let moving3 = atPlace.moveTo(0.0, 0.0, 100.0)\n  let atHome = moving3.moveComplete(0.0, 0.0, 100.0)\n  let off = atHome.powerOff()\n\n  echo \"\\n=== Demo complete! ===\\n\"\n\n  # =========================================================================\n  # COMPILE-TIME ERRORS - These dangerous bugs are prevented:\n  # =========================================================================\n\n  echo \"The following DANGEROUS bugs are caught at COMPILE TIME:\\n\"\n\n  # BUG 1: Moving without homing (position unknown!)\n  # let bad1 = needsHoming.moveTo(100.0, 0.0, 0.0)\n  echo \"  [PREVENTED] moveTo() without homing - could crash into limits!\"\n\n  # BUG 2: Power off while moving (motor damage!)\n  # let bad2 = moving1.powerOff()\n  echo \"  [PREVENTED] powerOff() while moving - motor damage risk!\"\n\n  # BUG 3: Continue after emergency stop\n  # let estop = moving2.emergencyStop(\"Obstacle detected\")\n  # let bad3 = estop.moveTo(0.0, 0.0, 0.0)\n  echo \"  [PREVENTED] moveTo() after E-stop - dangerous!\"\n\n  # BUG 4: Skip initialization\n  # let bad4 = initializing.startHoming()\n  echo \"  [PREVENTED] startHoming() before initialization complete\"\n\n  # BUG 5: Configure speed while moving\n  # let bad5 = moving1.setSpeed(100.0)\n  echo \"  [PREVENTED] setSpeed() while moving - could cause issues\"\n\n  echo \"\\nUncomment any of the 'bad' lines to see the compile error!\"\n</code></pre> <p>:material-file-code: View full source</p>"},{"location":"guide/examples/#order-fulfillment","title":"Order Fulfillment","text":"<p>Order fulfillment has a fixed sequence: place, pay, ship, deliver. Typestates ensure orders can't be shipped before payment or shipped twice.</p> <p>Bugs prevented: Ship before payment, double-ship, operations on unplaced cart.</p> <pre><code>## E-commerce Order Fulfillment with Typestates\n##\n## Order fulfillment bugs are expensive and embarrassing:\n## - Shipping before payment: lost merchandise\n## - Refunding unshipped orders: process confusion\n## - Double-shipping: inventory nightmare\n## - Cancelling already-shipped: customer confusion\n##\n## This example models the complete order lifecycle.\n\nimport ../src/typestates\nimport std/hashes\n\ntype\n  Order = object\n    id: string\n    customerId: string\n    items: seq[(string, int, int)]  # (sku, qty, price)\n    total: int\n    paymentId: string\n    trackingNumber: string\n    cancelReason: string\n\n  # Order states\n  Cart = distinct Order           ## Items being added, not yet placed\n  Placed = distinct Order         ## Order submitted, pending payment\n  Paid = distinct Order           ## Payment received\n  Picking = distinct Order        ## Warehouse picking items\n  Packed = distinct Order         ## Items packed, ready to ship\n  Shipped = distinct Order        ## Handed to carrier\n  Delivered = distinct Order      ## Customer received package\n  Cancelled = distinct Order      ## Order cancelled\n  Returned = distinct Order       ## Items returned by customer\n\ntypestate Order:\n  # Orders need to be inspected at various stages (for status, totals, etc.).\n  consumeOnTransition = false\n  states Cart, Placed, Paid, Picking, Packed, Shipped, Delivered, Cancelled, Returned\n  transitions:\n    Cart -&gt; Placed                     # Submit order\n    Placed -&gt; (Paid | Cancelled) as PaymentResult         # Pay or cancel\n    Paid -&gt; (Picking | Cancelled) as FulfillmentAction        # Start fulfillment or cancel (refund)\n    Picking -&gt; Packed                  # Finish picking\n    Packed -&gt; Shipped                  # Hand to carrier\n    Shipped -&gt; Delivered               # Delivery confirmed\n    Delivered -&gt; Returned              # Customer returns\n    * -&gt; Cancelled                     # Can always cancel (with appropriate handling)\n\n# ============================================================================\n# Cart Operations\n# ============================================================================\n\nproc newOrder(customerId: string): Cart =\n  ## Create a new shopping cart.\n  echo \"  [ORDER] New cart for customer: \", customerId\n  result = Cart(Order(customerId: customerId))\n\nproc addItem(order: Cart, sku: string, qty: int, price: int): Cart {.notATransition.} =\n  ## Add an item to the cart.\n  var o = order.Order\n  o.items.add((sku, qty, price))\n  o.total += qty * price\n  echo \"  [ORDER] Added \", qty, \"x \", sku, \" @ $\", price, \" = $\", qty * price\n  result = Cart(o)\n\nproc placeOrder(order: Cart): Placed {.transition.} =\n  ## Submit the order for processing.\n  var o = order.Order\n  o.id = \"ORD-\" &amp; $hash(o.customerId)  # Simplified ID generation\n  echo \"  [ORDER] Order placed: \", o.id, \" (total: $\", o.total, \")\"\n  result = Placed(o)\n\n# ============================================================================\n# Payment\n# ============================================================================\n\nproc pay(order: Placed, paymentId: string): Paid {.transition.} =\n  ## Record payment for the order.\n  var o = order.Order\n  o.paymentId = paymentId\n  echo \"  [ORDER] Payment received: \", paymentId\n  result = Paid(o)\n\nproc cancelUnpaid(order: Placed, reason: string): Cancelled {.transition.} =\n  ## Cancel an unpaid order (no refund needed).\n  var o = order.Order\n  o.cancelReason = reason\n  echo \"  [ORDER] Order cancelled (unpaid): \", reason\n  result = Cancelled(o)\n\nproc cancelWithRefund(order: Paid, reason: string): Cancelled {.transition.} =\n  ## Cancel a paid order and process refund.\n  var o = order.Order\n  o.cancelReason = reason\n  echo \"  [ORDER] Order cancelled with refund\"\n  echo \"  [ORDER] Refunding payment: \", o.paymentId\n  result = Cancelled(o)\n\n# ============================================================================\n# Fulfillment\n# ============================================================================\n\nproc startPicking(order: Paid): Picking {.transition.} =\n  ## Start warehouse picking process.\n  echo \"  [WAREHOUSE] Starting pick for order: \", order.Order.id\n  for (sku, qty, _) in order.Order.items:\n    echo \"  [WAREHOUSE]   Pick \", qty, \"x \", sku\n  result = Picking(order.Order)\n\nproc finishPacking(order: Picking): Packed {.transition.} =\n  ## Finish packing the order.\n  echo \"  [WAREHOUSE] Order packed and ready for shipping\"\n  result = Packed(order.Order)\n\nproc ship(order: Packed, trackingNumber: string): Shipped {.transition.} =\n  ## Hand order to carrier.\n  var o = order.Order\n  o.trackingNumber = trackingNumber\n  echo \"  [SHIPPING] Order shipped!\"\n  echo \"  [SHIPPING] Tracking: \", trackingNumber\n  result = Shipped(o)\n\nproc confirmDelivery(order: Shipped): Delivered {.transition.} =\n  ## Confirm customer received the order.\n  echo \"  [SHIPPING] Delivery confirmed for: \", order.Order.id\n  result = Delivered(order.Order)\n\n# ============================================================================\n# Returns\n# ============================================================================\n\nproc initiateReturn(order: Delivered, reason: string): Returned {.transition.} =\n  ## Customer initiates a return.\n  echo \"  [RETURNS] Return initiated for: \", order.Order.id\n  echo \"  [RETURNS] Reason: \", reason\n  echo \"  [RETURNS] Send to: 123 Returns Center, Warehouse City\"\n  result = Returned(order.Order)\n\n# ============================================================================\n# Status Queries\n# ============================================================================\n\nfunc orderId(order: OrderStates): string =\n  ## Get order ID.\n  order.Order.id\n\nfunc trackingNumber(order: Shipped): string =\n  ## Get tracking number.\n  order.Order.trackingNumber\n\nfunc total(order: OrderStates): int =\n  ## Get order total.\n  order.Order.total\n\n# ============================================================================\n# Example Usage\n# ============================================================================\n\nwhen isMainModule:\n  echo \"=== E-commerce Order Fulfillment Demo ===\\n\"\n\n  echo \"1. Customer adds items to cart...\"\n  let cart = newOrder(\"cust_12345\")\n    .addItem(\"SKU-LAPTOP\", 1, 99900)\n    .addItem(\"SKU-MOUSE\", 2, 2500)\n    .addItem(\"SKU-CABLE\", 3, 1000)\n\n  echo \"\\n2. Customer places order...\"\n  let placed = cart.placeOrder()\n\n  echo \"\\n3. Payment processing...\"\n  let paid = placed.pay(\"pay_ch_abc123\")\n\n  echo \"\\n4. Warehouse picks items...\"\n  let picking = paid.startPicking()\n\n  echo \"\\n5. Items packed...\"\n  let packed = picking.finishPacking()\n\n  echo \"\\n6. Shipped to customer...\"\n  let shipped = packed.ship(\"1Z999AA10123456784\")\n\n  echo \"\\n7. Customer receives package...\"\n  let delivered = shipped.confirmDelivery()\n\n  echo \"\\n=== Order complete! ===\\n\"\n\n  # =========================================================================\n  # COMPILE-TIME ERRORS - These business logic bugs are prevented:\n  # =========================================================================\n\n  echo \"The following bugs are caught at COMPILE TIME:\\n\"\n\n  # BUG 1: Ship before payment\n  # let bad1 = placed.ship(\"TRACKING\")\n  echo \"  [PREVENTED] ship() before payment - lost merchandise!\"\n\n  # BUG 2: Refund an order that wasn't paid\n  # let bad2 = placed.cancelWithRefund(\"changed mind\")\n  echo \"  [PREVENTED] cancelWithRefund() on unpaid order\"\n\n  # BUG 3: Ship already-shipped order (double ship)\n  # let bad3 = shipped.ship(\"ANOTHER-TRACKING\")\n  echo \"  [PREVENTED] ship() twice - inventory nightmare!\"\n\n  # BUG 4: Return before delivery\n  # let bad4 = shipped.initiateReturn(\"don't want it\")\n  echo \"  [PREVENTED] initiateReturn() before delivery\"\n\n  # BUG 5: Continue fulfillment after cancellation\n  # let cancelled = paid.cancelWithRefund(\"out of stock\")\n  # let bad5 = cancelled.startPicking()\n  echo \"  [PREVENTED] startPicking() after cancellation\"\n\n  # BUG 6: Pay for cart (not yet an order)\n  # let bad6 = cart.pay(\"payment\")\n  echo \"  [PREVENTED] pay() on Cart - order not submitted\"\n\n  echo \"\\nUncomment any of the 'bad' lines to see the compile error!\"\n</code></pre> <p>:material-file-code: View full source</p>"},{"location":"guide/examples/#document-workflow","title":"Document Workflow","text":"<p>Document publishing enforces a review process: draft, review, approve, publish. Typestates prevent publishing without approval or editing published content.</p> <p>Bugs prevented: Publishing without approval, editing published content, skipping review process.</p> <pre><code>## Document Workflow with Typestates\n##\n## Content publishing workflows have strict rules:\n## - Publishing drafts without review: quality issues\n## - Editing published content: audit/compliance problems\n## - Approving your own work: process violation\n## - Skipping required reviews: legal risk\n##\n## This example models a multi-stage document review workflow.\n\nimport ../src/typestates\nimport std/hashes\n\ntype\n  Document = object\n    id: string\n    title: string\n    content: string\n    author: string\n    reviewers: seq[string]\n    approver: string\n    version: int\n    publishedAt: int64\n\n  # Document states\n  Draft = distinct Document           ## Being written/edited\n  InReview = distinct Document        ## Submitted for review\n  ChangesRequested = distinct Document ## Reviewer requested changes\n  Approved = distinct Document        ## Passed review, ready to publish\n  Published = distinct Document       ## Live/public\n  Archived = distinct Document        ## Removed from public, preserved\n\ntypestate Document:\n  # Documents need to be inspected at various stages without consuming them.\n  consumeOnTransition = false\n  states Draft, InReview, ChangesRequested, Approved, Published, Archived\n  transitions:\n    Draft -&gt; InReview                    # Submit for review\n    InReview -&gt; (Approved | ChangesRequested) as ReviewResult  # Review decision\n    ChangesRequested -&gt; InReview         # Resubmit after changes\n    Approved -&gt; Published                # Go live\n    Published -&gt; (Archived | Draft) as PublishAction        # Archive or create new version\n    Archived -&gt; Draft                    # Restore for new version\n\n# ============================================================================\n# Creating and Editing\n# ============================================================================\n\nproc newDocument(title: string, author: string): Draft =\n  ## Create a new document draft.\n  echo \"  [DOC] Created: '\", title, \"' by \", author\n  result = Draft(Document(\n    id: \"doc_\" &amp; $hash(title),\n    title: title,\n    author: author,\n    version: 1\n  ))\n\nproc edit(doc: Draft, content: string): Draft {.notATransition.} =\n  ## Edit the document content.\n  var d = doc.Document\n  d.content = content\n  echo \"  [DOC] Updated content (\", content.len, \" chars)\"\n  result = Draft(d)\n\nproc setTitle(doc: Draft, title: string): Draft {.notATransition.} =\n  ## Update the document title.\n  var d = doc.Document\n  d.title = title\n  echo \"  [DOC] Title changed to: '\", title, \"'\"\n  result = Draft(d)\n\n# ============================================================================\n# Review Process\n# ============================================================================\n\nproc submitForReview(doc: Draft, reviewers: seq[string]): InReview {.transition.} =\n  ## Submit document for review.\n  var d = doc.Document\n  d.reviewers = reviewers\n  echo \"  [DOC] Submitted for review\"\n  echo \"  [DOC] Reviewers: \", reviewers\n  result = InReview(d)\n\nproc approve(doc: InReview, approver: string): Approved {.transition.} =\n  ## Approve the document.\n  var d = doc.Document\n  d.approver = approver\n  echo \"  [DOC] Approved by: \", approver\n  result = Approved(d)\n\nproc requestChanges(doc: InReview, feedback: string): ChangesRequested {.transition.} =\n  ## Request changes to the document.\n  echo \"  [DOC] Changes requested: \", feedback\n  result = ChangesRequested(doc.Document)\n\nproc updateContent(doc: ChangesRequested, newContent: string): ChangesRequested {.notATransition.} =\n  ## Update content while in ChangesRequested state.\n  var d = doc.Document\n  d.content = newContent\n  echo \"  [DOC] Content updated (\", newContent.len, \" chars)\"\n  result = ChangesRequested(d)\n\nproc resubmit(doc: ChangesRequested): InReview {.transition.} =\n  ## Resubmit after making changes.\n  echo \"  [DOC] Resubmitted for review\"\n  result = InReview(doc.Document)\n\n# ============================================================================\n# Publishing\n# ============================================================================\n\nproc publish(doc: Approved): Published {.transition.} =\n  ## Publish the approved document.\n  var d = doc.Document\n  d.publishedAt = 1234567890  # In real code: current timestamp\n  echo \"  [DOC] Published! '\", d.title, \"'\"\n  result = Published(d)\n\nproc archive(doc: Published, reason: string): Archived {.transition.} =\n  ## Archive a published document.\n  echo \"  [DOC] Archived: \", reason\n  result = Archived(doc.Document)\n\nproc createNewVersion(doc: Published): Draft {.transition.} =\n  ## Create a new draft version from published.\n  var d = doc.Document\n  d.version += 1\n  d.approver = \"\"\n  d.publishedAt = 0\n  echo \"  [DOC] New version \", d.version, \" created from published\"\n  result = Draft(d)\n\nproc restore(doc: Archived): Draft {.transition.} =\n  ## Restore archived document as new draft.\n  var d = doc.Document\n  d.version += 1\n  echo \"  [DOC] Restored as version \", d.version\n  result = Draft(d)\n\n# ============================================================================\n# Status Queries\n# ============================================================================\n\nfunc title(doc: DocumentStates): string =\n  doc.Document.title\n\nfunc author(doc: DocumentStates): string =\n  doc.Document.author\n\nfunc version(doc: DocumentStates): int =\n  doc.Document.version\n\nfunc isPublished(doc: Published): bool = true\n\n# ============================================================================\n# Example Usage\n# ============================================================================\n\nwhen isMainModule:\n  echo \"=== Document Workflow Demo ===\\n\"\n\n  echo \"1. Creating new document...\"\n  let draft = newDocument(\"Q4 Strategy Document\", \"alice@company.com\")\n    .edit(\"# Q4 Strategy\\n\\nOur goals for Q4 are...\")\n    .setTitle(\"Q4 2024 Strategy Document\")\n\n  echo \"\\n2. Submitting for review...\"\n  let review = draft.submitForReview(@[\"bob@company.com\", \"carol@company.com\"])\n\n  echo \"\\n3. Reviewer requests changes...\"\n  let needsChanges = review.requestChanges(\"Please add budget section\")\n\n  echo \"\\n4. Author makes changes and resubmits...\"\n  let resubmitted = needsChanges.resubmit()\n\n  echo \"\\n5. Document approved...\"\n  let approved = resubmitted.approve(\"carol@company.com\")\n\n  echo \"\\n6. Publishing document...\"\n  let published = approved.publish()\n\n  echo \"\\n7. Later, creating new version for updates...\"\n  let v2Draft = published.createNewVersion()\n  let v2 = v2Draft.edit(\"# Q4 2024 Strategy\\n\\nUpdated with Q3 results...\")\n\n  echo \"\\n=== Workflow complete! ===\\n\"\n\n  # =========================================================================\n  # COMPILE-TIME ERRORS - These process violations are prevented:\n  # =========================================================================\n\n  echo \"The following process violations are caught at COMPILE TIME:\\n\"\n\n  # BUG 1: Publishing without approval\n  # let bad1 = draft.publish()\n  echo \"  [PREVENTED] publish() Draft - must be approved first!\"\n\n  # BUG 2: Publishing during review\n  # let bad2 = review.publish()\n  echo \"  [PREVENTED] publish() InReview - review not complete!\"\n\n  # BUG 3: Editing published content\n  # let bad3 = published.edit(\"hacked content\")\n  echo \"  [PREVENTED] edit() Published - audit violation!\"\n\n  # BUG 4: Approving draft (skipping review)\n  # let bad4 = draft.approve(\"alice\")\n  echo \"  [PREVENTED] approve() Draft - must go through review!\"\n\n  # BUG 5: Double-publishing\n  # let bad5 = published.publish()\n  echo \"  [PREVENTED] publish() Published - already live!\"\n\n  # BUG 6: Requesting changes on approved doc\n  # let bad6 = approved.requestChanges(\"wait, one more thing\")\n  echo \"  [PREVENTED] requestChanges() Approved - too late!\"\n\n  echo \"\\nUncomment any of the 'bad' lines to see the compile error!\"\n</code></pre> <p>:material-file-code: View full source</p>"},{"location":"guide/examples/#single-use-token-ownership","title":"Single-Use Token (Ownership)","text":"<p>Some resources should only be used once: password reset tokens, one-time payment links, event tickets. This example uses <code>consumeOnTransition = true</code> (the default) to enforce that tokens cannot be copied or reused.</p> <p>Bugs prevented: Double consumption, copying to bypass single-use, using after consumption.</p> <pre><code>## Single-Use Token with Ownership Enforcement\n##\n## Some resources should only be used once:\n## - Password reset tokens\n## - One-time payment links\n## - Single-use API keys\n## - Event tickets\n##\n## This example uses consumeOnTransition = true (the default) to enforce\n## that tokens cannot be copied or reused after consumption.\n##\n## Run: nim c -r examples/single_use_token.nim\n\nimport ../src/typestates\n\ntype\n  Token = object\n    id: string\n    value: string\n    createdAt: string\n\n  # Token states\n  Valid = distinct Token      ## Token is valid, can be used\n  Used = distinct Token       ## Token has been consumed\n  Expired = distinct Token    ## Token has expired\n  Revoked = distinct Token    ## Token was manually revoked\n\ntypestate Token:\n  # DEFAULT: consumeOnTransition = true\n  # This enforces ownership - tokens cannot be copied after creation.\n  # Each token can only follow ONE path through the state machine.\n  states Valid, Used, Expired, Revoked\n  initial: Valid\n  terminal: Used\n  transitions:\n    Valid -&gt; Used       # Consume the token\n    Valid -&gt; Expired    # Token expires\n    Valid -&gt; Revoked    # Token is revoked\n\n# ============================================================================\n# Token Operations\n# ============================================================================\n\nproc createToken(id: string, value: string): Valid =\n  ## Create a new single-use token.\n  echo \"  [TOKEN] Created: \", id\n  Valid(Token(id: id, value: value, createdAt: \"now\"))\n\nproc consume(token: sink Valid): Used {.transition.} =\n  ## Use the token (one-time only).\n  ## sink + consumeOnTransition = true prevents copying, enforcing single-use.\n  let t = Token(token)\n  echo \"  [TOKEN] Consumed: \", t.id\n  Used(t)\n\nproc expire(token: Valid): Expired {.transition.} =\n  ## Mark token as expired.\n  echo \"  [TOKEN] Expired: \", Token(token).id\n  Expired(Token(token))\n\nproc revoke(token: Valid): Revoked {.transition.} =\n  ## Revoke the token.\n  echo \"  [TOKEN] Revoked: \", Token(token).id\n  Revoked(Token(token))\n\nproc getValue(token: Valid): string {.notATransition.} =\n  ## Read the token value (only when valid).\n  Token(token).value\n\n# ============================================================================\n# Example: Password Reset Token\n# ============================================================================\n\nwhen isMainModule:\n  echo \"=== Single-Use Token Demo ===\\n\"\n\n  echo \"1. Creating and immediately consuming a password reset token...\"\n  # With consumeOnTransition = true, tokens flow directly through transitions\n  let usedToken = createToken(\"reset-abc123\", \"secret-reset-value\").consume()\n\n  echo \"\\n=== Token consumed! ===\\n\"\n\n  # =========================================================================\n  # COMPILE-TIME ERRORS - Ownership enforcement prevents these bugs:\n  # =========================================================================\n\n  echo \"The following bugs are caught at COMPILE TIME:\\n\"\n\n  # BUG 1: Storing a token and then trying to use it twice\n  # let token = createToken(\"test\", \"value\")\n  # let used1 = token.consume()\n  # let used2 = token.consume()  # ERROR: token was already moved\n  echo \"  [PREVENTED] Double consumption of token\"\n\n  # BUG 2: Copying token to bypass single-use\n  # let token = createToken(\"test\", \"value\")\n  # let backup = token  # ERROR: =copy is not available for Valid\n  echo \"  [PREVENTED] Copying token to bypass single-use\"\n\n  # BUG 3: Reading token value then consuming (uses token twice)\n  # let token = createToken(\"test\", \"value\")\n  # echo token.getValue()\n  # discard token.consume()  # ERROR: token was not last read in getValue()\n  echo \"  [PREVENTED] Reading token value prevents later consumption\"\n\n  # BUG 4: Using terminal state\n  # let reused = usedToken.consume()  # ERROR: Used is a terminal state\n  echo \"  [PREVENTED] Transitioning from terminal state\"\n\n  echo \"\\nUncomment any of the 'bad' lines above to see the compile error!\"\n  echo \"\\n=== Ownership enforcement ensures tokens are truly single-use ===\"\n</code></pre> <p>:material-file-code: View full source</p>"},{"location":"guide/examples/#shared-session-ref-types","title":"Shared Session (ref types)","text":"<p>When multiple parts of code need access to the same stateful object, use <code>ref</code> types. Common for session objects, connection pools, and shared resources in async code.</p> <p>Bugs prevented: Operations on wrong session state, accessing expired sessions.</p> <pre><code>## Shared Session with ref Types\n##\n## When multiple parts of your code need access to the same stateful object,\n## use `ref` types. This is common for:\n## - Session objects shared across handlers\n## - Connection pools\n## - Shared resources in async code\n##\n## This example shows how typestates work with heap-allocated ref types.\n##\n## Run: nim c -r examples/shared_session.nim\n\nimport ../src/typestates\n\ntype\n  Session = object\n    id: string\n    userId: int\n    data: string\n\n  # Session states\n  Unauthenticated = distinct Session\n  Authenticated = distinct Session\n  Expired = distinct Session\n\ntypestate Session:\n  # Shared sessions need to be read from multiple places\n  consumeOnTransition = false\n  states Unauthenticated, Authenticated, Expired\n  transitions:\n    Unauthenticated -&gt; Authenticated\n    Authenticated -&gt; Expired\n\n# ============================================================================\n# Session Operations (ref types)\n# ============================================================================\n\nproc newSession(id: string): ref Unauthenticated =\n  ## Create a new heap-allocated session.\n  result = new(Unauthenticated)\n  result[] = Unauthenticated(Session(id: id))\n  echo \"  [SESSION] Created: \", id\n\nproc authenticate(session: ref Unauthenticated, userId: int): ref Authenticated {.transition.} =\n  ## Authenticate the session - works with ref types.\n  var s = Session(session[])\n  s.userId = userId\n  result = new(Authenticated)\n  result[] = Authenticated(s)\n  echo \"  [SESSION] Authenticated user \", userId\n\nproc expire(session: ref Authenticated): ref Expired {.transition.} =\n  ## Expire the session.\n  result = new(Expired)\n  result[] = Expired(Session(session[]))\n  echo \"  [SESSION] Expired\"\n\nproc setData(session: ref Authenticated, data: string) =\n  ## Modify session data (only when authenticated).\n  var s = Session(session[])\n  s.data = data\n  session[] = Authenticated(s)\n  echo \"  [SESSION] Data set: \", data\n\nproc getData(session: ref Authenticated): string =\n  ## Read session data.\n  Session(session[]).data\n\nproc getUserId(session: ref Authenticated): int =\n  ## Get the authenticated user ID.\n  Session(session[]).userId\n\n# ============================================================================\n# Example: Multiple references to same session\n# ============================================================================\n\nwhen isMainModule:\n  echo \"=== Shared Session Demo (ref types) ===\\n\"\n\n  echo \"1. Creating session...\"\n  let session = newSession(\"sess-abc123\")\n\n  echo \"\\n2. Authenticating...\"\n  let authSession = session.authenticate(42)\n\n  echo \"\\n3. Multiple parts of code can access the same session...\"\n  # Simulate different parts of the application using the session\n  authSession.setData(\"user preferences\")\n  echo \"   Handler A reads: \", authSession.getData()\n  echo \"   Handler B reads user: \", authSession.getUserId()\n\n  echo \"\\n4. Expiring session...\"\n  let expiredSession = authSession.expire()\n\n  echo \"\\n=== Session lifecycle complete! ===\\n\"\n\n  # =========================================================================\n  # COMPILE-TIME ERRORS\n  # =========================================================================\n\n  echo \"The following bugs are caught at COMPILE TIME:\\n\"\n\n  # BUG 1: Setting data on unauthenticated session\n  # session.setData(\"hack\")  # ERROR: no matching proc for ref Unauthenticated\n  echo \"  [PREVENTED] setData() on unauthenticated session\"\n\n  # BUG 2: Getting user ID from expired session\n  # echo expiredSession.getUserId()  # ERROR: no matching proc for ref Expired\n  echo \"  [PREVENTED] getUserId() on expired session\"\n\n  # BUG 3: Authenticating already-authenticated session\n  # discard authSession.authenticate(99)  # ERROR: no matching proc\n  echo \"  [PREVENTED] authenticate() on already-authenticated session\"\n\n  echo \"\\nRef types work seamlessly with typestates!\"\n</code></pre> <p>:material-file-code: View full source</p>"},{"location":"guide/examples/#hardware-register-ptr-types","title":"Hardware Register (ptr types)","text":"<p>When interfacing with hardware or memory-mapped I/O, typestates can enforce correct access patterns with raw pointers.</p> <p>Bugs prevented: Reading uninitialized registers, modifying locked registers.</p> <pre><code>## Hardware Register Access with ptr Types\n##\n## When interfacing with hardware or memory-mapped I/O, you often work with\n## raw pointers. Typestates can enforce correct access patterns:\n## - Registers must be initialized before use\n## - Some registers are read-only after configuration\n## - Certain sequences must be followed\n##\n## This example shows how typestates work with ptr types for low-level code.\n##\n## Run: nim c -r examples/hardware_register.nim\n\nimport std/strutils\nimport ../src/typestates\n\ntype\n  Register = object\n    address: uint32\n    value: uint32\n\n  # Register states\n  Uninitialized = distinct Register\n  Configured = distinct Register\n  Locked = distinct Register\n\ntypestate Register:\n  # Hardware registers are accessed via pointers\n  consumeOnTransition = false\n  states Uninitialized, Configured, Locked\n  transitions:\n    Uninitialized -&gt; Configured\n    Configured -&gt; Configured   # Can reconfigure\n    Configured -&gt; Locked       # Lock to prevent further changes\n\n# ============================================================================\n# Register Operations (ptr types)\n# ============================================================================\n\nproc initRegister(reg: ptr Uninitialized, value: uint32): ptr Configured {.transition.} =\n  ## Initialize a hardware register with a value.\n  echo \"  [REG 0x\", reg[].Register.address.toHex, \"] Init: 0x\", value.toHex\n  var r = Register(reg[])\n  r.value = value\n  reg[] = Uninitialized(r)\n  cast[ptr Configured](../../examples/reg)\n\nproc configure(reg: ptr Configured, value: uint32): ptr Configured {.transition.} =\n  ## Reconfigure a register (only when not locked).\n  echo \"  [REG 0x\", reg[].Register.address.toHex, \"] Configure: 0x\", value.toHex\n  var r = Register(reg[])\n  r.value = value\n  reg[] = Configured(r)\n  reg\n\nproc lock(reg: ptr Configured): ptr Locked {.transition.} =\n  ## Lock the register to prevent further modifications.\n  echo \"  [REG 0x\", reg[].Register.address.toHex, \"] LOCKED\"\n  cast[ptr Locked](../../examples/reg)\n\nproc read(reg: ptr Configured): uint32 =\n  ## Read value from configured register.\n  Register(reg[]).value\n\nproc read(reg: ptr Locked): uint32 =\n  ## Read value from locked register.\n  Register(reg[]).value\n\n# ============================================================================\n# Example: GPIO Configuration\n# ============================================================================\n\nwhen isMainModule:\n  echo \"=== Hardware Register Demo (ptr types) ===\\n\"\n\n  # Simulate memory-mapped registers\n  var gpioModeReg = Uninitialized(Register(address: 0x4002_0000'u32, value: 0))\n  var gpioSpeedReg = Uninitialized(Register(address: 0x4002_0008'u32, value: 0))\n\n  echo \"1. Initializing GPIO registers...\"\n  let modePtr = addr(gpioModeReg).initRegister(0x0000_0001)  # Output mode\n  let speedPtr = addr(gpioSpeedReg).initRegister(0x0000_0003)  # High speed\n\n  echo \"\\n2. Reading configured values...\"\n  echo \"   Mode register: 0x\", modePtr.read().toHex\n  echo \"   Speed register: 0x\", speedPtr.read().toHex\n\n  echo \"\\n3. Reconfiguring mode register...\"\n  let modePtr2 = modePtr.configure(0x0000_0002)  # Alternate function mode\n  echo \"   New mode: 0x\", modePtr2.read().toHex\n\n  echo \"\\n4. Locking speed register...\"\n  let lockedSpeed = speedPtr.lock()\n  echo \"   Locked value: 0x\", lockedSpeed.read().toHex\n\n  echo \"\\n=== Register configuration complete! ===\\n\"\n\n  # =========================================================================\n  # COMPILE-TIME ERRORS\n  # =========================================================================\n\n  echo \"The following bugs are caught at COMPILE TIME:\\n\"\n\n  # BUG 1: Reading uninitialized register\n  # var uninit = Uninitialized(Register(address: 0xDEAD, value: 0))\n  # echo addr(uninit).read()  # ERROR: no matching proc for ptr Uninitialized\n  echo \"  [PREVENTED] read() on uninitialized register\"\n\n  # BUG 2: Configuring locked register\n  # discard lockedSpeed.configure(0xFF)  # ERROR: no matching proc for ptr Locked\n  echo \"  [PREVENTED] configure() on locked register\"\n\n  # BUG 3: Locking uninitialized register\n  # var uninit2 = Uninitialized(Register(address: 0xBEEF, value: 0))\n  # discard addr(uninit2).lock()  # ERROR: no matching proc for ptr Uninitialized\n  echo \"  [PREVENTED] lock() on uninitialized register\"\n\n  echo \"\\nPtr types enable type-safe hardware access!\"\n</code></pre> <p>:material-file-code: View full source</p>"},{"location":"guide/examples/#generic-patterns","title":"Generic Patterns","text":"<p>Reusable typestate patterns using generics. See Generic Typestates for more details.</p>"},{"location":"guide/examples/#resourcet-pattern","title":"Resource[T] Pattern","text":"<p>A reusable pattern for any resource requiring acquire/release semantics.</p> <pre><code>## Generic Resource[T] Pattern\n##\n## A reusable typestate pattern for any resource that must be acquired\n## before use and released after. Works with file handles, locks,\n## connections, memory allocations, or any RAII-style resource.\n##\n## Run: nim c -r examples/generic_resource.nim\n\nimport ../src/typestates\n\n# =============================================================================\n# Generic Resource Pattern\n# =============================================================================\n\ntype\n  Resource*[T] = object\n    ## Base type holding any resource.\n    handle*: T\n    name*: string  # For diagnostics\n\n  Released*[T] = distinct Resource[T]\n    ## Resource is not held - cannot be used.\n\n  Acquired*[T] = distinct Resource[T]\n    ## Resource is held - can be used, must be released.\n\ntypestate Resource[T]:\n  # Resources can be acquired, released, and re-acquired (RAII pattern).\n  consumeOnTransition = false\n  states Released[T], Acquired[T]\n  transitions:\n    Released[T] -&gt; Acquired[T]\n    Acquired[T] -&gt; Released[T]\n\nproc acquire*[T](../../examples/r: Released[T], handle: T): Acquired[T] {.transition.} =\n  ## Acquire the resource with the given handle.\n  var res = Resource[T](../../examples/r)\n  res.handle = handle\n  echo \"[\", res.name, \"] Acquired\"\n  result = Acquired[T](../../examples/res)\n\nproc release*[T](../../examples/r: Acquired[T]): Released[T] {.transition.} =\n  ## Release the resource back.\n  echo \"[\", Resource[T](../../examples/r).name, \"] Released\"\n  result = Released[T](../../examples/Resource[T](r))\n\nproc use*[T](../../examples/r: Acquired[T]): T {.notATransition.} =\n  ## Access the underlying handle (only when acquired).\n  Resource[T](../../examples/r).handle\n\nproc withResource*[T, R](r: Released[T], handle: T,\n                          body: proc(h: T): R): (R, Released[T]) =\n  ## RAII-style helper: acquire, use, release automatically.\n  let acquired = r.acquire(handle)\n  let res = body(acquired.use())\n  let released = acquired.release()\n  result = (res, released)\n\n# =============================================================================\n# Example 1: File Handle\n# =============================================================================\n\ntype FileHandle = object\n  fd: int\n  path: string\n\nproc openFile(path: string): FileHandle =\n  echo \"  Opening: \", path\n  FileHandle(fd: 42, path: path)\n\nproc closeFile(fh: FileHandle) =\n  echo \"  Closing: \", fh.path\n\nproc readFile(fh: FileHandle): string =\n  echo \"  Reading from fd=\", fh.fd\n  \"file contents\"\n\nblock fileExample:\n  echo \"\\n=== File Handle Example ===\"\n\n  # Create a released resource\n  var file = Released[FileHandle](../../examples/Resource[FileHandle](name: \"config.txt\"))\n\n  # Acquire it\n  let handle = openFile(\"/etc/config.txt\")\n  let acquired = file.acquire(handle)\n\n  # Use it\n  let contents = acquired.use().readFile()\n  echo \"  Got: \", contents\n\n  # Release it\n  let released = acquired.release()\n  closeFile(handle)\n\n  # COMPILE ERROR if uncommented:\n  # discard released.use()  # Can't use released resource!\n\n# =============================================================================\n# Example 2: Database Connection\n# =============================================================================\n\ntype DbConn = object\n  connString: string\n  connected: bool\n\nproc connect(connString: string): DbConn =\n  echo \"  Connecting to: \", connString\n  DbConn(connString: connString, connected: true)\n\nproc disconnect(conn: DbConn) =\n  echo \"  Disconnecting\"\n\nproc query(conn: DbConn, sql: string): seq[string] =\n  echo \"  Query: \", sql\n  @[\"row1\", \"row2\", \"row3\"]\n\nblock dbExample:\n  echo \"\\n=== Database Connection Example ===\"\n\n  var db = Released[DbConn](../../examples/Resource[DbConn](name: \"postgres\"))\n\n  # Manual acquire/release\n  let conn = connect(\"postgresql://localhost/mydb\")\n  let acquired = db.acquire(conn)\n\n  let rows = acquired.use().query(\"SELECT * FROM users\")\n  echo \"  Results: \", rows\n\n  let released = acquired.release()\n  disconnect(conn)\n\n# =============================================================================\n# Example 3: Lock/Mutex simulation\n# =============================================================================\n\ntype SimpleLock = object\n  id: int\n\nproc lock(id: int): SimpleLock =\n  echo \"  Locking mutex #\", id\n  SimpleLock(id: id)\n\nproc unlock(l: SimpleLock) =\n  echo \"  Unlocking mutex #\", l.id\n\nblock lockExample:\n  echo \"\\n=== Lock Example ===\"\n\n  var mutex = Released[SimpleLock](../../examples/Resource[SimpleLock](name: \"mutex\"))\n\n  # Using withResource for RAII-style usage\n  let (result, mutexReleased) = mutex.withResource(lock(1)) do (l: SimpleLock) -&gt; int:\n    echo \"  Critical section with lock #\", l.id\n    42  # Return value from critical section\n\n  echo \"  Result from critical section: \", result\n  unlock(SimpleLock(id: 1))\n\n# =============================================================================\n# Example 4: Memory Pool Allocation\n# =============================================================================\n\ntype PooledBuffer = object\n  size: int\n  data: ptr UncheckedArray[byte]\n\nproc allocFromPool(size: int): PooledBuffer =\n  echo \"  Allocating \", size, \" bytes from pool\"\n  # In real code, this would allocate from a pool\n  PooledBuffer(size: size, data: nil)\n\nproc returnToPool(buf: PooledBuffer) =\n  echo \"  Returning \", buf.size, \" bytes to pool\"\n\nblock memoryExample:\n  echo \"\\n=== Memory Pool Example ===\"\n\n  var buffer = Released[PooledBuffer](../../examples/Resource[PooledBuffer](name: \"buffer\"))\n\n  let mem = allocFromPool(4096)\n  let acquired = buffer.acquire(mem)\n\n  echo \"  Using buffer of size: \", acquired.use().size\n\n  let released = acquired.release()\n  returnToPool(mem)\n\n# =============================================================================\n# Summary\n# =============================================================================\n\necho \"\\n=== Summary ===\"\necho \"The Resource[T] pattern ensures:\"\necho \"  - Resources must be acquired before use\"\necho \"  - Resources must be released after use\"\necho \"  - Compile-time prevention of use-after-release\"\necho \"  - Works with ANY resource type via generics\"\n\necho \"\\nAll examples passed!\"\n</code></pre> <p>:material-file-code: View full source</p>"},{"location":"guide/examples/#pipelinet-pattern","title":"Pipeline[T] Pattern","text":"<p>A reusable pattern for entities that progress through a fixed sequence of stages.</p> <pre><code>## Generic Pipeline[T] Pattern\n##\n## A reusable typestate pattern for entities that progress through\n## a fixed sequence of stages. Works for orders, documents, builds,\n## deployments, or any linear workflow.\n##\n## Run: nim c -r examples/generic_pipeline.nim\n\nimport ../src/typestates\n\n# =============================================================================\n# Generic Pipeline Pattern (4-stage)\n# =============================================================================\n\ntype\n  Pipeline*[T] = object\n    ## Base type holding the entity progressing through stages.\n    entity*: T\n    startedAt*: string\n\n  Stage1*[T] = distinct Pipeline[T]\n    ## Initial stage - entity just entered the pipeline.\n\n  Stage2*[T] = distinct Pipeline[T]\n    ## Second stage - first transition complete.\n\n  Stage3*[T] = distinct Pipeline[T]\n    ## Third stage - nearing completion.\n\n  Stage4*[T] = distinct Pipeline[T]\n    ## Final stage - pipeline complete.\n\ntypestate Pipeline[T]:\n  # Pipeline entities flow through stages and may be inspected at each stage.\n  consumeOnTransition = false\n  states Stage1[T], Stage2[T], Stage3[T], Stage4[T]\n  transitions:\n    Stage1[T] -&gt; Stage2[T]\n    Stage2[T] -&gt; Stage3[T]\n    Stage3[T] -&gt; Stage4[T]\n\nproc start*[T](entity: T, timestamp: string): Stage1[T] =\n  ## Enter the pipeline at stage 1.\n  Stage1[T](../../examples/Pipeline[T](entity: entity, startedAt: timestamp))\n\nproc advance12*[T](../../examples/p: Stage1[T]): Stage2[T] {.transition.} =\n  ## Advance from stage 1 to stage 2.\n  Stage2[T](../../examples/Pipeline[T](p))\n\nproc advance23*[T](../../examples/p: Stage2[T]): Stage3[T] {.transition.} =\n  ## Advance from stage 2 to stage 3.\n  Stage3[T](../../examples/Pipeline[T](p))\n\nproc advance34*[T](../../examples/p: Stage3[T]): Stage4[T] {.transition.} =\n  ## Advance from stage 3 to stage 4 (complete).\n  Stage4[T](../../examples/Pipeline[T](p))\n\nproc entity*[T](../../examples/p: Stage1[T]): T {.notATransition.} = Pipeline[T](../../examples/p).entity\nproc entity*[T](../../examples/p: Stage2[T]): T {.notATransition.} = Pipeline[T](../../examples/p).entity\nproc entity*[T](../../examples/p: Stage3[T]): T {.notATransition.} = Pipeline[T](../../examples/p).entity\nproc entity*[T](../../examples/p: Stage4[T]): T {.notATransition.} = Pipeline[T](../../examples/p).entity\n\n# =============================================================================\n# Example 1: Order Fulfillment\n# =============================================================================\n\ntype\n  Order = object\n    id: string\n    items: seq[string]\n    total: int\n\n  # Semantic aliases for order stages\n  OrderCart = Stage1[Order]\n  OrderPaid = Stage2[Order]\n  OrderShipped = Stage3[Order]\n  OrderDelivered = Stage4[Order]\n\nproc addItem(cart: OrderCart, item: string, price: int): OrderCart {.notATransition.} =\n  var order = cart.entity()\n  order.items.add(item)\n  order.total += price\n  Stage1[Order](../../examples/Pipeline[Order](entity: order, startedAt: Pipeline[Order](cart).startedAt))\n\nproc pay(cart: OrderCart): OrderPaid =\n  echo \"  Payment received: $\", cart.entity().total\n  cart.advance12()\n\nproc ship(order: OrderPaid, tracking: string): OrderShipped =\n  echo \"  Shipped with tracking: \", tracking\n  order.advance23()\n\nproc deliver(order: OrderShipped): OrderDelivered =\n  echo \"  Delivered!\"\n  order.advance34()\n\nblock orderExample:\n  echo \"\\n=== Order Fulfillment Example ===\"\n\n  let cart = start(Order(id: \"ORD-001\"), \"2024-01-15\")\n    .addItem(\"Laptop\", 999)\n    .addItem(\"Mouse\", 29)\n    .addItem(\"Keyboard\", 79)\n\n  echo \"  Cart total: $\", cart.entity().total\n\n  let paid = cart.pay()\n  let shipped = paid.ship(\"1Z999AA10123456784\")\n  let delivered = shipped.deliver()\n\n  echo \"  Order \", delivered.entity().id, \" complete!\"\n\n  # COMPILE ERRORS if uncommented:\n  # discard cart.ship(\"TRACK\")      # Can't ship unpaid cart\n  # discard shipped.pay()           # Can't pay already-shipped order\n  # discard delivered.advance34()   # Can't advance past final stage\n\n# =============================================================================\n# Example 2: CI/CD Build Pipeline\n# =============================================================================\n\ntype\n  Build = object\n    repo: string\n    commit: string\n    artifacts: seq[string]\n\n  # Semantic aliases for build stages\n  BuildQueued = Stage1[Build]\n  BuildCompiling = Stage2[Build]\n  BuildTesting = Stage3[Build]\n  BuildDeployed = Stage4[Build]\n\nproc startBuild(repo, commit: string): BuildQueued =\n  echo \"  Build queued for \", repo, \"@\", commit[0..6]\n  start(Build(repo: repo, commit: commit), \"now\")\n\nproc compile(build: BuildQueued): BuildCompiling =\n  echo \"  Compiling...\"\n  var b = build.entity()\n  b.artifacts.add(\"app.bin\")\n  let pipeline = Pipeline[Build](entity: b, startedAt: Pipeline[Build](build).startedAt)\n  Stage2[Build](../../examples/pipeline)\n\nproc test(build: BuildCompiling): BuildTesting =\n  echo \"  Running tests...\"\n  build.advance23()\n\nproc deploy(build: BuildTesting): BuildDeployed =\n  echo \"  Deploying artifacts: \", build.entity().artifacts\n  build.advance34()\n\nblock buildExample:\n  echo \"\\n=== CI/CD Build Pipeline Example ===\"\n\n  let deployed = startBuild(\"github.com/user/project\", \"abc123def456\")\n    .compile()\n    .test()\n    .deploy()\n\n  echo \"  Build complete for \", deployed.entity().repo\n\n  # COMPILE ERRORS:\n  # discard startBuild(\"repo\", \"commit\").deploy()  # Can't skip stages!\n\n# =============================================================================\n# Example 3: Document Review\n# =============================================================================\n\ntype\n  Document = object\n    title: string\n    content: string\n    reviewer: string\n    approver: string\n\n  # Semantic aliases\n  DocDraft = Stage1[Document]\n  DocInReview = Stage2[Document]\n  DocApproved = Stage3[Document]\n  DocPublished = Stage4[Document]\n\nproc createDraft(title: string): DocDraft =\n  start(Document(title: title), \"draft-created\")\n\nproc edit(doc: DocDraft, content: string): DocDraft {.notATransition.} =\n  var d = doc.entity()\n  d.content = content\n  Stage1[Document](../../examples/Pipeline[Document](entity: d, startedAt: Pipeline[Document](doc).startedAt))\n\nproc submitForReview(doc: DocDraft, reviewer: string): DocInReview =\n  var d = doc.entity()\n  d.reviewer = reviewer\n  echo \"  Submitted to \", reviewer, \" for review\"\n  let pipeline = Pipeline[Document](entity: d, startedAt: Pipeline[Document](doc).startedAt)\n  Stage2[Document](../../examples/pipeline)\n\nproc approve(doc: DocInReview, approver: string): DocApproved =\n  var d = doc.entity()\n  d.approver = approver\n  echo \"  Approved by \", approver\n  let pipeline = Pipeline[Document](entity: d, startedAt: Pipeline[Document](doc).startedAt)\n  Stage3[Document](../../examples/pipeline)\n\nproc publish(doc: DocApproved): DocPublished =\n  echo \"  Published: \", doc.entity().title\n  doc.advance34()\n\nblock docExample:\n  echo \"\\n=== Document Review Example ===\"\n\n  let published = createDraft(\"Q4 Strategy\")\n    .edit(\"Our goals for Q4 include...\")\n    .submitForReview(\"alice@company.com\")\n    .approve(\"bob@company.com\")\n    .publish()\n\n  echo \"  Document '\", published.entity().title, \"' is live!\"\n\n  # COMPILE ERRORS:\n  # discard createDraft(\"Doc\").publish()  # Can't publish without review!\n\n# =============================================================================\n# Example 4: Deployment Pipeline\n# =============================================================================\n\ntype\n  Deployment = object\n    service: string\n    version: string\n    environment: string\n\n  # Semantic aliases\n  DeployStaging = Stage1[Deployment]\n  DeployCanary = Stage2[Deployment]\n  DeployPartial = Stage3[Deployment]\n  DeployFull = Stage4[Deployment]\n\nproc deployToStaging(service, version: string): DeployStaging =\n  echo \"  Deploying \", service, \" v\", version, \" to staging\"\n  start(Deployment(service: service, version: version, environment: \"staging\"), \"now\")\n\nproc promoteToCanary(d: DeployStaging): DeployCanary =\n  echo \"  Promoting to canary (1% traffic)\"\n  var dep = d.entity()\n  dep.environment = \"canary\"\n  Stage2[Deployment](../../examples/Pipeline[Deployment](entity: dep, startedAt: \"now\"))\n\nproc expandToPartial(d: DeployCanary): DeployPartial =\n  echo \"  Expanding to 25% traffic\"\n  var dep = d.entity()\n  dep.environment = \"partial\"\n  Stage3[Deployment](../../examples/Pipeline[Deployment](entity: dep, startedAt: \"now\"))\n\nproc rolloutFull(d: DeployPartial): DeployFull =\n  echo \"  Full rollout to 100% traffic\"\n  var dep = d.entity()\n  dep.environment = \"production\"\n  Stage4[Deployment](../../examples/Pipeline[Deployment](entity: dep, startedAt: \"now\"))\n\nblock deployExample:\n  echo \"\\n=== Deployment Pipeline Example ===\"\n\n  let production = deployToStaging(\"api-server\", \"2.3.0\")\n    .promoteToCanary()\n    .expandToPartial()\n    .rolloutFull()\n\n  echo \"  \", production.entity().service, \" v\", production.entity().version,\n       \" is now in \", production.entity().environment\n\n# =============================================================================\n# Summary\n# =============================================================================\n\necho \"\\n=== Summary ===\"\necho \"The Pipeline[T] pattern ensures:\"\necho \"  - Entities must progress through stages in order\"\necho \"  - No stage can be skipped\"\necho \"  - Operations are only valid at appropriate stages\"\necho \"  - Works with ANY entity type via generics\"\necho \"\"\necho \"Common applications:\"\necho \"  - Order fulfillment (Cart -&gt; Paid -&gt; Shipped -&gt; Delivered)\"\necho \"  - CI/CD builds (Queue -&gt; Compile -&gt; Test -&gt; Deploy)\"\necho \"  - Document review (Draft -&gt; Review -&gt; Approve -&gt; Publish)\"\necho \"  - Canary deployments (Staging -&gt; Canary -&gt; Partial -&gt; Full)\"\n\necho \"\\nAll examples passed!\"\n</code></pre> <p>:material-file-code: View full source</p>"},{"location":"guide/examples/#tips-for-designing-typestates","title":"Tips for Designing Typestates","text":""},{"location":"guide/examples/#1-start-with-the-state-diagram","title":"1. Start with the State Diagram","text":"<p>Draw your states and transitions first. Each arrow becomes a transition declaration.</p>"},{"location":"guide/examples/#2-one-responsibility-per-state","title":"2. One Responsibility Per State","text":"<p>Each state should represent one clear condition. If a state has multiple meanings, split it.</p>"},{"location":"guide/examples/#3-use-wildcards-sparingly","title":"3. Use Wildcards Sparingly","text":"<p><code>* -&gt; X</code> is powerful but can hide bugs. Use it only for truly universal operations like \"reset\" or \"emergency stop\".</p>"},{"location":"guide/examples/#4-consider-error-states","title":"4. Consider Error States","text":"<p>Many real systems need error/failure states. Plan for them upfront.</p>"},{"location":"guide/examples/#5-document-state-meanings","title":"5. Document State Meanings","text":"<p>Even with types enforcing transitions, document what each state means:</p> <pre><code>type\n  Pending = distinct Order\n    ## Order placed but not paid\n\n  Paid = distinct Order\n    ## Payment received, awaiting fulfillment\n\n  Shipped = distinct Order\n    ## Order shipped to customer\n</code></pre>"},{"location":"guide/formal-guarantees/","title":"Formal Guarantees","text":""},{"location":"guide/formal-guarantees/#formal-guarantees","title":"Formal Guarantees","text":"<p>This page explains the verification properties that nim-typestates provides and how they relate to formal methods concepts.</p>"},{"location":"guide/formal-guarantees/#correctness-by-construction","title":"Correctness by Construction","text":"<p>nim-typestates implements a form of correctness by construction: rather than testing for state machine violations at runtime, the type system makes them impossible to express.</p> <p>The Nim compiler acts as a verifier. If compilation succeeds, the program has been proven to contain no invalid state transitions.</p>"},{"location":"guide/formal-guarantees/#what-is-verified","title":"What is Verified","text":""},{"location":"guide/formal-guarantees/#temporal-safety","title":"Temporal Safety","text":"<p>Standard type systems verify data safety: a variable declared as <code>int</code> cannot be used as a <code>string</code>. Typestates extend this to temporal safety: an object in state <code>Closed</code> cannot be used where state <code>Open</code> is required.</p> <p>This prevents a class of bugs where operations are called in the wrong order or on objects in invalid states.</p>"},{"location":"guide/formal-guarantees/#protocol-adherence","title":"Protocol Adherence","text":"<p>Each <code>{.transition.}</code> proc is checked against the declared state graph. The compiler rejects any proc that:</p> <ul> <li>Takes a state type not registered in a typestate</li> <li>Returns a state not reachable from the input state</li> <li>Implements an undeclared transition</li> </ul>"},{"location":"guide/formal-guarantees/#state-exclusivity","title":"State Exclusivity","text":"<p>Distinct types ensure an object cannot satisfy multiple state types simultaneously. The type <code>Closed</code> is incompatible with <code>Open</code> at the type level, not just the value level.</p>"},{"location":"guide/formal-guarantees/#limitations","title":"Limitations","text":""},{"location":"guide/formal-guarantees/#specification-correctness","title":"Specification Correctness","text":"<p>The compiler verifies that code follows the declared state machine. It does not verify that the state machine correctly models the intended protocol.</p> <p>If the specification is wrong, the implementation will be \"correctly wrong.\"</p>"},{"location":"guide/formal-guarantees/#functional-correctness","title":"Functional Correctness","text":"<p>Typestates verify when operations can be called, not what they do. A <code>{.transition.}</code> proc from <code>Closed</code> to <code>Open</code> is verified to be callable only on <code>Closed</code> values and to return <code>Open</code> values. The proc body itself is not verified.</p>"},{"location":"guide/formal-guarantees/#runtime-behavior","title":"Runtime Behavior","text":"<p>Typestates operate at compile time. Runtime properties such as performance, memory safety, or exception behavior are outside their scope.</p> <p>For guidance on modeling errors as states rather than exceptions, see Error Handling.</p>"},{"location":"guide/formal-guarantees/#comparison-to-full-formal-verification","title":"Comparison to Full Formal Verification","text":"Aspect nim-typestates Full Formal Methods (TLA+, Coq) What is verified Protocol adherence Functional correctness Verification method Type checking Theorem proving Effort required Automatic Manual proofs Typical use Application protocols Safety-critical systems <p>nim-typestates occupies a practical middle ground: stronger guarantees than testing, lower cost than full formal verification.</p>"},{"location":"guide/generics/","title":"Generic Typestates","text":""},{"location":"guide/generics/#generic-typestates","title":"Generic Typestates","text":"<p>nim-typestates supports generic type parameters, enabling reusable typestate patterns.</p>"},{"location":"guide/generics/#basic-generic-typestate","title":"Basic Generic Typestate","text":"<p>Define a typestate with type parameters:</p> <pre><code>import typestates\n\ntype\n  Container[T] = object\n    value: T\n  Empty[T] = distinct Container[T]\n  Full[T] = distinct Container[T]\n\ntypestate Container[T]:\n  states Empty[T], Full[T]\n  transitions:\n    Empty[T] -&gt; Full[T]\n    Full[T] -&gt; Empty[T]\n</code></pre> <p>Implement transitions using generic procs:</p> <pre><code>proc fill[T](c: Empty[T], val: T): Full[T] {.transition.} =\n  var cont = Container[T](c)\n  cont.value = val\n  result = Full[T](cont)\n\nproc empty[T](c: Full[T]): Empty[T] {.transition.} =\n  result = Empty[T](Container[T](c))\n</code></pre> <p>Use with any type:</p> <pre><code># With int\nlet e = Empty[int](Container[int](value: 0))\nlet f = e.fill(42)\nlet e2 = f.empty()\n\n# With string\nlet s = Empty[string](Container[string](value: \"\"))\nlet s2 = s.fill(\"hello\")\n</code></pre>"},{"location":"guide/generics/#multiple-type-parameters","title":"Multiple Type Parameters","text":"<p>Typestates can have multiple type parameters:</p> <pre><code>type\n  KeyValue[K, V] = object\n    key: K\n    value: V\n  EmptyKV[K, V] = distinct KeyValue[K, V]\n  HasKey[K, V] = distinct KeyValue[K, V]\n  HasBoth[K, V] = distinct KeyValue[K, V]\n\ntypestate KeyValue[K, V]:\n  states EmptyKV[K, V], HasKey[K, V], HasBoth[K, V]\n  transitions:\n    EmptyKV[K, V] -&gt; HasKey[K, V]\n    HasKey[K, V] -&gt; HasBoth[K, V]\n    HasBoth[K, V] -&gt; EmptyKV[K, V]\n\nproc setKey[K, V](kv: EmptyKV[K, V], key: K): HasKey[K, V] {.transition.} =\n  var obj = KeyValue[K, V](kv)\n  obj.key = key\n  result = HasKey[K, V](obj)\n\nproc setValue[K, V](kv: HasKey[K, V], value: V): HasBoth[K, V] {.transition.} =\n  var obj = KeyValue[K, V](kv)\n  obj.value = value\n  result = HasBoth[K, V](obj)\n</code></pre>"},{"location":"guide/generics/#non-transitions-with-generics","title":"Non-Transitions with Generics","text":"<p>Use <code>{.notATransition.}</code> for operations that don't change state:</p> <pre><code>proc peek[T](c: Full[T]): T {.notATransition.} =\n  Container[T](c).value\n\nproc size[K, V](kv: HasBoth[K, V]): int {.notATransition.} =\n  1  # Always contains one key-value pair\n</code></pre>"},{"location":"guide/generics/#type-conversion-syntax","title":"Type Conversion Syntax","text":"<p>When converting between distinct generic types, use <code>Type[params](value)</code> syntax:</p> <pre><code># Correct - explicit generic parameters\nvar cont = Container[T](c)        # From distinct to base\nresult = Full[T](cont)            # From base to distinct\n\n# Wrong - method call syntax doesn't work with generics\n# var cont = c.Container[T]       # Compile error\n</code></pre>"},{"location":"guide/generics/#generated-helpers","title":"Generated Helpers","text":"<p>Generic typestates get fully parameterized helper types:</p> Helper Non-Generic Example Generic Example State enum <code>FileState = enum fsClosed, fsOpen</code> <code>ContainerState = enum fsEmpty, fsFull</code> Union type <code>FileStates = Closed \\| Open</code> <code>ContainerStates[T] = Empty[T] \\| Full[T]</code> State procs <code>proc state(f: Closed): FileState</code> <code>proc state[T](c: Empty[T]): ContainerState</code> <p>Usage example:</p> <pre><code># State enum works the same\ncheck fsEmpty is ContainerState\ncheck fsFull is ContainerState\n\n# Union type is parameterized\nproc acceptAny[T](c: ContainerStates[T]): ContainerState =\n  c.state\n\nlet e = Empty[int](Container[int](value: 0))\ncheck acceptAny(e) == fsEmpty\n\n# State procs are generic\nlet f = Full[string](Container[string](value: \"hello\"))\ncheck f.state == fsFull\n</code></pre>"},{"location":"guide/generics/#branching-transitions-with-generics","title":"Branching Transitions with Generics","text":"<p>Generic typestates fully support branching transitions with parameterized branch types:</p> <pre><code>type\n  Container[T] = object\n    value: T\n  Empty[T] = distinct Container[T]\n  Full[T] = distinct Container[T]\n  Error[T] = distinct Container[T]\n\ntypestate Container[T]:\n  states Empty[T], Full[T], Error[T]\n  transitions:\n    Empty[T] -&gt; (Full[T] | Error[T]) as FillResult[T]\n    Full[T] -&gt; Empty[T]\n</code></pre> <p>This generates:</p> <pre><code># Branch type enum (not parameterized)\ntype FillResultKind* = enum fFull, fError\n\n# Branch type (parameterized)\ntype FillResult*[T] = object\n  case kind*: FillResultKind\n  of fFull: full*: Full[T]\n  of fError: error*: Error[T]\n\n# Constructors (generic)\nproc toFillResult*[T](s: Full[T]): FillResult[T]\nproc toFillResult*[T](s: Error[T]): FillResult[T]\n\n# Operator (generic)\ntemplate `-&gt;`*[T](_: typedesc[FillResult[T]], s: Full[T]): FillResult[T]\ntemplate `-&gt;`*[T](_: typedesc[FillResult[T]], s: Error[T]): FillResult[T]\n</code></pre> <p>Usage:</p> <pre><code>proc fill[T](e: Empty[T], val: T): FillResult[T] =\n  if val == default(T):\n    FillResult[T] -&gt; Error[T](Container[T](e))\n  else:\n    var c = Container[T](e)\n    c.value = val\n    FillResult[T] -&gt; Full[T](c)\n\nlet empty = Empty[int](Container[int](value: 0))\nlet result = fill(empty, 42)\n\ncase result.kind\nof fFull: echo \"Got value: \", Container[int](result.full).value\nof fError: echo \"Failed\"\n</code></pre>"},{"location":"guide/generics/#supported-type-expressions","title":"Supported Type Expressions","text":"<p>Generic typestates support various type expressions:</p> Type Expression Example Notes Simple generics <code>Container[T]</code> Single type parameter Multi-param generics <code>Map[K, V]</code> Multiple type parameters Nested generics <code>Container[seq[T]]</code> Generic of generic Constrained generics <code>Container[T: SomeInteger]</code> With type bounds (see below) Static parameters <code>Buffer[N: static int]</code> Compile-time values"},{"location":"guide/generics/#constrained-generic-parameters","title":"Constrained Generic Parameters","text":"<p>When using constrained generic parameters, you must repeat the constraint in the typestate declaration. This applies to all constraints including type bounds (<code>SomeInteger</code>, <code>SomeNumber</code>) and static parameters (<code>static int</code>).</p> <pre><code>type\n  # Type definitions with constraints\n  Buffer[N: static int] = object\n    data: array[N, byte]\n  Empty[N: static int] = distinct Buffer[N]\n  Full[N: static int] = distinct Buffer[N]\n\n# Constraint MUST be repeated in typestate header\ntypestate Buffer[N: static int]:\n  states Empty[N], Full[N]\n  transitions:\n    Empty[N] -&gt; Full[N]\n    Full[N] -&gt; Empty[N]\n</code></pre> <p>The same applies to type constraints:</p> <pre><code>type\n  NumericContainer[T: SomeNumber] = object\n    value: T\n  Unset[T: SomeNumber] = distinct NumericContainer[T]\n  Set[T: SomeNumber] = distinct NumericContainer[T]\n\n# Constraint MUST be repeated\ntypestate NumericContainer[T: SomeNumber]:\n  states Unset[T], Set[T]\n  transitions:\n    Unset[T] -&gt; Set[T]\n</code></pre>"},{"location":"guide/generics/#pattern-builder-with-required-fields","title":"Pattern: Builder with Required Fields","text":"<p>Use generics to track which fields have been set:</p> <pre><code>type\n  UserBuilder = object\n    name: string\n    email: string\n\n  NeedsBoth = distinct UserBuilder\n  NeedsEmail = distinct UserBuilder\n  Complete = distinct UserBuilder\n\ntypestate UserBuilder:\n  states NeedsBoth, NeedsEmail, Complete\n  transitions:\n    NeedsBoth -&gt; NeedsEmail\n    NeedsEmail -&gt; Complete\n\nproc withName(b: NeedsBoth, name: string): NeedsEmail {.transition.} =\n  var builder = UserBuilder(b)\n  builder.name = name\n  result = NeedsEmail(builder)\n\nproc withEmail(b: NeedsEmail, email: string): Complete {.transition.} =\n  var builder = UserBuilder(b)\n  builder.email = email\n  result = Complete(builder)\n\nproc build(b: Complete): User {.notATransition.} =\n  let builder = UserBuilder(b)\n  User(name: builder.name, email: builder.email)\n</code></pre>"},{"location":"guide/generics/#pattern-resource-wrapper","title":"Pattern: Resource Wrapper","text":"<p>Wrap any resource type with acquire/release protocol:</p> <pre><code>type\n  Resource[T] = object\n    handle: T\n  Released[T] = distinct Resource[T]\n  Acquired[T] = distinct Resource[T]\n\ntypestate Resource[T]:\n  states Released[T], Acquired[T]\n  transitions:\n    Released[T] -&gt; Acquired[T]\n    Acquired[T] -&gt; Released[T]\n\nproc acquire[T](r: Released[T], handle: T): Acquired[T] {.transition.} =\n  var res = Resource[T](r)\n  res.handle = handle\n  result = Acquired[T](res)\n\nproc release[T](r: Acquired[T]): Released[T] {.transition.} =\n  result = Released[T](Resource[T](r))\n\nproc use[T](r: Acquired[T]): T {.notATransition.} =\n  Resource[T](r).handle\n</code></pre>"},{"location":"guide/generics/#static-parameters-as-state-differentiation","title":"Static Parameters as State Differentiation","text":"<p>A common pattern in embedded programming (see Nim forum discussion) uses static parameters to differentiate states at compile time:</p> <pre><code># What you might want to write (DOES NOT WORK):\ntype\n  GPIO[Enabled: static bool, Dir: static Option[Direction]] = object\n    pin: int\n\ntypestate GPIO[Enabled: static bool, Dir: static Option[Direction]]:\n  states GPIO[false, none(Direction)], GPIO[true, none(Direction)]\n  transitions:\n    GPIO[false, none(Direction)] -&gt; GPIO[true, none(Direction)]\n</code></pre> <p>This fails because all states share the same base name <code>GPIO</code>. The library cannot generate unique enum values, union types, or state procs when base names collide.</p> <p>Use distinct wrapper types instead:</p> <pre><code>type\n  GPIO[Enabled: static bool, Dir: static Option[Direction]] = object\n    pin: int\n\n  # Wrapper types with unique base names\n  Disabled = distinct GPIO[false, none(Direction)]\n  EnabledNoDir = distinct GPIO[true, none(Direction)]\n  InputMode = distinct GPIO[true, some(Input)]\n  OutputMode = distinct GPIO[true, some(Output)]\n\ntypestate GPIO[Enabled: static bool, Dir: static Option[Direction]]:\n  states Disabled, EnabledNoDir, InputMode, OutputMode\n  transitions:\n    Disabled -&gt; EnabledNoDir\n    EnabledNoDir -&gt; InputMode\n    EnabledNoDir -&gt; OutputMode\n\nproc enable(g: Disabled): EnabledNoDir {.transition.} =\n  EnabledNoDir(GPIO[true, none(Direction)](pin: GPIO[false, none(Direction)](g).pin))\n\nproc setInput(g: EnabledNoDir): InputMode {.transition.} =\n  InputMode(GPIO[true, some(Input)](pin: GPIO[true, none(Direction)](g).pin))\n</code></pre> <p>This approach:</p> <ul> <li>Preserves the zero-cost abstraction (distinct types compile away)</li> <li>Gives states meaningful names in error messages</li> <li>Works with all library features (enums, unions, branching)</li> </ul>"},{"location":"guide/generics/#limitations","title":"Limitations","text":"<ol> <li> <p>Constraints must be repeated: Generic constraints (<code>static int</code>, <code>SomeInteger</code>, etc.) must be explicitly stated in the typestate header - they cannot be inferred from type definitions. See Constrained Generic Parameters.</p> </li> <li> <p>Unique base names required: All states must have distinct base type names. Using the same type with different parameters (like <code>GPIO[false]</code> vs <code>GPIO[true]</code>) is not supported. See Static Parameters as State Differentiation for the workaround.</p> </li> <li> <p>Branch type params must match: Branch type parameters must use the same type variables as the typestate (e.g., <code>FillResult[K]</code> when typestate uses <code>T</code> will fail).</p> </li> <li> <p>Distinct types with multiple params: Due to a Nim compiler limitation, using <code>distinct</code> with multiple generic params may cause C compilation errors. Use wrapper objects instead:</p> </li> </ol> <pre><code># May cause issues with distinct\ntype EmptyMap[K, V] = distinct Map[K, V]\n\n# Works reliably\ntype EmptyMap[K, V] = object\n  inner: Map[K, V]\n</code></pre>"},{"location":"guide/generics/#next-steps","title":"Next Steps","text":"<ul> <li>DSL Reference - Complete syntax reference</li> <li>Examples - More usage patterns</li> </ul>"},{"location":"guide/getting-started/","title":"Getting Started","text":""},{"location":"guide/getting-started/#getting-started","title":"Getting Started","text":"<p>This guide walks through building a typestate-validated file handle from scratch.</p>"},{"location":"guide/getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Nim 2.0 or later</li> <li>Basic familiarity with Nim's type system</li> </ul>"},{"location":"guide/getting-started/#installation","title":"Installation","text":"<pre><code>nimble install typestates\n</code></pre> <p>Nim &lt; 2.2.8 with Static Generics</p> <p>If you use <code>static</code> generic parameters (e.g., <code>Buffer[N: static int]</code>) with ARC/ORC/AtomicARC, you may hit a Nim codegen bug fixed in Nim 2.2.8. The library detects this and shows workarounds. Options:</p> <ol> <li>Upgrade to Nim &gt;= 2.2.8</li> <li>Use <code>--mm:refc</code> instead</li> <li>Add <code>consumeOnTransition = false</code> to your typestate</li> <li>Make your base type inherit from <code>RootObj</code> and add <code>inheritsFromRootObj = true</code></li> </ol> <p>Regular generics (<code>Container[T]</code>) are not affected.</p>"},{"location":"guide/getting-started/#step-1-define-your-base-type","title":"Step 1: Define Your Base Type","text":"<p>Start with a regular object type that holds your data:</p> <pre><code>type\n  File = object\n    path: string\n    handle: int  # OS file descriptor\n</code></pre>"},{"location":"guide/getting-started/#step-2-define-state-types","title":"Step 2: Define State Types","text":"<p>Create distinct types for each state. Using <code>distinct</code> ensures the compiler treats them as different types:</p> <pre><code>type\n  File = object\n    path: string\n    handle: int\n\n  Closed = distinct File\n  Open = distinct File\n</code></pre> <p>Now <code>Closed</code> and <code>Open</code> are incompatible types - you can't pass a <code>Closed</code> where an <code>Open</code> is expected.</p>"},{"location":"guide/getting-started/#step-3-declare-the-typestate","title":"Step 3: Declare the Typestate","text":"<p>Import the library and declare valid transitions:</p> <pre><code>import typestates\n\ntype\n  File = object\n    path: string\n    handle: int\n  Closed = distinct File\n  Open = distinct File\n\ntypestate File:\n  states Closed, Open\n  transitions:\n    Closed -&gt; Open\n    Open -&gt; Closed\n</code></pre> <p>This tells the compiler:</p> <ul> <li><code>File</code> has two states: <code>Closed</code> and <code>Open</code></li> <li><code>Closed</code> can transition to <code>Open</code></li> <li><code>Open</code> can transition to <code>Closed</code></li> <li>No other transitions are valid</li> </ul>"},{"location":"guide/getting-started/#step-4-implement-transitions","title":"Step 4: Implement Transitions","text":"<p>Use the <code>{.transition.}</code> pragma to mark state-changing procs:</p> <pre><code>proc open(f: Closed, path: string): Open {.transition.} =\n  ## Open a closed file, returning it in the Open state.\n  var file = f.File  # Access underlying File\n  file.path = path\n  file.handle = 1  # Pretend we opened it\n  result = Open(file)\n\nproc close(f: Open): Closed {.transition.} =\n  ## Close an open file, returning it in the Closed state.\n  var file = f.File\n  file.handle = 0  # Pretend we closed it\n  result = Closed(file)\n</code></pre> <p>The <code>{.transition.}</code> pragma validates at compile time that:</p> <ol> <li>The input type (<code>Closed</code> or <code>Open</code>) is a registered state</li> <li>The return type is a valid transition target</li> <li>The transition is declared in the typestate block</li> </ol>"},{"location":"guide/getting-started/#step-5-use-it","title":"Step 5: Use It","text":"<pre><code># Create a file in the Closed state\nvar f = Closed(File(path: \"\", handle: 0))\n\n# Open it - returns Open type\nlet opened = f.open(\"/tmp/example.txt\")\n\n# Close it - returns Closed type\nlet closed = opened.close()\n\n# This won't compile!\n# let bad = opened.open(\"/other.txt\")\n# Error: Undeclared transition: Open -&gt; Open\n</code></pre>"},{"location":"guide/getting-started/#what-happens-on-invalid-transitions","title":"What Happens on Invalid Transitions?","text":"<p>If you try to implement an undeclared transition:</p> <pre><code>proc lock(f: Open): Locked {.transition.} =\n  discard\n</code></pre> <p>You get a compile-time error:</p> <pre><code>Error: Undeclared transition: Open -&gt; Locked\n  Typestate 'File' does not declare this transition.\n  Valid transitions from 'Open': @[\"Closed\"]\n  Hint: Add 'Open -&gt; Locked' to the transitions block.\n</code></pre>"},{"location":"guide/getting-started/#generated-helpers","title":"Generated Helpers","text":"<p>The <code>typestate</code> macro generates some useful types:</p>"},{"location":"guide/getting-started/#state-enum","title":"State Enum","text":"<pre><code>type FileState* = enum\n  fsClosed, fsOpen\n</code></pre>"},{"location":"guide/getting-started/#union-type","title":"Union Type","text":"<pre><code>type FileStates* = Closed | Open\n</code></pre>"},{"location":"guide/getting-started/#state-procs","title":"State Procs","text":"<pre><code>proc state*(f: Closed): FileState = fsClosed\nproc state*(f: Open): FileState = fsOpen\n</code></pre> <p>Use them for runtime inspection when needed:</p> <pre><code>proc describe[S: FileStates](f: S): string =\n  case f.state\n  of fsClosed: \"File is closed\"\n  of fsOpen: \"File is open\"\n</code></pre>"},{"location":"guide/getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>DSL Reference - Learn about branching, wildcards, and more</li> <li>Examples - See real-world patterns</li> <li>Error Handling - Model errors as states</li> </ul> <p>For details on what the compiler verifies, see Formal Guarantees.</p>"},{"location":"guide/strict-mode/","title":"Strict Mode","text":""},{"location":"guide/strict-mode/#strict-mode","title":"Strict Mode","text":"<p>nim-typestates uses strict defaults to catch bugs early.</p>"},{"location":"guide/strict-mode/#default-behavior","title":"Default Behavior","text":"<p>By default, typestates have:</p> <ul> <li><code>strictTransitions = true</code> - All procs with state params must be marked</li> <li><code>consumeOnTransition = true</code> - State types cannot be copied</li> </ul>"},{"location":"guide/strict-mode/#consumeontransition","title":"consumeOnTransition","text":"<p>When enabled (default), state types cannot be copied. This prevents bugs where you accidentally use a stale state after transitioning:</p> <pre><code>typestate File:\n  states Closed, Open\n  transitions:\n    Closed -&gt; Open\n    Open -&gt; Closed\n\nlet closed = Closed(File(handle: 0))\nlet opened = closed.open()  # closed is consumed\n\n# This would be a bug - closed already transitioned!\n# let opened2 = closed.open()  # Compile error: cannot copy\n</code></pre> <p>The <code>=copy</code> hook is generated with an error pragma, ensuring compile-time enforcement.</p>"},{"location":"guide/strict-mode/#opting-out","title":"Opting Out","text":"<pre><code>typestate LegacyFile:\n  consumeOnTransition = false  # Allow copying\n  states Closed, Open\n  ...\n</code></pre> <p>Use this when you genuinely need to copy state (e.g., for logging the \"before\" state).</p>"},{"location":"guide/strict-mode/#stricttransitions","title":"strictTransitions","text":"<p>When enabled, any proc with a state type as its first parameter MUST have either:</p> <ul> <li><code>{.transition.}</code> - for state-changing operations</li> <li><code>{.notATransition.}</code> - for read-only operations</li> </ul> <pre><code>typestate File:\n  states Closed, Open\n  transitions:\n    Closed -&gt; Open\n\nproc open(f: Closed): Open {.transition.} = ...     # OK\nproc read(f: Open): string {.notATransition.} = ... # OK\nproc helper(f: Open): int = ...                     # ERROR!\n</code></pre>"},{"location":"guide/strict-mode/#opting-out_1","title":"Opting Out","text":"<pre><code>typestate LegacyFile:\n  strictTransitions = false\n  states Closed, Open\n  ...\n</code></pre>"},{"location":"guide/strict-mode/#module-boundaries","title":"Module Boundaries","text":"<p>Typestates can only be defined once, in a single module. All states and transitions must be declared together:</p> <pre><code># library.nim\ntypestate Payment:\n  states Created, Captured\n  transitions:\n    Created -&gt; Captured\n\n# user_code.nim\nimport library\n\nproc check(p: Created): bool {.notATransition.} = ...  # OK - read-only\nproc hack(p: Created): Captured {.transition.} = ...   # ERROR - can't add transitions from external module\n</code></pre> <p>This ensures the typestate's behavior is fully defined where it's declared, preventing accidental or malicious modification from other modules.</p>"},{"location":"guide/verification/","title":"Verification","text":""},{"location":"guide/verification/#verification","title":"Verification","text":"<p>The typestates library provides multiple verification layers.</p>"},{"location":"guide/verification/#compile-time-checking","title":"Compile-Time Checking","text":"<p>The <code>{.transition.}</code> and <code>{.notATransition.}</code> pragmas validate at compile time:</p> <ul> <li>Transitions match declared state machine</li> <li>Sealed typestates block external transitions</li> </ul>"},{"location":"guide/verification/#verifytypestates-macro","title":"verifyTypestates() Macro","text":"<p>For comprehensive in-module verification:</p> <pre><code>import typestates\n\ntypestate File:\n  states Closed, Open\n  ...\n\nproc open(...) {.transition.} = ...\nproc close(...) {.transition.} = ...\n\nverifyTypestates()  # Validates everything above\n</code></pre>"},{"location":"guide/verification/#cli-tool","title":"CLI Tool","text":"<p>The <code>typestates</code> CLI provides project-wide verification and visualization:</p> <pre><code>typestates verify src/     # Check all procs are properly marked\ntypestates dot src/        # Generate GraphViz diagrams\n</code></pre> <p>See CLI Reference for complete usage and Visualization for diagram generation.</p>"},{"location":"guide/visualization/","title":"Visualization","text":""},{"location":"guide/visualization/#visualization","title":"Visualization","text":"<p>The <code>typestates dot</code> command generates GraphViz DOT output for visualizing state machines as diagrams.</p>"},{"location":"guide/visualization/#basic-usage","title":"Basic Usage","text":"<pre><code># Generate DOT output\ntypestates dot src/\n\n# Save to file\ntypestates dot src/ &gt; states.dot\n\n# Generate PNG directly\ntypestates dot src/ | dot -Tpng -o states.png\n\n# Generate SVG for web\ntypestates dot src/ | dot -Tsvg -o states.svg\n</code></pre>"},{"location":"guide/visualization/#options","title":"Options","text":"Option Description <code>--splines=MODE</code> Edge routing: <code>spline</code> (default), <code>ortho</code>, <code>polyline</code>, <code>line</code> <code>--separate</code> Generate separate graph per typestate <code>--no-style</code> Output minimal DOT without styling"},{"location":"guide/visualization/#edge-routing-modes","title":"Edge Routing Modes","text":"<pre><code># Curved edges (default) - best edge separation\ntypestates dot src/\n\n# Right-angle edges only\ntypestates dot --splines=ortho src/\n\n# Straight line segments\ntypestates dot --splines=polyline src/\n\n# Direct straight lines\ntypestates dot --splines=line src/\n</code></pre>"},{"location":"guide/visualization/#edge-styles","title":"Edge Styles","text":"<p>The CLI uses dark mode styling with different edge styles to distinguish transition types:</p> Type Style Description Normal Solid light gray Standard state transitions Wildcard Dotted gray Transitions from any state (<code>* -&gt; State</code>) Bridge Dashed light purple Cross-typestate transitions <p>Wildcard transitions are deduplicated: if an explicit transition exists (e.g., <code>Pooled -&gt; Closed</code>), the wildcard-expanded version is skipped.</p>"},{"location":"guide/visualization/#example-file-state-machine","title":"Example: File State Machine","text":"<p>Given this typestate definition:</p> <pre><code>import typestates\n\ntype\n  File = object\n    path: string\n  Closed = distinct File\n  Open = distinct File\n\ntypestate File:\n  states Closed, Open\n  transitions:\n    Closed -&gt; Open\n    Open -&gt; Closed\n</code></pre> <p>Running <code>typestates dot src/</code> produces:</p> <pre><code>digraph {\n  rankdir=TB;\n  splines=spline;\n  compound=true;\n  nodesep=1.0;\n  ranksep=1.0;\n  bgcolor=\"transparent\";\n  pad=0.3;\n\n  node [shape=box, style=\"rounded,filled\", fillcolor=\"#2d2d2d\", color=\"#b39ddb\", fontcolor=\"#e0e0e0\", fontname=\"sans-serif\", fontsize=14, margin=\"0.4,0.3\"];\n  edge [fontname=\"sans-serif\", fontsize=11, color=\"#b0b0b0\"];\n\n  subgraph cluster_File {\n    label=\"File\";\n    fontname=\"sans-serif\";\n    fontsize=16;\n    fontcolor=\"#e0e0e0\";\n    labelloc=t;\n    style=\"rounded\";\n    color=\"#b39ddb\";\n    bgcolor=\"#1e1e1e\";\n    margin=30;\n\n    Closed;\n    Open;\n\n    Closed -&gt; Open;\n    Open -&gt; Closed;\n  }\n}\n</code></pre> <p>Rendered as a diagram:</p> <p></p> <p>Output Format</p> <p>The CLI generates a unified graph with each typestate as a labeled subgraph. This allows multiple typestates and bridges to be visualized together in a single diagram.</p>"},{"location":"guide/visualization/#example-payment-processing","title":"Example: Payment Processing","text":"<p>A more complex example with branching transitions:</p> <pre><code>typestate Payment:\n  states Created, Authorized, Captured, PartiallyRefunded, FullyRefunded, Settled, Voided\n  transitions:\n    Created -&gt; Authorized\n    Authorized -&gt; (Captured | Voided) as AuthResult\n    Captured -&gt; (PartiallyRefunded | FullyRefunded | Settled) as CaptureResult\n    PartiallyRefunded -&gt; (PartiallyRefunded | FullyRefunded | Settled) as RefundResult\n    FullyRefunded -&gt; Settled\n</code></pre> <p></p>"},{"location":"guide/visualization/#example-wildcard-transitions","title":"Example: Wildcard Transitions","text":"<p>Wildcard transitions (<code>* -&gt; State</code>) are rendered with dotted gray edges:</p> <pre><code>typestate DbConnection:\n  states Pooled, CheckedOut, InTransaction, Closed\n  transitions:\n    Pooled -&gt; (CheckedOut | Closed) as PoolResult\n    CheckedOut -&gt; (Pooled | InTransaction | Closed) as CheckoutResult\n    InTransaction -&gt; CheckedOut\n    * -&gt; Closed\n</code></pre> <p></p> <p>The dotted gray edges indicate transitions that come only from the wildcard. Explicit transitions (like <code>Pooled -&gt; Closed</code>) remain solid.</p>"},{"location":"guide/visualization/#installing-graphviz","title":"Installing GraphViz","text":"<p>The DOT output can be rendered with GraphViz. Install it for your platform:</p> macOSUbuntu/DebianWindows <pre><code>brew install graphviz\n</code></pre> <pre><code>sudo apt install graphviz\n</code></pre> <pre><code>choco install graphviz\n</code></pre>"},{"location":"guide/visualization/#output-formats","title":"Output Formats","text":"<p>GraphViz supports many output formats:</p> Format Command Use Case PNG <code>dot -Tpng</code> Documentation, README SVG <code>dot -Tsvg</code> Web, scalable graphics PDF <code>dot -Tpdf</code> Print, documentation DOT (raw output) Further processing"},{"location":"guide/visualization/#customizing-output","title":"Customizing Output","text":"<p>The CLI produces dark mode styled output by default with light purple accents. For easier customization, use <code>--no-style</code> to get minimal DOT output:</p> <pre><code># Minimal output without styling - easier to customize\ntypestates dot --no-style src/ &gt; minimal.dot\n</code></pre> <p>You can also post-process the styled output:</p> <pre><code># Light mode (swap colors)\ntypestates dot src/ | sed 's/#2d2d2d/#f5f5f5/g; s/#1e1e1e/#fafafa/g; s/#e0e0e0/#212121/g; s/#b0b0b0/#424242/g' | dot -Tpng -o light.png\n</code></pre>"},{"location":"guide/visualization/#-no-style-output","title":"--no-style Output","text":"<p>The <code>--no-style</code> flag produces bare DOT structure with no styling attributes:</p> <pre><code>digraph {\n  subgraph cluster_File {\n    label=\"File\";\n\n    Closed;\n    Open;\n\n    Closed -&gt; Open;\n    Open -&gt; Closed;\n  }\n}\n</code></pre> <p>This is ideal when you want to apply your own colors, fonts, and layout settings. Edge styles (<code>dotted</code>, <code>dashed</code>) are preserved to distinguish wildcard and bridge transitions.</p>"},{"location":"guide/visualization/#generating-documentation-images","title":"Generating Documentation Images","text":"<p>To include diagrams in your documentation:</p> <pre><code># Create images directory\nmkdir -p docs/assets/images\n\n# Generate all typestate diagrams\ntypestates dot src/ | csplit -f docs/assets/images/state- -b '%02d.dot' - '/^digraph/' '{*}'\n\n# Convert each to SVG\nfor f in docs/assets/images/state-*.dot; do\n  dot -Tsvg \"$f\" -o \"${f%.dot}.svg\"\ndone\n</code></pre>"},{"location":"guide/visualization/#multiple-typestates","title":"Multiple Typestates","text":"<p>If your project has multiple typestates, the <code>dot</code> command outputs them all in a single unified graph with separate subgraphs. Bridges between typestates are shown as dashed purple edges.</p>"},{"location":"guide/visualization/#example-authentication-flow-with-session","title":"Example: Authentication Flow with Session","text":"<p>This example shows two typestates with bridges connecting them:</p> <pre><code># Session typestate\ntype\n  Session = object\n    userId: string\n  Active = distinct Session\n  Expired = distinct Session\n\ntypestate Session:\n  states Active, Expired\n  transitions:\n    Active -&gt; Expired\n\n# AuthFlow typestate with bridges to Session\ntype\n  AuthFlow = object\n    userId: string\n  Pending = distinct AuthFlow\n  Authenticated = distinct AuthFlow\n  Failed = distinct AuthFlow\n\ntypestate AuthFlow:\n  states Pending, Authenticated, Failed\n  transitions:\n    Pending -&gt; Authenticated\n    Pending -&gt; Failed\n  bridges:\n    Authenticated -&gt; Session.Active\n    Failed -&gt; Session.Expired\n</code></pre> <p></p> <p>The dashed purple edges show bridges connecting states across different typestates.</p>"}]}