{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#nim-typestates","title":"nim-typestates","text":"<p>Compile-time typestate validation for Nim.</p>"},{"location":"#what-is-this","title":"What is this?","text":"<p>nim-typestates is a Nim library that enforces state machine patterns at compile time. Define your valid states and transitions, and the compiler ensures your code follows them.</p> <pre><code>import typestates\n\ntype\n  File = object\n    path: string\n  Closed = distinct File\n  Open = distinct File\n\ntypestate File:\n  states Closed, Open\n  transitions:\n    Closed -&gt; Open\n    Open -&gt; Closed\n\nproc open(f: Closed): Open {.transition.} =\n  result = Open(f)\n\nproc close(f: Open): Closed {.transition.} =\n  result = Closed(f)\n\n# This works:\nlet f = Closed(File(path: \"/tmp/test\"))\nlet opened = f.open()\nlet closed = opened.close()\n\n# This won't compile - Open can't transition to Open!\n# let bad = opened.open()\n</code></pre> <p>The compiler verifies that your code follows the declared protocol. If it compiles, invalid state transitions are impossible. See Formal Guarantees for details.</p>"},{"location":"#why-typestates","title":"Why typestates?","text":"<p>Traditional runtime state machines have problems:</p> <ul> <li>Runtime errors: Invalid transitions cause crashes or bugs</li> <li>Defensive code: You write <code>if state == X</code> checks everywhere</li> <li>Documentation drift: State diagrams don't match code</li> </ul> <p>Typestates solve this by encoding states in the type system:</p> <ul> <li>Compile-time errors: Invalid transitions don't compile</li> <li>Self-documenting: Types show valid operations</li> <li>Zero runtime cost: It's just types</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>Compile-time validation - Invalid transitions fail at compile time with clear error messages</li> <li>Branching transitions - <code>Closed -&gt; Open | Errored as OpenResult</code> with user-named branch types</li> <li>Wildcard transitions - <code>* -&gt; Closed</code> (any state can close)</li> <li>Generated helpers - <code>FileState</code> enum, <code>FileStates</code> union type, branch constructors</li> <li>Cross-typestate bridges - Connect independent state machines</li> <li>GraphViz export - Visualize your state machine</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>nimble install typestates\n</code></pre> <p>Or add to your <code>.nimble</code> file:</p> <pre><code>requires \"typestates &gt;= 0.1.0\"\n</code></pre>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>Getting Started - Tutorial walkthrough</li> <li>DSL Reference - Complete syntax documentation</li> <li>Examples - Real-world patterns</li> <li>API Reference - Generated API docs</li> </ul>"},{"location":"#references","title":"References","text":""},{"location":"#foundational-papers","title":"Foundational Papers","text":"<ul> <li>Typestate: A Programming Language Concept (Strom &amp; Yemini, 1986) - The original paper introducing typestates as a compile-time mechanism for tracking object state</li> <li>Typestates for Objects (Aldrich et al., 2009) - Extends typestates to object-oriented programming with practical implementation strategies</li> </ul>"},{"location":"#tutorials-and-introductions","title":"Tutorials and Introductions","text":"<ul> <li>The Typestate Pattern in Rust - Accessible introduction to encoding typestates using Rust's type system</li> <li>Typestate Analysis (Wikipedia) - Overview of typestate analysis concepts and history</li> <li>Formal Verification (Wikipedia) - Background on formal methods that typestates relate to</li> </ul>"},{"location":"#related-projects","title":"Related Projects","text":"<ul> <li>typestate crate for Rust - Procedural macro approach to typestates in Rust, similar design philosophy to nim-typestates</li> <li>Plaid Programming Language - Research language from CMU with first-class typestate support built into the language</li> </ul>"},{"location":"#license","title":"License","text":"<p>MIT</p>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#api-reference","title":"API Reference","text":"<p>Auto-generated API documentation from source code.</p>"},{"location":"api/#main-module","title":"Main Module","text":""},{"location":"api/#typestates","title":"typestates","text":"<p>Compile-time state machine verification for Nim.</p> <p>This library enforces state machine protocols at compile time through Nim's type system. Programs that compile have been verified to contain no invalid state transitions.</p> <p>This approach is known as correctness by construction: invalid states become unrepresentable rather than checked at runtime.</p> <p>Exports:</p> <ul> <li><code>typestate</code> macro - Declare states and transitions</li> <li><code>{.transition.}</code> pragma - Mark and validate transition procs</li> <li><code>{.notATransition.}</code> pragma - Mark non-transition procs</li> </ul>"},{"location":"api/#typestate","title":"typestate","text":"<pre><code>macro typestate(name: untyped; body: untyped): untyped</code></pre> <p>Define a typestate with states and valid transitions.</p> <p>The typestate block declares:</p> <ul> <li>states: The distinct types that represent each state</li> <li>transitions: Which state changes are allowed</li> </ul> <p>Basic syntax:</p> <pre><code>typestate File:\n  states Closed, Open, Errored\n  transitions:\n    Closed -&gt; Open | Errored    # Branching\n    Open -&gt; Closed\n    * -&gt; Closed                 # Wildcard\n</code></pre> <p>What it generates:</p> <ul> <li><code>FileState</code> enum with <code>fsClosed</code>, <code>fsOpen</code>, <code>fsErrored</code></li> <li><code>FileStates</code> union type for generic procs</li> <li><code>state()</code> procs for runtime inspection</li> </ul> <p>Transition syntax:</p> <ul> <li><code>A -&gt; B</code> - Simple transition</li> <li><code>A -&gt; B | C</code> - Branching (can go to B or C)</li> <li><code>* -&gt; X</code> - Wildcard (any state can go to X)</li> </ul> <p>See also: <code>{.transition.}</code> pragma for implementing transitions</p> <p>:param name: The base type name (must match your type definition) :param body: The states and transitions declarations :returns: Generated helper types (enum, union, state procs)</p> Parameters <ul> <li> <code>name</code>               (<code>untyped</code>)                \u2013 The base type name (must match your type definition)             </li> <li> <code>body</code>               (<code>untyped</code>)                \u2013 The states and transitions declarations             </li> </ul> Returns <p><code>untyped</code> \u2013 Generated helper types (enum, union, state procs)</p> Source:              src/typestates.nim:21"},{"location":"api/#submodules","title":"Submodules","text":""},{"location":"api/#types_1","title":"Types","text":"<p>Core type definitions.</p>"},{"location":"api/#types","title":"types","text":"<p>Core type definitions for the typestate system.</p> <p>This module defines the internal representation of typestates, states, and transitions used during compile-time validation.</p> <p>These types are primarily used internally by the <code>typestate</code> macro and <code>{.transition.}</code> pragma. Most users won't interact with them directly.</p>"},{"location":"api/#extractBaseName","title":"extractBaseName","text":"<pre><code>proc extractBaseName(stateRepr: string): string</code></pre> <p>Extract the base type name from a state repr string.</p> <p>Used for comparing state names when generic parameters may differ:</p> <ul> <li><code>\"Empty\"</code> -&gt; <code>\"Empty\"</code></li> <li><code>\"Empty[T]\"</code> -&gt; <code>\"Empty\"</code></li> <li><code>\"Container[K, V]\"</code> -&gt; <code>\"Container\"</code></li> <li><code>\"ref Closed\"</code> -&gt; <code>\"Closed\"</code></li> </ul> <p>:param stateRepr: Full state repr string :returns: Base name without generic parameters</p> Parameters <ul> <li> <code>stateRepr</code>               (<code>string</code>)                \u2013 Full state repr string             </li> </ul> Returns <p><code>string</code> \u2013 Base name without generic parameters</p> Source:              src/typestates/types.nim:11"},{"location":"api/#State","title":"State","text":"<pre><code>type State</code></pre> Source:              src/typestates/types.nim:40"},{"location":"api/#Transition","title":"Transition","text":"<pre><code>type Transition</code></pre> Source:              src/typestates/types.nim:59"},{"location":"api/#Bridge","title":"Bridge","text":"<pre><code>type Bridge</code></pre> Source:              src/typestates/types.nim:95"},{"location":"api/#TypestateGraph","title":"TypestateGraph","text":"<pre><code>type TypestateGraph</code></pre> Source:              src/typestates/types.nim:125"},{"location":"api/#==","title":"==","text":"<pre><code>proc ==(a, b: Transition): bool</code></pre> <p>Compare two transitions for equality.</p> <p>Two transitions are equal if they have the same source state, destination states, and wildcard status. The declaration location is not considered for equality.</p> <p>:param a: First transition to compare :param b: Second transition to compare :returns: <code>true</code> if transitions are semantically equivalent</p> Parameters <ul> <li> <code>a</code>               (<code>Transition</code>)                \u2013 First transition to compare             </li> <li> <code>b</code>               (<code>Transition</code>)                \u2013 Second transition to compare             </li> </ul> Returns <p><code>bool</code> \u2013 `true` if transitions are semantically equivalent</p> Source:              src/typestates/types.nim:160"},{"location":"api/#==","title":"==","text":"<pre><code>proc ==(a, b: Bridge): bool</code></pre> <p>Compare two bridges for equality.</p> <p>Two bridges are equal if they have the same source state, destination typestate, and destination state. The declaration location is not considered for equality.</p> <p>:param a: First bridge to compare :param b: Second bridge to compare :returns: <code>true</code> if bridges are semantically equivalent</p> Parameters <ul> <li> <code>a</code>               (<code>Bridge</code>)                \u2013 First bridge to compare             </li> <li> <code>b</code>               (<code>Bridge</code>)                \u2013 Second bridge to compare             </li> </ul> Returns <p><code>bool</code> \u2013 `true` if bridges are semantically equivalent</p> Source:              src/typestates/types.nim:174"},{"location":"api/#hasTransition","title":"hasTransition","text":"<pre><code>proc hasTransition(graph: TypestateGraph; fromState, toState: string): bool</code></pre> <p>Check if a transition from <code>fromState</code> to <code>toState</code> is valid.</p> <p>This proc checks both explicit transitions and wildcard transitions. A transition is valid if there's an explicit transition <code>fromState -&gt; toState</code>, or there's a wildcard transition <code>* -&gt; toState</code>.</p> <p>Comparisons use base names to support generic types: - <code>hasTransition(g, \"Empty\", \"Full\")</code> matches <code>Empty[T] -&gt; Full[T]</code></p> <p>Example:</p> <pre><code># Given: Closed -&gt; Open, * -&gt; Closed\ngraph.hasTransition(\"Closed\", \"Open\")   # true\ngraph.hasTransition(\"Open\", \"Closed\")   # true (via wildcard)\ngraph.hasTransition(\"Closed\", \"Closed\") # true (via wildcard)\ngraph.hasTransition(\"Open\", \"Open\")     # false (not declared)\n</code></pre> <p>:param graph: The typestate graph to check :param fromState: The source state name (base name or full repr) :param toState: The destination state name (base name or full repr) :returns: <code>true</code> if the transition is allowed, <code>false</code> otherwise</p> Parameters <ul> <li> <code>graph</code>               (<code>TypestateGraph</code>)                \u2013 The typestate graph to check             </li> <li> <code>fromState</code>               (<code>string</code>)                \u2013 The source state name (base name or full repr)             </li> <li> <code>toState</code>               (<code>string</code>)                \u2013 The destination state name (base name or full repr)             </li> </ul> Returns <p><code>bool</code> \u2013 `true` if the transition is allowed, `false` otherwise</p> Source:              src/typestates/types.nim:188"},{"location":"api/#validDestinations","title":"validDestinations","text":"<pre><code>proc validDestinations(graph: TypestateGraph; fromState: string): seq[string]</code></pre> <p>Get all valid destination states from a given state.</p> <p>This includes both explicit transitions from <code>fromState</code> and destinations reachable via wildcard transitions.</p> <p>Comparisons use base names to support generic types. Returns base names for clearer error messages.</p> <p>Example:</p> <pre><code># Given: Closed -&gt; Open | Errored, * -&gt; Closed\ngraph.validDestinations(\"Closed\")  # @[\"Open\", \"Errored\", \"Closed\"]\ngraph.validDestinations(\"Open\")    # @[\"Closed\"]\n</code></pre> <p>:param graph: The typestate graph to query :param fromState: The source state to check transitions from :returns: A sequence of state base names that can be transitioned to</p> Parameters <ul> <li> <code>graph</code>               (<code>TypestateGraph</code>)                \u2013 The typestate graph to query             </li> <li> <code>fromState</code>               (<code>string</code>)                \u2013 The source state to check transitions from             </li> </ul> Returns <p><code>seq[string]</code> \u2013 A sequence of state base names that can be transitioned to</p> Source:              src/typestates/types.nim:222"},{"location":"api/#hasBridge","title":"hasBridge","text":"<pre><code>proc hasBridge(graph: TypestateGraph; fromState, toTypestate, toState: string): bool</code></pre> <p>Check if a bridge from <code>fromState</code> to <code>toTypestate.toState</code> is declared.</p> <p>Comparisons use base names to support generic types.</p> <p>Example:</p> <pre><code># Given: Authenticated -&gt; Session.Active\ngraph.hasBridge(\"Authenticated\", \"Session\", \"Active\")  # true\ngraph.hasBridge(\"Failed\", \"Session\", \"Active\")         # false\n</code></pre> <p>:param graph: The typestate graph to check :param fromState: The source state name :param toTypestate: The destination typestate name :param toState: The destination state name :returns: <code>true</code> if the bridge is declared, <code>false</code> otherwise</p> Parameters <ul> <li> <code>graph</code>               (<code>TypestateGraph</code>)                \u2013 The typestate graph to check             </li> <li> <code>fromState</code>               (<code>string</code>)                \u2013 The source state name             </li> <li> <code>toTypestate</code>               (<code>string</code>)                \u2013 The destination typestate name             </li> <li> <code>toState</code>               (<code>string</code>)                \u2013 The destination state name             </li> </ul> Returns <p><code>bool</code> \u2013 `true` if the bridge is declared, `false` otherwise</p> Source:              src/typestates/types.nim:252"},{"location":"api/#validBridges","title":"validBridges","text":"<pre><code>proc validBridges(graph: TypestateGraph; fromState: string): seq[string]</code></pre> <p>Get all valid bridge destinations from a given state.</p> <p>Returns dotted notation strings like \"Session.Active\".</p> <p>Example:</p> <pre><code># Given: Authenticated -&gt; Session.Active, Failed -&gt; ErrorLog.Entry\ngraph.validBridges(\"Authenticated\")  # @[\"Session.Active\"]\ngraph.validBridges(\"Failed\")         # @[\"ErrorLog.Entry\"]\n</code></pre> <p>:param graph: The typestate graph to query :param fromState: The source state to check bridges from :returns: A sequence of dotted destination names</p> Parameters <ul> <li> <code>graph</code>               (<code>TypestateGraph</code>)                \u2013 The typestate graph to query             </li> <li> <code>fromState</code>               (<code>string</code>)                \u2013 The source state to check bridges from             </li> </ul> Returns <p><code>seq[string]</code> \u2013 A sequence of dotted destination names</p> Source:              src/typestates/types.nim:280"},{"location":"api/#parser_1","title":"Parser","text":"<p>DSL parser for typestate blocks.</p>"},{"location":"api/#parser","title":"parser","text":"<p>Parser for the typestate DSL.</p> <p>This module transforms the AST from a <code>typestate</code> macro invocation into a <code>TypestateGraph</code> structure. It handles parsing of:</p> <ul> <li>State declarations (<code>states Closed, Open, Errored</code>)</li> <li>Transition declarations (<code>Closed -&gt; Open | Errored</code>)</li> <li>Wildcard transitions (<code>* -&gt; Closed</code>)</li> </ul> <p>The parser operates at compile-time within macro context.</p> <p>Internal module - most users won't interact with this directly.</p>"},{"location":"api/#parseStates","title":"parseStates","text":"<pre><code>proc parseStates(graph: var TypestateGraph; node: NimNode)</code></pre> <p>Parse a states declaration and add states to the graph.</p> <p>Accepts both command syntax (<code>states Closed, Open</code>) and call syntax (<code>states(Closed, Open)</code>).</p> <p>States can be any valid Nim type expression:</p> <ul> <li>Simple identifiers: <code>Closed</code>, <code>Open</code></li> <li>Generic types: <code>Container[T]</code>, <code>Map[K, V]</code></li> <li>Ref types: <code>ref Closed</code></li> <li>Qualified names: <code>mymodule.State</code></li> </ul> <p>Example AST inputs:</p> <pre><code># Simple: states Closed, Open\nCommand\n  Ident \"states\"\n  Ident \"Closed\"\n  Ident \"Open\"\n\n# Generic: states Empty[T], Full[T]\nCommand\n  Ident \"states\"\n  BracketExpr\n    Ident \"Empty\"\n    Ident \"T\"\n  BracketExpr\n    Ident \"Full\"\n    Ident \"T\"\n</code></pre> <p>:param graph: The typestate graph to populate :param node: AST node of the states declaration :raises: Compile-time error if syntax is invalid</p> Parameters <ul> <li> <code>graph</code>               (<code>var TypestateGraph</code>)                \u2013 The typestate graph to populate             </li> <li> <code>node</code>               (<code>NimNode</code>)                \u2013 AST node of the states declaration             </li> </ul> Source:              src/typestates/parser.nim:45"},{"location":"api/#parseTransition","title":"parseTransition","text":"<pre><code>proc parseTransition(node: NimNode): Transition</code></pre> <p>Parse a single transition declaration.</p> <p>Supports three forms:</p> <ul> <li>Simple: <code>Closed -&gt; Open</code></li> <li>Branching: <code>Closed -&gt; Open | Errored</code></li> <li>Wildcard: <code>* -&gt; Closed</code></li> </ul> <p>Example AST for <code>Closed -&gt; Open | Errored</code>:</p> <pre><code>Infix\n  Ident \"-&gt;\"\n  Ident \"Closed\"\n  Infix\n    Ident \"|\"\n    Ident \"Open\"\n    Ident \"Errored\"\n</code></pre> <p>Example AST for <code>* -&gt; Closed</code> (wildcard parsed as nested prefix):</p> <pre><code>Prefix\n  Ident \"*\"\n  Prefix\n    Ident \"-&gt;\"\n    Ident \"Closed\"\n</code></pre> <p>:param node: AST node of the transition expression :returns: A <code>Transition</code> object :raises: Compile-time error if syntax is invalid</p> Parameters <ul> <li> <code>node</code>               (<code>NimNode</code>)                \u2013 AST node of the transition expression             </li> </ul> Returns <p><code>Transition</code> \u2013 A `Transition` object</p> Source:              src/typestates/parser.nim:123"},{"location":"api/#parseBridgesBlock","title":"parseBridgesBlock","text":"<pre><code>proc parseBridgesBlock(graph: var TypestateGraph; node: NimNode)</code></pre> <p>Parse the bridges block and add all bridges to the graph.</p> <p>Example input:</p> <pre><code>bridges:\n  Authenticated -&gt; Session.Active\n  Failed -&gt; ErrorLog.Entry\n  * -&gt; Shutdown.Terminal\n</code></pre> <p>:param graph: The typestate graph to populate :param node: AST node of the bridges block :raises: Compile-time error if block is malformed</p> Parameters <ul> <li> <code>graph</code>               (<code>var TypestateGraph</code>)                \u2013 The typestate graph to populate             </li> <li> <code>node</code>               (<code>NimNode</code>)                \u2013 AST node of the bridges block             </li> </ul> Source:              src/typestates/parser.nim:311"},{"location":"api/#parseTypestateBody","title":"parseTypestateBody","text":"<pre><code>proc parseTypestateBody(name: NimNode; body: NimNode): TypestateGraph</code></pre> <p>Parse a complete typestate block body into a TypestateGraph.</p> <p>This is the main entry point for parsing. It processes the full body of a <code>typestate</code> macro invocation.</p> <p>The typestate name can be a simple identifier or a generic type:</p> <ul> <li>Simple: <code>typestate File:</code></li> <li>Generic: <code>typestate Container[T]:</code></li> </ul> <p>Examples:</p> <pre><code>typestate File:          # name = \"File\"\n  states Closed, Open\n  transitions:\n    Closed -&gt; Open\n\ntypestate Container[T]:  # name = \"Container\", with type param T\n  states Empty[T], Full[T]\n  transitions:\n    Empty[T] -&gt; Full[T]\n</code></pre> <p>:param name: The typestate name (identifier or bracket expression) :param body: The statement list containing states and transitions :returns: A fully populated <code>TypestateGraph</code> :raises: Compile-time error for invalid syntax</p> Parameters <ul> <li> <code>name</code>               (<code>NimNode</code>)                \u2013 The typestate name (identifier or bracket expression)             </li> <li> <code>body</code>               (<code>NimNode</code>)                \u2013 The statement list containing states and transitions             </li> </ul> Returns <p><code>TypestateGraph</code> \u2013 A fully populated `TypestateGraph`</p> Source:              src/typestates/parser.nim:415"},{"location":"api/#registry_1","title":"Registry","text":"<p>Compile-time typestate storage.</p>"},{"location":"api/#registry","title":"registry","text":"<p>Compile-time registry for typestate definitions.</p> <p>This module provides a global compile-time registry that stores all declared typestates. The registry enables:</p> <ul> <li>Looking up typestates by name</li> <li>Finding which typestate a state type belongs to</li> <li>Extending typestates across modules</li> </ul> <p>The registry is used by the <code>{.transition.}</code> pragma to validate that transitions are allowed.</p> <p>Internal module - most users won't interact with this directly.</p>"},{"location":"api/#registerTypestate","title":"registerTypestate","text":"<pre><code>template registerTypestate(graph: TypestateGraph)</code></pre> <p>Register a typestate graph in the compile-time registry.</p> <p>Each typestate can only be defined once. Attempting to register a typestate with the same name twice results in a compile error.</p> <p>Example:</p> <pre><code>typestate File:\n  states Closed, Open\n  transitions:\n    Closed -&gt; Open\n    Open -&gt; Closed\n</code></pre> <p>:param graph: The typestate graph to register</p> Parameters <ul> <li> <code>graph</code>               (<code>TypestateGraph</code>)                \u2013 The typestate graph to register             </li> </ul> Source:              src/typestates/registry.nim:61"},{"location":"api/#hasTypestate","title":"hasTypestate","text":"<pre><code>template hasTypestate(name: string): bool</code></pre> <p>Check if a typestate with the given name exists in the registry.</p> <p>:param name: The typestate name to look up :returns: <code>true</code> if registered, <code>false</code> otherwise</p> Parameters <ul> <li> <code>name</code>               (<code>string</code>)                \u2013 The typestate name to look up             </li> </ul> Returns <p><code>bool</code> \u2013 `true` if registered, `false` otherwise</p> Source:              src/typestates/registry.nim:87"},{"location":"api/#getTypestate","title":"getTypestate","text":"<pre><code>template getTypestate(name: string): TypestateGraph</code></pre> <p>Retrieve a typestate graph by name.</p> <p>:param name: The typestate name to look up :returns: The <code>TypestateGraph</code> for the typestate :raises: Compile-time error if not found</p> Parameters <ul> <li> <code>name</code>               (<code>string</code>)                \u2013 The typestate name to look up             </li> </ul> Returns <p><code>TypestateGraph</code> \u2013 The `TypestateGraph` for the typestate</p> Source:              src/typestates/registry.nim:94"},{"location":"api/#findTypestateForState","title":"findTypestateForState compileTime","text":"<pre><code>proc findTypestateForState(stateName: string): Option[TypestateGraph]</code></pre> <p>Find which typestate a given state belongs to.</p> <p>Searches all registered typestates to find one containing the specified state. Used by the <code>{.transition.}</code> pragma to determine which typestate graph to validate against.</p> <p>Lookups use base names to support generic types: - <code>findTypestateForState(\"Empty\")</code> finds <code>typestate Container</code> with <code>Empty[T]</code></p> <p>Example:</p> <pre><code># If File typestate has states Closed, Open:\nfindTypestateForState(\"Closed\")  # some(FileGraph)\nfindTypestateForState(\"Unknown\") # none\n\n# If Container typestate has states Empty[T], Full[T]:\nfindTypestateForState(\"Empty\")   # some(ContainerGraph)\n</code></pre> <p>:param stateName: The state type name (base name, e.g., \"Closed\", \"Empty\") :returns: <code>some(graph)</code> if found, <code>none</code> if state is not in any typestate</p> Parameters <ul> <li> <code>stateName</code>               (<code>string</code>)                \u2013 The state type name (base name, e.g., \"Closed\", \"Empty\")             </li> </ul> Returns <p><code>Option[TypestateGraph]</code> \u2013 `some(graph)` if found, `none` if state is not in any typestate</p> Source:              src/typestates/registry.nim:105"},{"location":"api/#BranchTypeInfo","title":"BranchTypeInfo","text":"<pre><code>type BranchTypeInfo</code></pre> Source:              src/typestates/registry.nim:136"},{"location":"api/#findBranchTypeInfo","title":"findBranchTypeInfo compileTime","text":"<pre><code>proc findBranchTypeInfo(typeName: string): Option[BranchTypeInfo]</code></pre> <p>Check if a type name is a user-defined branch type.</p> <p>Branch types are named by the user via <code>as TypeName</code> syntax in branching transitions.</p> <p>This function searches all registered typestates for branching transitions that declare the given branch type name.</p> <p>Example:</p> <pre><code># If typestate has: Created -&gt; Approved | Declined as ProcessResult\nfindBranchTypeInfo(\"ProcessResult\")\n# Returns: some(BranchTypeInfo(sourceState: \"Created\",\n#                              destinations: @[\"Approved\", \"Declined\"]))\n\nfindBranchTypeInfo(\"NotABranch\")\n# Returns: none(BranchTypeInfo)\n</code></pre> <p>:param typeName: The type name to check :returns: <code>some(info)</code> if it's a branch type, <code>none</code> otherwise</p> Parameters <ul> <li> <code>typeName</code>               (<code>string</code>)                \u2013 The type name to check             </li> </ul> Returns <p><code>Option[BranchTypeInfo]</code> \u2013 `some(info)` if it's a branch type, `none` otherwise</p> Source:              src/typestates/registry.nim:145"},{"location":"api/#pragmas_1","title":"Pragmas","text":"<p>Pragma implementations for transition validation.</p>"},{"location":"api/#pragmas","title":"pragmas","text":"<p>Pragmas for marking and validating state transitions.</p> <p>This module provides the pragmas that users apply to their procs:</p> <ul> <li><code>{.transition.}</code> - Mark a proc as a state transition (validated)</li> <li><code>{.notATransition.}</code> - Mark a proc as intentionally not a transition</li> </ul> <p>The <code>{.transition.}</code> pragma performs compile-time validation to ensure that only declared transitions are implemented.</p>"},{"location":"api/#registerSealedStates","title":"registerSealedStates compileTime","text":"<pre><code>proc registerSealedStates(modulePath: string; stateNames: seq[string])</code></pre> <p>Register states from a sealed typestate for external checking.</p> <p>:param modulePath: The module filename where the typestate is defined :param stateNames: List of state type names to register</p> Parameters <ul> <li> <code>modulePath</code>               (<code>string</code>)                \u2013 The module filename where the typestate is defined             </li> <li> <code>stateNames</code>               (<code>seq[string]</code>)                \u2013 List of state type names to register             </li> </ul> Source:              src/typestates/pragmas.nim:20"},{"location":"api/#isStateFromSealedTypestate","title":"isStateFromSealedTypestate compileTime","text":"<pre><code>proc isStateFromSealedTypestate(stateName: string; currentModule: string): Option[string]</code></pre> <p>Check if a state is from a sealed typestate defined in another module.</p> <p>:param stateName: The state type name to check :param currentModule: The current module's filename :returns: <code>some(modulePath)</code> if from external sealed typestate, <code>none</code> otherwise</p> Parameters <ul> <li> <code>stateName</code>               (<code>string</code>)                \u2013 The state type name to check             </li> <li> <code>currentModule</code>               (<code>string</code>)                \u2013 The current module's filename             </li> </ul> Returns <p><code>Option[string]</code> \u2013 `some(modulePath)` if from external sealed typestate, `none` otherwise</p> Source:              src/typestates/pragmas.nim:31"},{"location":"api/#transition","title":"transition","text":"<pre><code>macro transition(procDef: untyped): untyped</code></pre> <p>Mark a proc as a state transition and verify it at compile time.</p> <p>The compiler checks that the transition from the input state type to the return state type is declared in the corresponding typestate. If not, compilation fails with a diagnostic.</p> <p>This provides compile-time protocol enforcement: only declared transitions can be implemented.</p> <p>Example:</p> <pre><code>proc open(f: Closed): Open {.transition.} =\n  result = Open(f)\n\nproc close(f: Open): Closed {.transition.} =\n  result = Closed(f)\n</code></pre> <p>Error example:</p> <pre><code>Error: Undeclared transition: Open -&gt; Locked\n  Typestate 'File' does not declare this transition.\n  Valid transitions from 'Open': @[\"Closed\"]\n  Hint: Add 'Open -&gt; Locked' to the transitions block.\n</code></pre> Parameters <ul> <li> <code>procDef</code>               (<code>untyped</code>)                            </li> </ul> Returns <p><code>untyped</code></p> Source:              src/typestates/pragmas.nim:88"},{"location":"api/#notATransition","title":"notATransition pragma","text":"<pre><code>template notATransition()</code></pre> <p>Mark a proc as intentionally not a state transition.</p> <p>Use this pragma for procs that operate on state types but don't change the state. This is required when <code>strictTransitions</code> is enabled on the typestate.</p> <p>When to use:</p> <ul> <li>Procs that read from a state type</li> <li>Procs that perform I/O without changing state</li> <li>Procs that modify the underlying data without state transition</li> </ul> <p>Example:</p> <pre><code># Side effects without state change\nproc write(f: Open, data: string) {.notATransition.} =\n  rawWrite(f.handle, data)\n\n# Pure functions don't need this (use `func` instead)\nfunc path(f: Open): string = f.File.path\n</code></pre> Source:              src/typestates/pragmas.nim:230"},{"location":"api/#code-generation","title":"Code Generation","text":"<p>Code generation for helper types.</p>"},{"location":"api/#codegen","title":"codegen","text":"<p>Code generation for typestate helper types.</p> <p>This module generates the helper types and procs that make typestates easier to use at runtime:</p> <ul> <li>State enum: <code>FileState = enum fsClosed, fsOpen, ...</code></li> <li>Union type: <code>FileStates = Closed | Open | ...</code></li> <li>State procs: <code>proc state(f: Closed): FileState</code></li> <li>Branch types: <code>CreatedBranch</code> variant for <code>Created -&gt; Approved | Declined</code></li> <li>Branch constructors: <code>toCreatedBranch(s: Approved): CreatedBranch</code></li> </ul> <p>These are generated automatically by the <code>typestate</code> macro.</p>"},{"location":"api/#buildGenericParams","title":"buildGenericParams","text":"<pre><code>proc buildGenericParams(typeParams: seq[NimNode]): NimNode</code></pre> <p>Build a generic params node for proc/type definitions.</p> <p>For <code>@[T]</code>, generates: <code>[T]</code> For <code>@[K, V]</code>, generates: <code>[K, V]</code> For <code>@[]</code>, returns empty node (non-generic)</p> <p>:param typeParams: Sequence of type parameter idents :returns: nnkGenericParams node or newEmptyNode()</p> Parameters <ul> <li> <code>typeParams</code>               (<code>seq[NimNode]</code>)                \u2013 Sequence of type parameter idents             </li> </ul> Returns <p><code>NimNode</code> \u2013 nnkGenericParams node or newEmptyNode()</p> Source:              src/typestates/codegen.nim:17"},{"location":"api/#extractTypeParams","title":"extractTypeParams","text":"<pre><code>proc extractTypeParams(node: NimNode): seq[NimNode]</code></pre> <p>Extract type parameters from a type node.</p> <p>For <code>FillResult[T]</code>, returns <code>@[T]</code> For <code>Map[K, V]</code>, returns <code>@[K, V]</code> For <code>Simple</code>, returns <code>@[]</code></p> <p>:param node: A type AST node (ident or bracket expr) :returns: Sequence of type parameter nodes</p> Parameters <ul> <li> <code>node</code>               (<code>NimNode</code>)                \u2013 A type AST node (ident or bracket expr)             </li> </ul> Returns <p><code>seq[NimNode]</code> \u2013 Sequence of type parameter nodes</p> Source:              src/typestates/codegen.nim:32"},{"location":"api/#generateStateEnum","title":"generateStateEnum","text":"<pre><code>proc generateStateEnum(graph: TypestateGraph): NimNode</code></pre> <p>Generate a runtime enum representing all states.</p> <p>For a typestate named <code>File</code> with states <code>Closed</code>, <code>Open</code>, <code>Errored</code>, generates:</p> <pre><code>type FileState* = enum\n  fsClosed, fsOpen, fsErrored\n</code></pre> <p>For generic typestates like <code>Container[T]</code> with states <code>Empty[T]</code>, <code>Full[T]</code>:</p> <pre><code>type ContainerState* = enum\n  fsEmpty, fsFull\n</code></pre> <p>The enum values use base names (without type params) prefixed with <code>fs</code>.</p> <p>:param graph: The typestate graph to generate from :returns: AST for the enum type definition</p> Parameters <ul> <li> <code>graph</code>               (<code>TypestateGraph</code>)                \u2013 The typestate graph to generate from             </li> </ul> Returns <p><code>NimNode</code> \u2013 AST for the enum type definition</p> Source:              src/typestates/codegen.nim:46"},{"location":"api/#generateUnionType","title":"generateUnionType","text":"<pre><code>proc generateUnionType(graph: TypestateGraph): NimNode</code></pre> <p>Generate a type alias for \"any state\" using Nim's union types.</p> <p>For a typestate named <code>File</code> with states <code>Closed</code>, <code>Open</code>, <code>Errored</code>, generates:</p> <pre><code>type FileStates* = Closed | Open | Errored\n</code></pre> <p>For generic typestates like <code>Container[T]</code>:</p> <pre><code>type ContainerStates*[T] = Empty[T] | Full[T]\n</code></pre> <p>This union type is useful for procs that can accept any state.</p> <p>:param graph: The typestate graph to generate from :returns: AST for the union type definition</p> Parameters <ul> <li> <code>graph</code>               (<code>TypestateGraph</code>)                \u2013 The typestate graph to generate from             </li> </ul> Returns <p><code>NimNode</code> \u2013 AST for the union type definition</p> Source:              src/typestates/codegen.nim:84"},{"location":"api/#generateStateProcs","title":"generateStateProcs","text":"<pre><code>proc generateStateProcs(graph: TypestateGraph): NimNode</code></pre> <p>Generate <code>state()</code> procs for runtime state inspection.</p> <p>For each state, generates a proc that returns the enum value:</p> <pre><code>proc state*(f: Closed): FileState = fsClosed\nproc state*(f: Open): FileState = fsOpen\n</code></pre> <p>For generic types:</p> <pre><code>proc state*[T](f: Empty[T]): ContainerState = fsEmpty\nproc state*[T](f: Full[T]): ContainerState = fsFull\n</code></pre> <p>:param graph: The typestate graph to generate from :returns: AST for all state() proc definitions</p> Parameters <ul> <li> <code>graph</code>               (<code>TypestateGraph</code>)                \u2013 The typestate graph to generate from             </li> </ul> Returns <p><code>NimNode</code> \u2013 AST for all state() proc definitions</p> Source:              src/typestates/codegen.nim:137"},{"location":"api/#hasGenericStates","title":"hasGenericStates","text":"<pre><code>proc hasGenericStates(graph: TypestateGraph): bool</code></pre> <p>Check if any states use generic type parameters.</p> Parameters <ul> <li> <code>graph</code>               (<code>TypestateGraph</code>)                            </li> </ul> Returns <p><code>bool</code></p> Source:              src/typestates/codegen.nim:190"},{"location":"api/#getBranchingTransitions","title":"getBranchingTransitions","text":"<pre><code>proc getBranchingTransitions(graph: TypestateGraph): seq[Transition]</code></pre> <p>Get all transitions that have multiple destinations (branching).</p> <p>A branching transition is one where <code>toStates.len &gt; 1</code>, like: <code>Created -&gt; Approved | Declined</code></p> <p>:param graph: The typestate graph to query :returns: Sequence of branching transitions</p> Parameters <ul> <li> <code>graph</code>               (<code>TypestateGraph</code>)                \u2013 The typestate graph to query             </li> </ul> Returns <p><code>seq[Transition]</code> \u2013 Sequence of branching transitions</p> Source:              src/typestates/codegen.nim:197"},{"location":"api/#generateBranchTypes","title":"generateBranchTypes","text":"<pre><code>proc generateBranchTypes(graph: TypestateGraph): NimNode</code></pre> <p>Generate variant types for branching transitions.</p> <p>For a transition like <code>Created -&gt; Approved | Declined as ProcessResult</code>, generates:</p> <pre><code>type\n  ProcessResultKind* = enum pApproved, pDeclined\n  ProcessResult* = object\n    case kind*: ProcessResultKind\n    of pApproved: approved*: Approved\n    of pDeclined: declined*: Declined\n</code></pre> <p>For generic types like <code>Empty[T] -&gt; Full[T] | Error[T] as FillResult[T]</code>:</p> <pre><code>type\n  FillResultKind* = enum fFull, fError\n  FillResult*[T] = object\n    case kind*: FillResultKind\n    of fFull: full*: Full[T]\n    of fError: error*: Error[T]\n</code></pre> <p>The type name comes from the <code>as TypeName</code> syntax in the DSL. Enum prefixes are derived from the first letter of the type name.</p> <p>:param graph: The typestate graph to generate from :returns: AST for all branch type definitions</p> Parameters <ul> <li> <code>graph</code>               (<code>TypestateGraph</code>)                \u2013 The typestate graph to generate from             </li> </ul> Returns <p><code>NimNode</code> \u2013 AST for all branch type definitions</p> Source:              src/typestates/codegen.nim:219"},{"location":"api/#generateBranchConstructors","title":"generateBranchConstructors","text":"<pre><code>proc generateBranchConstructors(graph: TypestateGraph): NimNode</code></pre> <p>Generate constructor procs for branch types.</p> <p>For <code>Created -&gt; Approved | Declined as ProcessResult</code>, generates:</p> <pre><code>proc toProcessResult*(s: Approved): ProcessResult =\n  ProcessResult(kind: pApproved, approved: s)\n\nproc toProcessResult*(s: Declined): ProcessResult =\n  ProcessResult(kind: pDeclined, declined: s)\n</code></pre> <p>For generic types:</p> <pre><code>proc toFillResult*[T](s: Full[T]): FillResult[T] =\n  FillResult[T](kind: fFull, full: s)\n</code></pre> <p>:param graph: The typestate graph to generate from :returns: AST for all constructor proc definitions</p> Parameters <ul> <li> <code>graph</code>               (<code>TypestateGraph</code>)                \u2013 The typestate graph to generate from             </li> </ul> Returns <p><code>NimNode</code> \u2013 AST for all constructor proc definitions</p> Source:              src/typestates/codegen.nim:325"},{"location":"api/#generateBranchOperators","title":"generateBranchOperators","text":"<pre><code>proc generateBranchOperators(graph: TypestateGraph): NimNode</code></pre> <p>Generate <code>-&gt;</code> operator templates for branch types.</p> <p>The <code>-&gt;</code> operator provides syntactic sugar for branch construction. It takes the branch type on the left and the state value on the right:</p> <pre><code># Usage (for: Created -&gt; Approved | Declined as ProcessResult):\nProcessResult -&gt; Approved(c.Payment)\n\n# Equivalent to:\ntoProcessResult(Approved(c.Payment))\n</code></pre> <p>For generic types:</p> <pre><code>FillResult[int] -&gt; Full[int](container)\n</code></pre> <p>Generated templates:</p> <pre><code>template `-&gt;`*(T: typedesc[ProcessResult], s: Approved): ProcessResult =\n  toProcessResult(s)\n\ntemplate `-&gt;`*[T](T: typedesc[FillResult[T]], s: Full[T]): FillResult[T] =\n  toFillResult(s)\n</code></pre> <p>The <code>typedesc</code> parameter disambiguates when the same state appears in multiple branch types.</p> <p>:param graph: The typestate graph to generate from :returns: AST for all operator template definitions</p> Parameters <ul> <li> <code>graph</code>               (<code>TypestateGraph</code>)                \u2013 The typestate graph to generate from             </li> </ul> Returns <p><code>NimNode</code> \u2013 AST for all operator template definitions</p> Source:              src/typestates/codegen.nim:399"},{"location":"api/#generateAll","title":"generateAll","text":"<pre><code>proc generateAll(graph: TypestateGraph): NimNode</code></pre> <p>Generate all helper types and procs for a typestate.</p> <p>This is the main entry point called by the <code>typestate</code> macro. It generates:</p> <ol> <li>State enum (<code>FileState</code>)</li> <li>Union type (<code>FileStates</code> or <code>ContainerStates[T]</code>)</li> <li>State procs (<code>state()</code> for each state)</li> <li>Branch types for branching transitions (user-named via <code>as TypeName</code>)</li> <li>Branch constructors (<code>toTypeName</code>)</li> <li>Branch operators (<code>-&gt;</code>)</li> </ol> <p>For generic typestates like <code>Container[T]</code>, all generated types and procs include proper type parameters.</p> <p>:param graph: The typestate graph to generate from :returns: AST containing all generated definitions</p> Parameters <ul> <li> <code>graph</code>               (<code>TypestateGraph</code>)                \u2013 The typestate graph to generate from             </li> </ul> Returns <p><code>NimNode</code> \u2013 AST containing all generated definitions</p> Source:              src/typestates/codegen.nim:489"},{"location":"api/#cli_1","title":"CLI","text":"<p>Command-line tool functionality.</p>"},{"location":"api/#cli","title":"cli","text":"<p>Command-line tool for typestates.</p> <p>Usage:</p> <pre><code>typestates verify [paths...]\ntypestates dot [paths...]\n</code></pre> <p>Parses source files using Nim's AST parser and verifies typestate rules or generates DOT output.</p> <p>Note: Files must be valid Nim syntax. Parse errors cause verification to fail loudly with a clear error message.</p>"},{"location":"api/#VerifyResult","title":"VerifyResult","text":"<pre><code>type VerifyResult</code></pre> Source:              src/typestates/cli.nim:23"},{"location":"api/#parseTypestates","title":"parseTypestates","text":"<pre><code>proc parseTypestates(paths: seq[string]): ParseResult</code></pre> <p>Parse all Nim files in the given paths for typestates.</p> <p>Uses Nim's AST parser for accurate extraction. Fails loudly on files with syntax errors.</p> <p>:param paths: List of file or directory paths to scan :returns: All parsed typestates and total file count :raises ParseError: on syntax errors</p> Parameters <ul> <li> <code>paths</code>               (<code>seq[string]</code>)                \u2013 List of file or directory paths to scan             </li> </ul> Returns <p><code>ParseResult</code> \u2013 All parsed typestates and total file count</p> Source:              src/typestates/cli.nim:35"},{"location":"api/#generateDot","title":"generateDot","text":"<pre><code>proc generateDot(ts: ParsedTypestate): string</code></pre> <p>Generate GraphViz DOT output for a typestate.</p> <p>Creates a directed graph representation suitable for rendering with <code>dot</code>, <code>neato</code>, or other GraphViz tools.</p> <p>Example output:</p> <pre><code>digraph File {\n  rankdir=LR;\n  node [shape=box];\n\n  Closed;\n  Open;\n\n  Closed -&gt; Open;\n  Open -&gt; Closed;\n}\n</code></pre> <p>:param ts: The parsed typestate to visualize :returns: DOT format string</p> Parameters <ul> <li> <code>ts</code>               (<code>ParsedTypestate</code>)                \u2013 The parsed typestate to visualize             </li> </ul> Returns <p><code>string</code> \u2013 DOT format string</p> Source:              src/typestates/cli.nim:46"},{"location":"api/#generateUnifiedDot","title":"generateUnifiedDot","text":"<pre><code>proc generateUnifiedDot(typestates: seq[ParsedTypestate]): string</code></pre> <p>Generate a unified GraphViz DOT output showing all typestates.</p> <p>Creates subgraphs for each typestate with cross-cluster edges for bridges.</p> <p>Example output:</p> <pre><code>digraph {\n  rankdir=LR;\n  node [shape=box];\n\n  subgraph cluster_AuthFlow {\n    label=\"AuthFlow\";\n    Authenticated;\n    Failed;\n    Authenticated -&gt; Failed;\n  }\n\n  subgraph cluster_Session {\n    label=\"Session\";\n    Active;\n    Closed;\n    Active -&gt; Closed;\n  }\n\n  // Bridges (cross-cluster edges)\n  Authenticated -&gt; Active [style=dashed, label=\"bridge\"];\n  Failed -&gt; Closed [style=dashed, label=\"bridge\"];\n}\n</code></pre> <p>:param typestates: List of parsed typestates to visualize :returns: DOT format string</p> Parameters <ul> <li> <code>typestates</code>               (<code>seq[ParsedTypestate]</code>)                \u2013 List of parsed typestates to visualize             </li> </ul> Returns <p><code>string</code> \u2013 DOT format string</p> Source:              src/typestates/cli.nim:95"},{"location":"api/#generateSeparateDot","title":"generateSeparateDot","text":"<pre><code>proc generateSeparateDot(ts: ParsedTypestate): string</code></pre> <p>Generate GraphViz DOT output for a single typestate.</p> <p>Bridges are shown as terminal nodes with dashed edges.</p> <p>Example output:</p> <pre><code>digraph AuthFlow {\n  rankdir=LR;\n  node [shape=box];\n\n  Authenticated;\n  Failed;\n\n  Authenticated -&gt; Failed;\n  Authenticated -&gt; \"Session.Active\" [style=dashed];\n  Failed -&gt; \"Session.Closed\" [style=dashed];\n}\n</code></pre> <p>:param ts: The parsed typestate to visualize :returns: DOT format string</p> Parameters <ul> <li> <code>ts</code>               (<code>ParsedTypestate</code>)                \u2013 The parsed typestate to visualize             </li> </ul> Returns <p><code>string</code> \u2013 DOT format string</p> Source:              src/typestates/cli.nim:185"},{"location":"api/#verify","title":"verify","text":"<pre><code>proc verify(paths: seq[string]): VerifyResult</code></pre> <p>Verify all Nim files in the given paths.</p> <p>Uses Nim's AST parser to extract typestates, then checks that all procs operating on state types are properly marked with <code>{.transition.}</code> or <code>{.notATransition.}</code>.</p> <p>Note: Files with syntax errors cause verification to fail immediately with a clear error message.</p> <p>:param paths: List of file or directory paths to verify :returns: Verification results with errors, warnings, and counts :raises ParseError: on syntax errors</p> Parameters <ul> <li> <code>paths</code>               (<code>seq[string]</code>)                \u2013 List of file or directory paths to verify             </li> </ul> Returns <p><code>VerifyResult</code> \u2013 Verification results with errors, warnings, and counts</p> Source:              src/typestates/cli.nim:286"},{"location":"guide/bridges/","title":"Cross-Type Bridges","text":""},{"location":"guide/bridges/#cross-type-state-bridges","title":"Cross-Type State Bridges","text":"<p>Bridges allow terminal states of one typestate to transition into states of a completely different typestate. This enables modeling resource transformation, wrapping, and protocol handoff.</p>"},{"location":"guide/bridges/#declaration","title":"Declaration","text":"<p>Declare bridges in the source typestate using a <code>bridges:</code> block with dotted notation:</p> <pre><code>import session\n\ntypestate AuthFlow:\n  states Pending, Authenticated, Failed\n  transitions:\n    Pending -&gt; Authenticated\n    Pending -&gt; Failed\n  bridges:\n    Authenticated -&gt; Session.Active\n    Failed -&gt; ErrorLog.Entry\n</code></pre> <p>The destination typestate must be imported and exist.</p>"},{"location":"guide/bridges/#implementation","title":"Implementation","text":""},{"location":"guide/bridges/#using-procs","title":"Using Procs","text":"<p>Use procs when you need extra arguments:</p> <pre><code>proc startSession(auth: Authenticated, config: SessionConfig): Active {.transition.} =\n  result = Active(Session(\n    userId: auth.AuthFlow.userId,\n    timeout: config.timeout\n  ))\n</code></pre>"},{"location":"guide/bridges/#using-converters","title":"Using Converters","text":"<p>Use converters for simple 1:1 transforms:</p> <pre><code>converter toSession(auth: Authenticated): Active {.transition.} =\n  Active(Session(userId: auth.AuthFlow.userId))\n\n# Usage - implicit conversion works\nlet session: Active = myAuth\n</code></pre>"},{"location":"guide/bridges/#branching","title":"Branching","text":"<p>Bridges support branching like regular transitions:</p> <pre><code>bridges:\n  Authenticated -&gt; Session.Active | Session.Guest\n</code></pre>"},{"location":"guide/bridges/#wildcard-bridges","title":"Wildcard Bridges","text":"<p>Use <code>*</code> to allow any state to bridge to a destination:</p> <pre><code>bridges:\n  * -&gt; Shutdown.Terminal\n</code></pre>"},{"location":"guide/bridges/#validation","title":"Validation","text":"<p>The compiler validates:</p> <ol> <li>Bridge is declared in source typestate's <code>bridges:</code> block</li> <li>Proc/converter signature matches declaration</li> <li>Destination typestate exists</li> <li>Destination state exists in that typestate</li> <li>Destination module is imported</li> </ol>"},{"location":"guide/bridges/#error-messages","title":"Error Messages","text":""},{"location":"guide/bridges/#bridge-not-declared","title":"Bridge Not Declared","text":"<pre><code>Error: Undeclared bridge: Authenticated -&gt; Session.Active\n  Typestate 'AuthFlow' does not declare this bridge.\n  Valid bridges from 'Authenticated': @[]\n  Hint: Add 'bridges: Authenticated -&gt; Session.Active' to AuthFlow.\n</code></pre>"},{"location":"guide/bridges/#unknown-typestate","title":"Unknown Typestate","text":"<p>If you reference a typestate that doesn't exist, you'll get an error indicating that the destination type isn't part of any registered typestate.</p>"},{"location":"guide/bridges/#unknown-state","title":"Unknown State","text":"<p>If you reference a state that doesn't exist in the destination typestate, you'll get an error indicating which states are valid.</p>"},{"location":"guide/bridges/#complete-example","title":"Complete Example","text":"<pre><code># session.nim\nimport typestates\n\ntype\n  Session = object\n    userId: string\n  Active = distinct Session\n  Expired = distinct Session\n\ntypestate Session:\n  states Active, Expired\n  transitions:\n    Active -&gt; Expired\n\n# auth.nim\nimport typestates\nimport ./session\n\ntype\n  AuthFlow = object\n    userId: string\n  Pending = distinct AuthFlow\n  Authenticated = distinct AuthFlow\n\ntypestate AuthFlow:\n  states Pending, Authenticated\n  transitions:\n    Pending -&gt; Authenticated\n  bridges:\n    Authenticated -&gt; Session.Active\n\nconverter toSession(a: Authenticated): Active {.transition.} =\n  Active(Session(userId: a.AuthFlow.userId))\n</code></pre>"},{"location":"guide/bridges/#visualization","title":"Visualization","text":""},{"location":"guide/bridges/#unified-graph-default","title":"Unified Graph (default)","text":"<pre><code>typestates dot src/\n</code></pre> <p>Shows all typestates with cross-cluster dashed edges for bridges.</p>"},{"location":"guide/bridges/#separate-graphs","title":"Separate Graphs","text":"<pre><code>typestates dot --separate src/\n</code></pre> <p>Shows individual graphs per typestate with bridges as terminal nodes.</p>"},{"location":"guide/cli/","title":"CLI Reference","text":""},{"location":"guide/cli/#command-line-interface","title":"Command Line Interface","text":"<p>The <code>typestates</code> command-line tool provides project-wide verification and visualization capabilities.</p>"},{"location":"guide/cli/#installation","title":"Installation","text":"<p>The CLI is installed automatically with the library:</p> <pre><code>nimble install typestates\n</code></pre>"},{"location":"guide/cli/#usage","title":"Usage","text":"<pre><code>typestates &lt;command&gt; [paths...]\n\nCommands:\n  verify    Check that procs on state types are properly marked\n  dot       Generate GraphViz DOT output for visualization\n\nOptions:\n  -h, --help      Show help\n  -v, --version   Show version\n</code></pre>"},{"location":"guide/cli/#verify-command","title":"Verify Command","text":"<p>The <code>verify</code> command checks that all procs operating on state types are properly marked with <code>{.transition.}</code> or <code>{.notATransition.}</code>.</p>"},{"location":"guide/cli/#basic-usage","title":"Basic Usage","text":"<pre><code>typestates verify src/\ntypestates verify src/ tests/\ntypestates verify .\n</code></pre>"},{"location":"guide/cli/#example","title":"Example","text":"<p>Given this file <code>src/file_state.nim</code>:</p> <pre><code>import typestates\n\ntype\n  File = object\n    path: string\n  Closed = distinct File\n  Open = distinct File\n\ntypestate File:\n  states Closed, Open\n  transitions:\n    Closed -&gt; Open\n    Open -&gt; Closed\n\nproc open(f: Closed): Open {.transition.} =\n  result = Open(f)\n\nproc close(f: Open): Closed {.transition.} =\n  result = Closed(f)\n</code></pre> <p>Running verification:</p> <pre><code>$ typestates verify src/\nChecked 1 files, 2 transitions\n\nAll checks passed!\n</code></pre>"},{"location":"guide/cli/#error-output","title":"Error Output","text":"<p>If a proc is missing the required pragma:</p> <pre><code># Missing {.transition.} pragma!\nproc open(f: Closed): Open =\n  result = Open(f)\n</code></pre> <pre><code>$ typestates verify src/\nChecked 1 files, 1 transitions\nERROR: src/file_state.nim:15 - Unmarked proc on state 'Closed' (strictTransitions enabled)\n\n1 error(s) found\n</code></pre>"},{"location":"guide/cli/#syntax-error-handling","title":"Syntax Error Handling","text":"<p>The CLI uses Nim's AST parser for accurate extraction. Files must be valid Nim syntax:</p> <pre><code>$ typestates verify src/\nERROR: Parse error in src/broken.nim: invalid indentation\n</code></pre> <p>This is intentional - a verification tool should not silently skip files it cannot parse.</p>"},{"location":"guide/cli/#dot-command","title":"Dot Command","text":"<p>The <code>dot</code> command generates GraphViz DOT output for visualizing state machines.</p> <p>See Visualization for detailed usage and examples.</p>"},{"location":"guide/cli/#basic-usage_1","title":"Basic Usage","text":"<pre><code>typestates dot src/\ntypestates dot src/ &gt; states.dot\ntypestates dot src/ | dot -Tpng -o states.png\n</code></pre>"},{"location":"guide/cli/#ci-integration","title":"CI Integration","text":""},{"location":"guide/cli/#github-actions","title":"GitHub Actions","text":"<pre><code>- name: Install typestates\n  run: nimble install typestates -y\n\n- name: Verify typestates\n  run: typestates verify src/\n</code></pre>"},{"location":"guide/cli/#circleci","title":"CircleCI","text":"<pre><code>- run:\n    name: Verify typestates\n    command: |\n      nimble install typestates -y\n      typestates verify src/\n</code></pre>"},{"location":"guide/cli/#nimble-task","title":"Nimble Task","text":"<p>Add a verification task to your <code>.nimble</code> file:</p> <pre><code>task verify, \"Verify typestate rules\":\n  exec \"typestates verify src/\"\n</code></pre> <p>Then run:</p> <pre><code>nimble verify\n</code></pre>"},{"location":"guide/dsl-reference/","title":"DSL Reference","text":""},{"location":"guide/dsl-reference/#dsl-reference","title":"DSL Reference","text":"<p>Complete reference for the nim-typestates DSL syntax.</p>"},{"location":"guide/dsl-reference/#typestate-block","title":"Typestate Block","text":"<pre><code>typestate TypeName:\n  states State1, State2, State3\n  transitions:\n    State1 -&gt; State2\n    State2 -&gt; State3\n</code></pre>"},{"location":"guide/dsl-reference/#states-declaration","title":"States Declaration","text":"<p>List all state types that participate in this typestate:</p> <pre><code>states Closed, Open, Reading, Writing, Errored\n</code></pre> <p>Each state must be a <code>distinct</code> type of the base type:</p> <pre><code>type\n  File = object\n    # ...\n  Closed = distinct File\n  Open = distinct File\n</code></pre>"},{"location":"guide/dsl-reference/#transitions-block","title":"Transitions Block","text":"<p>Declare valid state transitions using <code>-&gt;</code> syntax:</p> <pre><code>transitions:\n  Closed -&gt; Open\n  Open -&gt; Closed\n</code></pre>"},{"location":"guide/dsl-reference/#transition-syntax","title":"Transition Syntax","text":""},{"location":"guide/dsl-reference/#simple-transitions","title":"Simple Transitions","text":"<p>One source state to one destination:</p> <pre><code>Closed -&gt; Open\n</code></pre>"},{"location":"guide/dsl-reference/#branching-transitions","title":"Branching Transitions","text":"<p>One source state to multiple possible destinations using <code>|</code>, with a required result type name:</p> <pre><code>Closed -&gt; Open | Errored as OpenResult\n</code></pre> <p>The <code>as TypeName</code> syntax names the generated branch type. This is required for all branching transitions.</p> <p>This means a proc taking <code>Closed</code> can return either <code>Open</code> or <code>Errored</code>, wrapped in an <code>OpenResult</code> variant type.</p>"},{"location":"guide/dsl-reference/#wildcard-transitions","title":"Wildcard Transitions","text":"<p>Any state can transition to a destination using <code>*</code>:</p> <pre><code>* -&gt; Closed\n</code></pre> <p>Wildcards are useful for \"reset\" or \"cleanup\" operations that work from any state.</p>"},{"location":"guide/dsl-reference/#bridges","title":"Bridges","text":"<p>Cross-typestate transitions declared with dotted notation.</p>"},{"location":"guide/dsl-reference/#syntax","title":"Syntax","text":"<pre><code>bridges:\n  SourceState -&gt; DestTypestate.DestState\n  SourceState -&gt; DestTypestate.State1 | DestTypestate.State2  # Branching\n  * -&gt; DestTypestate.DestState  # Wildcard\n</code></pre>"},{"location":"guide/dsl-reference/#requirements","title":"Requirements","text":"<ul> <li>Destination typestate must be imported</li> <li>Destination typestate and state must exist</li> <li>Bridge must be declared before implementation</li> </ul>"},{"location":"guide/dsl-reference/#examples","title":"Examples","text":"<p>Simple bridge:</p> <pre><code>bridges:\n  Authenticated -&gt; Session.Active\n</code></pre> <p>Branching bridge:</p> <pre><code>bridges:\n  Authenticated -&gt; Session.Active | Session.Guest\n</code></pre> <p>Wildcard bridge:</p> <pre><code>bridges:\n  * -&gt; Shutdown.Terminal\n</code></pre> <p>See Bridges for full documentation.</p>"},{"location":"guide/dsl-reference/#pragmas","title":"Pragmas","text":""},{"location":"guide/dsl-reference/#transition","title":"<code>{.transition.}</code>","text":"<p>Mark a proc as a state transition. The compiler validates that the transition is declared.</p> <pre><code>proc open(f: Closed): Open {.transition.} =\n  result = Open(f)\n</code></pre> <p>Validation rules:</p> <ul> <li>First parameter must be a registered state type</li> <li>Return type must be a valid transition target</li> <li>Transition must be declared in the typestate block</li> <li>Must have <code>{.raises: [].}</code> - errors should be states, not exceptions</li> </ul> <p>See Error Handling for patterns on modeling errors as states.</p> <p>Error on invalid transition:</p> <pre><code>Error: Undeclared transition: Open -&gt; Locked\n  Typestate 'File' does not declare this transition.\n  Valid transitions from 'Open': @[\"Closed\"]\n  Hint: Add 'Open -&gt; Locked' to the transitions block.\n</code></pre>"},{"location":"guide/dsl-reference/#notatransition","title":"<code>{.notATransition.}</code>","text":"<p>Mark a proc as intentionally NOT a transition. Use for procs that operate on state types but don't change state:</p> <pre><code>proc write(f: Open, data: string) {.notATransition.} =\n  # Writes data but stays in Open state\n  rawWrite(f.File.handle, data)\n\nproc read(f: Open, count: int): string {.notATransition.} =\n  # Reads data but stays in Open state\n  result = rawRead(f.File.handle, count)\n</code></pre> <p>For pure functions (no side effects), use <code>func</code> instead - no pragma needed:</p> <pre><code>func path(f: Open): string =\n  f.File.path\n</code></pre>"},{"location":"guide/dsl-reference/#generated-types","title":"Generated Types","text":"<p>For <code>typestate File:</code> with states <code>Closed</code>, <code>Open</code>, <code>Errored</code>:</p>"},{"location":"guide/dsl-reference/#state-enum","title":"State Enum","text":"<pre><code>type FileState* = enum\n  fsClosed, fsOpen, fsErrored\n</code></pre> <p>Enum values are prefixed with <code>fs</code> (for \"file state\") to avoid name collisions.</p>"},{"location":"guide/dsl-reference/#union-type","title":"Union Type","text":"<pre><code>type FileStates* = Closed | Open | Errored\n</code></pre> <p>Useful for generic procs that accept any state:</p> <pre><code>proc describe[S: FileStates](f: S): string =\n  case f.state\n  of fsClosed: \"closed\"\n  of fsOpen: \"open\"\n  of fsErrored: \"errored\"\n</code></pre>"},{"location":"guide/dsl-reference/#state-procs","title":"State Procs","text":"<pre><code>proc state*(f: Closed): FileState = fsClosed\nproc state*(f: Open): FileState = fsOpen\nproc state*(f: Errored): FileState = fsErrored\n</code></pre>"},{"location":"guide/dsl-reference/#branch-types","title":"Branch Types","text":"<p>For branching transitions like <code>Created -&gt; Approved | Declined | Review as ProcessResult</code>, the macro generates types and helpers for returning multiple possible states.</p> <p>Usage with the <code>-&gt;</code> operator:</p> <pre><code>proc process(c: Created): ProcessResult {.transition.} =\n  if c.Payment.amount &gt; 100:\n    ProcessResult -&gt; Approved(c.Payment)\n  elif c.Payment.amount &gt; 50:\n    ProcessResult -&gt; Review(c.Payment)\n  else:\n    ProcessResult -&gt; Declined(c.Payment)\n</code></pre> <p>The <code>-&gt;</code> operator takes the branch type on the left and the destination state on the right. This mirrors the DSL syntax and is unambiguous even when the same state appears in multiple branch types.</p> <p>Pattern matching on the result:</p> <pre><code>let result = process(created)\ncase result.kind\nof pApproved: echo \"Approved: \", result.approved.Payment.amount\nof pDeclined: echo \"Declined\"\nof pReview: echo \"Needs review\"\n</code></pre> <p>What gets generated:</p> <p>The <code>-&gt;</code> operator is syntactic sugar around constructor procs. For each branching transition with <code>as TypeName</code>, the macro generates:</p> <ol> <li> <p>Enum - <code>ProcessResultKind = enum pApproved, pDeclined, pReview</code>    (prefix is first letter of type name, e.g., <code>p</code> for ProcessResult)</p> </li> <li> <p>Variant object - <code>ProcessResult</code> holding the result</p> </li> <li> <p>Constructor procs - <code>toProcessResult(s: Approved): ProcessResult</code> etc.</p> </li> <li> <p><code>-&gt;</code> operator - <code>template -&gt;(T: typedesc[ProcessResult], s: Approved)</code> etc.</p> </li> </ol> <p>You can use the constructors directly if preferred:</p> <pre><code>toProcessResult(Approved(c.Payment))  # Equivalent to: ProcessResult -&gt; Approved(c.Payment)\n</code></pre> <p>See Returning Union Types for more examples.</p>"},{"location":"guide/dsl-reference/#complete-example","title":"Complete Example","text":"<pre><code>import typestates\n\ntype\n  Connection = object\n    host: string\n    port: int\n    socket: int\n\n  Disconnected = distinct Connection\n  Connecting = distinct Connection\n  Connected = distinct Connection\n  Errored = distinct Connection\n\ntypestate Connection:\n  states Disconnected, Connecting, Connected, Errored\n  transitions:\n    Disconnected -&gt; Connecting\n    Connecting -&gt; Connected | Errored as ConnectResult\n    Connected -&gt; Disconnected\n    Errored -&gt; Disconnected\n    * -&gt; Disconnected  # Can always disconnect\n\nproc connect(c: Disconnected, host: string, port: int): Connecting {.transition.} =\n  var conn = c.Connection\n  conn.host = host\n  conn.port = port\n  result = Connecting(conn)\n\nproc waitForConnection(c: Connecting): ConnectResult {.transition.} =\n  # In real code, this would do async I/O\n  if true:  # Pretend success\n    ConnectResult -&gt; Connected(c.Connection)\n  else:\n    ConnectResult -&gt; Errored(c.Connection)\n\nproc disconnect[S: ConnectionStates](c: S): Disconnected {.transition.} =\n  var conn = c.Connection\n  conn.socket = 0\n  result = Disconnected(conn)\n\nproc send(c: Connected, data: string) {.notATransition.} =\n  # Send data, stay connected\n  discard\n</code></pre>"},{"location":"guide/dsl-reference/#tips","title":"Tips","text":""},{"location":"guide/dsl-reference/#accessing-the-base-type","title":"Accessing the Base Type","text":"<p>State types are <code>distinct</code>, so you need to convert to access fields:</p> <pre><code>proc path(f: Open): string =\n  f.File.path  # Convert Open to File to access .path\n</code></pre>"},{"location":"guide/dsl-reference/#returning-union-types","title":"Returning Union Types","text":"<p>For branching transitions, use the <code>-&gt;</code> operator with the generated branch type:</p> <pre><code># Branching transition: Connecting -&gt; Connected | Errored as ConnectResult\nproc waitForConnection(c: Connecting): ConnectResult {.transition.} =\n  if success:\n    ConnectResult -&gt; Connected(c.Connection)\n  else:\n    ConnectResult -&gt; Errored(c.Connection)\n</code></pre> <p>Then pattern match on the result:</p> <pre><code>let result = conn.waitForConnection()\ncase result.kind\nof cConnected:\n  echo \"Connected!\"\n  sendData(result.connected)\nof cErrored:\n  echo \"Error: \", result.errored.message\n</code></pre> <p>Why branch types? Nim's <code>A | B</code> syntax creates a generic type constraint, not a runtime sum type. You cannot actually return different types from if/else branches. The generated branch types solve this by wrapping the result in an object variant.</p>"},{"location":"guide/dsl-reference/#generic-over-all-states","title":"Generic Over All States","text":"<p>Use the generated union type for generic procs:</p> <pre><code>proc forceClose[S: FileStates](f: S): Closed =\n  Closed(f.File)\n</code></pre>"},{"location":"guide/error-handling/","title":"Error Handling","text":""},{"location":"guide/error-handling/#error-handling","title":"Error Handling","text":"<p>Typestates model errors as states, not exceptions. If an operation can fail, the failure is a state the object transitions to.</p>"},{"location":"guide/error-handling/#the-rule","title":"The Rule","text":"<p>All <code>{.transition.}</code> procs must have <code>{.raises: [].}</code> - either explicitly declared or inferred. The library enforces this at compile time.</p>"},{"location":"guide/error-handling/#why","title":"Why?","text":"<p>Exceptions bypass the state machine. If a transition raises an exception, the caller never receives the promised state. The object's logical state becomes undefined.</p> <p>Error states are explicit and trackable. The type system knows about them, and callers must handle them.</p>"},{"location":"guide/error-handling/#example","title":"Example","text":"<pre><code># Wrong: exception bypasses state machine\nproc open(f: Closed, path: string): Open {.transition.} =\n  if not fileExists(path):\n    raise newException(IOError, \"not found\")  # Compile error!\n  ...\n\n# Right: error is a state, use branch type\n# (assumes: Closed -&gt; Open | OpenFailed as OpenResult)\nproc open(f: Closed, path: string): OpenResult {.transition.} =\n  if not fileExists(path):\n    return OpenResult -&gt; OpenFailed(f.File)\n  OpenResult -&gt; Open(f.File)\n</code></pre>"},{"location":"guide/error-handling/#defects-vs-exceptions","title":"Defects vs Exceptions","text":"<p>Nim distinguishes between Defects (bugs) and CatchableErrors (recoverable errors).</p>"},{"location":"guide/error-handling/#defects","title":"Defects","text":"<p>Programming errors that should not be caught:</p> <ul> <li><code>IndexDefect</code> - array/seq index out of bounds</li> <li><code>DivByZeroDefect</code> - division by zero</li> <li><code>AssertionDefect</code> - failed assertion</li> </ul> <p>Defects are NOT tracked by the <code>{.raises.}</code> pragma. A proc can have <code>{.raises: [].}</code> but still trigger a Defect if there's a bug.</p>"},{"location":"guide/error-handling/#catchableerrors","title":"CatchableErrors","text":"<p>Recoverable errors that callers can handle:</p> <ul> <li><code>IOError</code> - file/network operations</li> <li><code>ValueError</code> - parsing, conversion</li> <li><code>OSError</code> - system calls</li> </ul> <p>These ARE tracked by <code>{.raises.}</code>. Our enforcement prevents transitions from raising them.</p>"},{"location":"guide/error-handling/#what-typestates-guarantee","title":"What Typestates Guarantee","text":"<p>The library guarantees protocol correctness - you cannot call operations in the wrong state. It does NOT guarantee implementation correctness - your transition body might still have bugs that trigger Defects.</p> <p>Recommendation: Avoid Defect-prone operations in transitions, or guard them:</p> <pre><code># Risky: seq[i] can raise IndexDefect\nproc getItem(c: HasItems): Item {.transition, raises: [].} =\n  result = c.items[0]  # Bug if items is empty!\n\n# Safer: check first, return error state\n# (assumes: HasItems -&gt; Item | Empty as GetItemResult)\nproc getItem(c: HasItems): GetItemResult {.transition, raises: [].} =\n  if c.items.len == 0:\n    return GetItemResult -&gt; Empty(c.Container)\n  GetItemResult -&gt; Item(c.items[0])\n</code></pre>"},{"location":"guide/error-handling/#patterns","title":"Patterns","text":""},{"location":"guide/error-handling/#branching-transitions","title":"Branching Transitions","text":"<p>For transitions that can result in multiple states (success or failure), use the <code>as TypeName</code> syntax to name the branch type. Given:</p> <pre><code>typestate Connection:\n  states Disconnected, Connected, ConnectionFailed\n  transitions:\n    Disconnected -&gt; Connected | ConnectionFailed as ConnectResult\n    Connected -&gt; Disconnected\n    ConnectionFailed -&gt; Disconnected\n</code></pre> <p>The macro generates branch types and the <code>-&gt;</code> operator for constructing results.</p> <p>Use the <code>-&gt;</code> operator in your transition:</p> <pre><code>proc connect(c: Disconnected, host: string): ConnectResult {.transition, raises: [].} =\n  try:\n    let socket = connectSocket(host)\n    var conn = Connected(c.Connection)\n    conn.Connection.socket = socket\n    ConnectResult -&gt; conn\n  except OSError:\n    ConnectResult -&gt; ConnectionFailed(c.Connection)\n</code></pre> <p>The <code>-&gt;</code> operator takes the branch type on the left and the destination state on the right.</p> <p>Then pattern match on the result:</p> <pre><code>let result = connect(disconnected, \"localhost\")\ncase result.kind\nof cConnected:\n  echo \"Connected!\"\n  use(result.connected)\nof cConnectionFailed:\n  echo \"Failed to connect\"\n  retry(result.connectionfailed)\n</code></pre>"},{"location":"guide/error-handling/#wrap-external-calls","title":"Wrap External Calls","text":"<p>Create <code>{.raises: [].}</code> wrappers for exception-throwing APIs:</p> <pre><code>proc tryReadFile(path: string): Option[string] {.raises: [].} =\n  try:\n    result = some(readFile(path))\n  except IOError:\n    result = none(string)\n\n# (assumes: Empty -&gt; Loaded | LoadFailed as LoadResult)\nproc load(f: Empty, path: string): LoadResult {.transition, raises: [].} =\n  let content = tryReadFile(path)\n  if content.isNone:\n    return LoadResult -&gt; LoadFailed(f.Document)\n  var loaded = Loaded(f.Document)\n  loaded.Document.content = content.get\n  LoadResult -&gt; loaded\n</code></pre>"},{"location":"guide/error-handling/#result-types","title":"Result Types","text":"<p>Use Result[T, E] for structured error handling:</p> <pre><code># (assumes: Empty -&gt; Loaded | LoadFailed as LoadResult)\nproc load(f: Empty, path: string): LoadResult {.transition, raises: [].} =\n  let content = readFileResult(path)  # returns Result[string, IOError]\n  if content.isErr:\n    return LoadResult -&gt; LoadFailed(f.Document)\n  var loaded = Loaded(f.Document)\n  loaded.Document.content = content.get\n  LoadResult -&gt; loaded\n</code></pre>"},{"location":"guide/examples/","title":"Examples","text":""},{"location":"guide/examples/#examples","title":"Examples","text":"<p>Real-world patterns where typestates prevent expensive bugs.</p> <p>Running the Examples</p> <p>All examples in this guide are available as complete, runnable files in the <code>examples/</code> directory.</p>"},{"location":"guide/examples/#payment-processing","title":"Payment Processing","text":"<p>Payment processing requires strict ordering: authorize before capture, capture before refund. Typestates prevent costly mistakes like double-capture or refunds before capture.</p> <pre><code>import typestates\n\ntype\n  Payment = object\n    id: string\n    amount: int           # cents, to avoid float issues\n    authCode: string\n    refundedAmount: int\n\n  Created = distinct Payment\n  Authorized = distinct Payment\n  Captured = distinct Payment\n  PartiallyRefunded = distinct Payment\n  FullyRefunded = distinct Payment\n  Settled = distinct Payment\n\ntypestate Payment:\n  states Created, Authorized, Captured, PartiallyRefunded, FullyRefunded, Settled\n  transitions:\n    Created -&gt; Authorized\n    Authorized -&gt; Captured\n    Captured -&gt; PartiallyRefunded | FullyRefunded | Settled\n    PartiallyRefunded -&gt; PartiallyRefunded | FullyRefunded | Settled\n    FullyRefunded -&gt; Settled\n\nproc authorize(p: Created, cardToken: string): Authorized {.transition.} =\n  var payment = p.Payment\n  payment.authCode = \"AUTH_\" &amp; payment.id\n  echo \"Authorized $\", payment.amount\n  result = Authorized(payment)\n\nproc capture(p: Authorized): Captured {.transition.} =\n  echo \"Captured $\", p.Payment.amount\n  result = Captured(p.Payment)\n\nproc partialRefund(p: Captured, amount: int): PartiallyRefunded {.transition.} =\n  var payment = p.Payment\n  payment.refundedAmount = amount\n  echo \"Refunded $\", amount\n  result = PartiallyRefunded(payment)\n\nproc settle(p: Captured): Settled {.transition.} =\n  echo \"Settled $\", p.Payment.amount\n  result = Settled(p.Payment)\n\n# Usage\nvar payment = Created(Payment(id: \"pay_123\", amount: 9999))\nlet authed = payment.authorize(\"card_tok_visa\")\nlet captured = authed.capture()\nlet settled = captured.settle()\n\n# COMPILE ERRORS - The bugs we prevent:\n# payment.capture()        # Can't capture without auth\n# captured.capture()       # Can't capture twice\n# authed.partialRefund(50) # Can't refund before capture\n</code></pre> <p>Bugs prevented:</p> <ul> <li>Capturing before authorization</li> <li>Double-capture</li> <li>Refunding before capture</li> <li>Operations on settled payments</li> </ul>"},{"location":"guide/examples/#database-connection-pool","title":"Database Connection Pool","text":"<p>Connection pools have invariants that are easy to violate: don't query pooled connections, don't return connections mid-transaction, don't commit without a transaction.</p> <pre><code>import typestates\n\ntype\n  DbConnection = object\n    id: int\n    inTransaction: bool\n\n  Pooled = distinct DbConnection\n  CheckedOut = distinct DbConnection\n  InTransaction = distinct DbConnection\n  Closed = distinct DbConnection\n\ntypestate DbConnection:\n  states Pooled, CheckedOut, InTransaction, Closed\n  transitions:\n    Pooled -&gt; CheckedOut | Closed as PoolResult\n    CheckedOut -&gt; Pooled | InTransaction | Closed as UseResult\n    InTransaction -&gt; CheckedOut\n    * -&gt; Closed\n\nproc checkout(conn: Pooled): CheckedOut {.transition.} =\n  echo \"Checked out connection #\", conn.DbConnection.id\n  result = CheckedOut(conn.DbConnection)\n\nproc release(conn: CheckedOut): Pooled {.transition.} =\n  echo \"Released connection #\", conn.DbConnection.id\n  result = Pooled(conn.DbConnection)\n\nproc beginTransaction(conn: CheckedOut): InTransaction {.transition.} =\n  echo \"BEGIN TRANSACTION\"\n  result = InTransaction(conn.DbConnection)\n\nproc commit(conn: InTransaction): CheckedOut {.transition.} =\n  echo \"COMMIT\"\n  result = CheckedOut(conn.DbConnection)\n\nproc execute(conn: CheckedOut, sql: string): CheckedOut {.notATransition.} =\n  echo \"Execute: \", sql\n  result = conn\n\nproc execute(conn: InTransaction, sql: string): InTransaction {.notATransition.} =\n  echo \"Execute (in tx): \", sql\n  result = conn\n\n# Usage\nvar pooledConn = Pooled(DbConnection(id: 42))\nlet conn = pooledConn.checkout()\nlet tx = conn.beginTransaction()\nlet tx2 = tx.execute(\"INSERT INTO users VALUES (1, 'alice')\")\nlet afterTx = tx2.commit()\nlet returned = afterTx.release()\n\n# COMPILE ERRORS:\n# returned.execute(\"SELECT 1\")  # Can't query pooled connection\n# tx.release()                  # Can't release during transaction\n# conn.commit()                 # Can't commit without transaction\n</code></pre> <p>Bugs prevented:</p> <ul> <li>Query on pooled (not checked out) connection</li> <li>Returning connection while in transaction</li> <li>Committing without starting transaction</li> <li>Nested transactions</li> </ul>"},{"location":"guide/examples/#http-request-lifecycle","title":"HTTP Request Lifecycle","text":"<p>HTTP requests follow a strict sequence: set headers, send headers, send body, await response. Typestates enforce this ordering at compile time.</p> <pre><code>import typestates\n\ntype\n  HttpRequest = object\n    path: string\n    headers: seq[(string, string)]\n    body: string\n    responseCode: int\n\n  Building = distinct HttpRequest\n  HeadersSent = distinct HttpRequest\n  RequestSent = distinct HttpRequest\n  ResponseReceived = distinct HttpRequest\n\ntypestate HttpRequest:\n  states Building, HeadersSent, RequestSent, ResponseReceived\n  transitions:\n    Building -&gt; HeadersSent\n    HeadersSent -&gt; RequestSent\n    RequestSent -&gt; ResponseReceived\n    ResponseReceived -&gt; Building  # Keep-alive\n\nproc header(req: Building, key, value: string): Building {.notATransition.} =\n  var r = req.HttpRequest\n  r.headers.add((key, value))\n  result = Building(r)\n\nproc sendHeaders(req: Building): HeadersSent {.transition.} =\n  echo \"&gt;&gt;&gt; Sending headers\"\n  result = HeadersSent(req.HttpRequest)\n\nproc sendBody(req: HeadersSent, body: string): RequestSent {.transition.} =\n  echo \"&gt;&gt;&gt; Sending body (\", body.len, \" bytes)\"\n  result = RequestSent(req.HttpRequest)\n\nproc finish(req: HeadersSent): RequestSent {.transition.} =\n  echo \"&gt;&gt;&gt; Request complete (no body)\"\n  result = RequestSent(req.HttpRequest)\n\nproc awaitResponse(req: RequestSent): ResponseReceived {.transition.} =\n  var r = req.HttpRequest\n  r.responseCode = 200\n  echo \"&lt;&lt;&lt; Response: \", r.responseCode\n  result = ResponseReceived(r)\n\nfunc statusCode(resp: ResponseReceived): int =\n  resp.HttpRequest.responseCode\n\n# Usage\nlet req = Building(HttpRequest(path: \"/api/users\"))\n  .header(\"Accept\", \"application/json\")\n  .header(\"Authorization\", \"Bearer token\")\n  .sendHeaders()\n  .finish()\n  .awaitResponse()\n\necho \"Status: \", req.statusCode()\n\n# COMPILE ERRORS:\n# headersSent.header(\"X-Late\", \"header\")  # Can't add headers after sent\n# building.sendBody(\"data\")               # Can't send body before headers\n# headersSent.statusCode()                # Can't read response yet\n</code></pre> <p>Bugs prevented:</p> <ul> <li>Adding headers after they're sent</li> <li>Sending body before headers</li> <li>Reading response before request complete</li> </ul>"},{"location":"guide/examples/#oauth-authentication","title":"OAuth Authentication","text":"<p>OAuth requires authenticated tokens for API calls and refresh tokens to renew expired access. Typestates prevent calls with missing or expired credentials.</p> <pre><code>import typestates\n\ntype\n  OAuthSession = object\n    accessToken: string\n    refreshToken: string\n    expiresAt: int64\n\n  Unauthenticated = distinct OAuthSession\n  AwaitingCallback = distinct OAuthSession\n  Authenticated = distinct OAuthSession\n  TokenExpired = distinct OAuthSession\n\ntypestate OAuthSession:\n  states Unauthenticated, AwaitingCallback, Authenticated, TokenExpired\n  transitions:\n    Unauthenticated -&gt; AwaitingCallback\n    AwaitingCallback -&gt; Authenticated\n    Authenticated -&gt; TokenExpired\n    TokenExpired -&gt; Authenticated\n    * -&gt; Unauthenticated\n\nproc startAuth(session: Unauthenticated): AwaitingCallback {.transition.} =\n  echo \"Redirect to: https://auth.example.com/authorize?...\"\n  result = AwaitingCallback(session.OAuthSession)\n\nproc handleCallback(session: AwaitingCallback, code: string): Authenticated {.transition.} =\n  var s = session.OAuthSession\n  s.accessToken = \"eyJhbGc...\" &amp; code\n  s.refreshToken = \"refresh_\" &amp; code\n  echo \"Tokens received\"\n  result = Authenticated(s)\n\nproc callApi(session: Authenticated, endpoint: string): string {.notATransition.} =\n  echo \"GET \", endpoint, \" (Bearer \", session.OAuthSession.accessToken[0..10], \"...)\"\n  result = \"\"\"{\"status\": \"ok\"}\"\"\"\n\nproc tokenExpired(session: Authenticated): TokenExpired {.transition.} =\n  echo \"Token expired!\"\n  result = TokenExpired(session.OAuthSession)\n\nproc refresh(session: TokenExpired): Authenticated {.transition.} =\n  echo \"Refreshing token...\"\n  result = Authenticated(session.OAuthSession)\n\n# Usage\nlet session = Unauthenticated(OAuthSession())\n  .startAuth()\n  .handleCallback(\"auth_code_xyz\")\n\nlet data = session.callApi(\"/api/user/me\")\nlet expired = session.tokenExpired()\nlet refreshed = expired.refresh()\n\n# COMPILE ERRORS:\n# Unauthenticated(OAuthSession()).callApi(\"/api\")  # Can't call API unauthenticated\n# expired.callApi(\"/api\")                          # Can't call API with expired token\n# session.refresh()                                # Can't refresh non-expired token\n</code></pre> <p>Bugs prevented:</p> <ul> <li>API calls without authentication</li> <li>API calls with expired token</li> <li>Refreshing non-expired token</li> <li>Handling callback twice</li> </ul>"},{"location":"guide/examples/#robot-arm-controller","title":"Robot Arm Controller","text":"<p>Hardware control requires strict operation sequences. Moving without homing can crash into limits; powering off during movement can damage motors.</p> <pre><code>import typestates\n\ntype\n  RobotArm = object\n    x, y, z: float\n\n  PoweredOff = distinct RobotArm\n  NeedsHoming = distinct RobotArm\n  Homing = distinct RobotArm\n  Ready = distinct RobotArm\n  Moving = distinct RobotArm\n  EmergencyStop = distinct RobotArm\n\ntypestate RobotArm:\n  states PoweredOff, NeedsHoming, Homing, Ready, Moving, EmergencyStop\n  transitions:\n    PoweredOff -&gt; NeedsHoming\n    NeedsHoming -&gt; Homing\n    Homing -&gt; Ready\n    Ready -&gt; Moving | PoweredOff as ReadyResult\n    Moving -&gt; Ready | EmergencyStop as MoveResult\n    EmergencyStop -&gt; NeedsHoming | PoweredOff as RecoveryResult\n\nproc powerOn(arm: PoweredOff): NeedsHoming {.transition.} =\n  echo \"Powering on... Position unknown!\"\n  result = NeedsHoming(arm.RobotArm)\n\nproc startHoming(arm: NeedsHoming): Homing {.transition.} =\n  echo \"Finding home position...\"\n  result = Homing(arm.RobotArm)\n\nproc homingComplete(arm: Homing): Ready {.transition.} =\n  echo \"Homing complete. Ready!\"\n  result = Ready(arm.RobotArm)\n\nproc moveTo(arm: Ready, x, y, z: float): Moving {.transition.} =\n  echo \"Moving to (\", x, \", \", y, \", \", z, \")...\"\n  result = Moving(arm.RobotArm)\n\nproc moveComplete(arm: Moving): Ready {.transition.} =\n  echo \"Move complete\"\n  result = Ready(arm.RobotArm)\n\nproc emergencyStop(arm: Moving, reason: string): EmergencyStop {.transition.} =\n  echo \"!!! EMERGENCY STOP: \", reason\n  result = EmergencyStop(arm.RobotArm)\n\nproc powerOff(arm: Ready): PoweredOff {.transition.} =\n  echo \"Powering off safely\"\n  result = PoweredOff(arm.RobotArm)\n\n# Usage\nvar arm = PoweredOff(RobotArm())\nlet ready = arm.powerOn().startHoming().homingComplete()\nlet moving = ready.moveTo(100.0, 50.0, 20.0)\nlet done = moving.moveComplete()\nlet off = done.powerOff()\n\n# COMPILE ERRORS - These could damage equipment!\n# arm.moveTo(100, 0, 0)     # Can't move without homing!\n# moving.powerOff()         # Can't power off while moving!\n# ready.startHoming()       # Already homed!\n</code></pre> <p>Bugs prevented:</p> <ul> <li>Moving without homing (could crash into limits)</li> <li>Power off while moving (motor damage)</li> <li>Continuing after emergency stop</li> <li>Skip initialization</li> </ul>"},{"location":"guide/examples/#order-fulfillment","title":"Order Fulfillment","text":"<p>Order fulfillment has a fixed sequence: place, pay, ship, deliver. Typestates ensure orders can't be shipped before payment or shipped twice.</p> <pre><code>import typestates\n\ntype\n  Order = object\n    id: string\n    items: seq[string]\n    paymentId: string\n    trackingNumber: string\n\n  Cart = distinct Order\n  Placed = distinct Order\n  Paid = distinct Order\n  Shipped = distinct Order\n  Delivered = distinct Order\n\ntypestate Order:\n  states Cart, Placed, Paid, Shipped, Delivered\n  transitions:\n    Cart -&gt; Placed\n    Placed -&gt; Paid\n    Paid -&gt; Shipped\n    Shipped -&gt; Delivered\n\nproc addItem(order: Cart, item: string): Cart {.notATransition.} =\n  var o = order.Order\n  o.items.add(item)\n  result = Cart(o)\n\nproc placeOrder(order: Cart): Placed {.transition.} =\n  echo \"Order placed\"\n  result = Placed(order.Order)\n\nproc pay(order: Placed, paymentId: string): Paid {.transition.} =\n  var o = order.Order\n  o.paymentId = paymentId\n  echo \"Payment received: \", paymentId\n  result = Paid(o)\n\nproc ship(order: Paid, tracking: string): Shipped {.transition.} =\n  var o = order.Order\n  o.trackingNumber = tracking\n  echo \"Shipped! Tracking: \", tracking\n  result = Shipped(o)\n\nproc confirmDelivery(order: Shipped): Delivered {.transition.} =\n  echo \"Delivered!\"\n  result = Delivered(order.Order)\n\n# Usage\nlet order = Cart(Order())\n  .addItem(\"Laptop\")\n  .addItem(\"Mouse\")\n  .placeOrder()\n  .pay(\"pay_ch_123\")\n  .ship(\"1Z999AA10123456784\")\n  .confirmDelivery()\n\n# COMPILE ERRORS:\n# Cart(Order()).ship(\"TRACK\")  # Can't ship cart!\n# placed.ship(\"TRACK\")         # Can't ship without payment!\n# shipped.ship(\"TRACK2\")       # Can't ship twice!\n</code></pre> <p>Bugs prevented:</p> <ul> <li>Ship before payment</li> <li>Double-ship</li> <li>Operations on unplaced cart</li> </ul>"},{"location":"guide/examples/#document-workflow","title":"Document Workflow","text":"<p>Document publishing enforces a review process: draft, review, approve, publish. Typestates prevent publishing without approval or editing published content.</p> <pre><code>import typestates\n\ntype\n  Document = object\n    title: string\n    content: string\n    approver: string\n\n  Draft = distinct Document\n  InReview = distinct Document\n  Approved = distinct Document\n  Published = distinct Document\n\ntypestate Document:\n  states Draft, InReview, Approved, Published\n  transitions:\n    Draft -&gt; InReview\n    InReview -&gt; Approved | Draft as ReviewResult  # Approve or request changes\n    Approved -&gt; Published\n    Published -&gt; Draft  # New version\n\nproc edit(doc: Draft, content: string): Draft {.notATransition.} =\n  var d = doc.Document\n  d.content = content\n  result = Draft(d)\n\nproc submitForReview(doc: Draft): InReview {.transition.} =\n  echo \"Submitted for review\"\n  result = InReview(doc.Document)\n\nproc approve(doc: InReview, approver: string): Approved {.transition.} =\n  var d = doc.Document\n  d.approver = approver\n  echo \"Approved by: \", approver\n  result = Approved(d)\n\nproc requestChanges(doc: InReview): Draft {.transition.} =\n  echo \"Changes requested\"\n  result = Draft(doc.Document)\n\nproc publish(doc: Approved): Published {.transition.} =\n  echo \"Published!\"\n  result = Published(doc.Document)\n\n# Usage\nlet doc = Draft(Document(title: \"Q4 Strategy\"))\n  .edit(\"Our goals for Q4...\")\n  .submitForReview()\n  .approve(\"carol@company.com\")\n  .publish()\n\n# COMPILE ERRORS:\n# draft.publish()          # Can't publish without approval!\n# inReview.publish()       # Review not complete!\n# published.edit(\"hack\")   # Can't edit published content!\n</code></pre> <p>Bugs prevented:</p> <ul> <li>Publishing without approval</li> <li>Editing published content</li> <li>Skipping review process</li> </ul>"},{"location":"guide/examples/#generic-patterns","title":"Generic Patterns","text":"<p>The following examples show reusable typestate patterns using generics. See Generic Typestates for more on generic support.</p>"},{"location":"guide/examples/#resourcet-pattern","title":"Resource[T] Pattern","text":"<p>A reusable pattern for any resource requiring acquire/release semantics. Works with file handles, locks, connections, memory allocations, or any RAII-style resource.</p> <pre><code>import typestates\n\ntype\n  Resource[T] = object\n    handle: T\n    name: string\n\n  Released[T] = distinct Resource[T]\n  Acquired[T] = distinct Resource[T]\n\ntypestate Resource[T]:\n  states Released[T], Acquired[T]\n  transitions:\n    Released[T] -&gt; Acquired[T]\n    Acquired[T] -&gt; Released[T]\n\nproc acquire[T](r: Released[T], handle: T): Acquired[T] {.transition.} =\n  var res = Resource[T](r)\n  res.handle = handle\n  result = Acquired[T](res)\n\nproc release[T](r: Acquired[T]): Released[T] {.transition.} =\n  result = Released[T](Resource[T](r))\n\nproc use[T](r: Acquired[T]): T {.notATransition.} =\n  Resource[T](r).handle\n</code></pre> <p>Use with any resource type:</p> <pre><code># File handles\ntype FileHandle = object\n  fd: int\n  path: string\n\nvar file = Released[FileHandle](Resource[FileHandle](name: \"config\"))\nlet acquired = file.acquire(FileHandle(fd: 42, path: \"/etc/config\"))\necho acquired.use().path  # OK\nlet released = acquired.release()\n# released.use()  # COMPILE ERROR: can't use released resource\n\n# Database connections\ntype DbConn = object\n  connString: string\n\nvar db = Released[DbConn](Resource[DbConn](name: \"postgres\"))\nlet conn = db.acquire(DbConn(connString: \"postgresql://localhost/mydb\"))\n# ...use connection...\ndiscard conn.release()\n\n# Locks\ntype Lock = object\n  id: int\n\nvar mutex = Released[Lock](Resource[Lock](name: \"mutex\"))\nlet locked = mutex.acquire(Lock(id: 1))\n# ...critical section...\ndiscard locked.release()\n</code></pre> <p>Pattern benefits:</p> <ul> <li>Compile-time prevention of use-after-release</li> <li>Works with any resource type</li> <li>Enforces acquire-before-use</li> <li>Clean RAII semantics</li> </ul>"},{"location":"guide/examples/#pipelinet-pattern","title":"Pipeline[T] Pattern","text":"<p>A reusable pattern for entities that progress through a fixed sequence of stages. Works for orders, documents, builds, deployments, or any linear workflow.</p> <pre><code>import typestates\n\ntype\n  Pipeline[T] = object\n    entity: T\n\n  Stage1[T] = distinct Pipeline[T]\n  Stage2[T] = distinct Pipeline[T]\n  Stage3[T] = distinct Pipeline[T]\n  Stage4[T] = distinct Pipeline[T]\n\ntypestate Pipeline[T]:\n  states Stage1[T], Stage2[T], Stage3[T], Stage4[T]\n  transitions:\n    Stage1[T] -&gt; Stage2[T]\n    Stage2[T] -&gt; Stage3[T]\n    Stage3[T] -&gt; Stage4[T]\n\nproc start[T](entity: T): Stage1[T] =\n  Stage1[T](Pipeline[T](entity: entity))\n\nproc advance12[T](p: Stage1[T]): Stage2[T] {.transition.} =\n  Stage2[T](Pipeline[T](p))\n\nproc advance23[T](p: Stage2[T]): Stage3[T] {.transition.} =\n  Stage3[T](Pipeline[T](p))\n\nproc advance34[T](p: Stage3[T]): Stage4[T] {.transition.} =\n  Stage4[T](Pipeline[T](p))\n\nproc entity[T](p: Stage1[T]): T {.notATransition.} = Pipeline[T](p).entity\nproc entity[T](p: Stage2[T]): T {.notATransition.} = Pipeline[T](p).entity\nproc entity[T](p: Stage3[T]): T {.notATransition.} = Pipeline[T](p).entity\nproc entity[T](p: Stage4[T]): T {.notATransition.} = Pipeline[T](p).entity\n</code></pre> <p>Apply to different domains with semantic aliases:</p> <pre><code># Order fulfillment\ntype Order = object\n  id: string\n  items: seq[string]\n\ntype\n  OrderCart = Stage1[Order]      # Cart\n  OrderPaid = Stage2[Order]      # Paid\n  OrderShipped = Stage3[Order]   # Shipped\n  OrderDelivered = Stage4[Order] # Delivered\n\nlet order = start(Order(id: \"ORD-001\"))\nlet paid = order.advance12()      # Cart -&gt; Paid\nlet shipped = paid.advance23()    # Paid -&gt; Shipped\nlet delivered = shipped.advance34() # Shipped -&gt; Delivered\n\n# order.advance23()  # COMPILE ERROR: can't skip Paid stage\n\n# CI/CD builds\ntype Build = object\n  repo: string\n  commit: string\n\ntype\n  BuildQueued = Stage1[Build]\n  BuildCompiling = Stage2[Build]\n  BuildTesting = Stage3[Build]\n  BuildDeployed = Stage4[Build]\n\n# Document review\ntype Document = object\n  title: string\n  content: string\n\ntype\n  DocDraft = Stage1[Document]\n  DocInReview = Stage2[Document]\n  DocApproved = Stage3[Document]\n  DocPublished = Stage4[Document]\n</code></pre> <p>Pattern benefits:</p> <ul> <li>Enforces stage ordering at compile time</li> <li>Prevents skipping stages</li> <li>Single definition works for any entity type</li> <li>Domain-specific naming via type aliases</li> </ul>"},{"location":"guide/examples/#tips-for-designing-typestates","title":"Tips for Designing Typestates","text":""},{"location":"guide/examples/#1-start-with-the-state-diagram","title":"1. Start with the State Diagram","text":"<p>Draw your states and transitions first. Each arrow becomes a transition declaration.</p>"},{"location":"guide/examples/#2-one-responsibility-per-state","title":"2. One Responsibility Per State","text":"<p>Each state should represent one clear condition. If a state has multiple meanings, split it.</p>"},{"location":"guide/examples/#3-use-wildcards-sparingly","title":"3. Use Wildcards Sparingly","text":"<p><code>* -&gt; X</code> is powerful but can hide bugs. Use it only for truly universal operations like \"reset\" or \"emergency stop\".</p>"},{"location":"guide/examples/#4-consider-error-states","title":"4. Consider Error States","text":"<p>Many real systems need error/failure states. Plan for them upfront.</p>"},{"location":"guide/examples/#5-document-state-meanings","title":"5. Document State Meanings","text":"<p>Even with types enforcing transitions, document what each state means:</p> <pre><code>type\n  Pending = distinct Order\n    ## Order placed but not paid\n\n  Paid = distinct Order\n    ## Payment received, awaiting fulfillment\n\n  Shipped = distinct Order\n    ## Order shipped to customer\n</code></pre>"},{"location":"guide/formal-guarantees/","title":"Formal Guarantees","text":""},{"location":"guide/formal-guarantees/#formal-guarantees","title":"Formal Guarantees","text":"<p>This page explains the verification properties that nim-typestates provides and how they relate to formal methods concepts.</p>"},{"location":"guide/formal-guarantees/#correctness-by-construction","title":"Correctness by Construction","text":"<p>nim-typestates implements a form of correctness by construction: rather than testing for state machine violations at runtime, the type system makes them impossible to express.</p> <p>The Nim compiler acts as a verifier. If compilation succeeds, the program has been proven to contain no invalid state transitions.</p>"},{"location":"guide/formal-guarantees/#what-is-verified","title":"What is Verified","text":""},{"location":"guide/formal-guarantees/#temporal-safety","title":"Temporal Safety","text":"<p>Standard type systems verify data safety: a variable declared as <code>int</code> cannot be used as a <code>string</code>. Typestates extend this to temporal safety: an object in state <code>Closed</code> cannot be used where state <code>Open</code> is required.</p> <p>This prevents a class of bugs where operations are called in the wrong order or on objects in invalid states.</p>"},{"location":"guide/formal-guarantees/#protocol-adherence","title":"Protocol Adherence","text":"<p>Each <code>{.transition.}</code> proc is checked against the declared state graph. The compiler rejects any proc that:</p> <ul> <li>Takes a state type not registered in a typestate</li> <li>Returns a state not reachable from the input state</li> <li>Implements an undeclared transition</li> </ul>"},{"location":"guide/formal-guarantees/#state-exclusivity","title":"State Exclusivity","text":"<p>Distinct types ensure an object cannot satisfy multiple state types simultaneously. The type <code>Closed</code> is incompatible with <code>Open</code> at the type level, not just the value level.</p>"},{"location":"guide/formal-guarantees/#limitations","title":"Limitations","text":""},{"location":"guide/formal-guarantees/#specification-correctness","title":"Specification Correctness","text":"<p>The compiler verifies that code follows the declared state machine. It does not verify that the state machine correctly models the intended protocol.</p> <p>If the specification is wrong, the implementation will be \"correctly wrong.\"</p>"},{"location":"guide/formal-guarantees/#functional-correctness","title":"Functional Correctness","text":"<p>Typestates verify when operations can be called, not what they do. A <code>{.transition.}</code> proc from <code>Closed</code> to <code>Open</code> is verified to be callable only on <code>Closed</code> values and to return <code>Open</code> values. The proc body itself is not verified.</p>"},{"location":"guide/formal-guarantees/#runtime-behavior","title":"Runtime Behavior","text":"<p>Typestates operate at compile time. Runtime properties such as performance, memory safety, or exception behavior are outside their scope.</p> <p>For guidance on modeling errors as states rather than exceptions, see Error Handling.</p>"},{"location":"guide/formal-guarantees/#comparison-to-full-formal-verification","title":"Comparison to Full Formal Verification","text":"Aspect nim-typestates Full Formal Methods (TLA+, Coq) What is verified Protocol adherence Functional correctness Verification method Type checking Theorem proving Effort required Automatic Manual proofs Typical use Application protocols Safety-critical systems <p>nim-typestates occupies a practical middle ground: stronger guarantees than testing, lower cost than full formal verification.</p>"},{"location":"guide/generics/","title":"Generic Typestates","text":""},{"location":"guide/generics/#generic-typestates","title":"Generic Typestates","text":"<p>nim-typestates supports generic type parameters, enabling reusable typestate patterns.</p>"},{"location":"guide/generics/#basic-generic-typestate","title":"Basic Generic Typestate","text":"<p>Define a typestate with type parameters:</p> <pre><code>import typestates\n\ntype\n  Container[T] = object\n    value: T\n  Empty[T] = distinct Container[T]\n  Full[T] = distinct Container[T]\n\ntypestate Container[T]:\n  states Empty[T], Full[T]\n  transitions:\n    Empty[T] -&gt; Full[T]\n    Full[T] -&gt; Empty[T]\n</code></pre> <p>Implement transitions using generic procs:</p> <pre><code>proc fill[T](c: Empty[T], val: T): Full[T] {.transition.} =\n  var cont = Container[T](c)\n  cont.value = val\n  result = Full[T](cont)\n\nproc empty[T](c: Full[T]): Empty[T] {.transition.} =\n  result = Empty[T](Container[T](c))\n</code></pre> <p>Use with any type:</p> <pre><code># With int\nlet e = Empty[int](Container[int](value: 0))\nlet f = e.fill(42)\nlet e2 = f.empty()\n\n# With string\nlet s = Empty[string](Container[string](value: \"\"))\nlet s2 = s.fill(\"hello\")\n</code></pre>"},{"location":"guide/generics/#multiple-type-parameters","title":"Multiple Type Parameters","text":"<p>Typestates can have multiple type parameters:</p> <pre><code>type\n  KeyValue[K, V] = object\n    key: K\n    value: V\n  EmptyKV[K, V] = distinct KeyValue[K, V]\n  HasKey[K, V] = distinct KeyValue[K, V]\n  HasBoth[K, V] = distinct KeyValue[K, V]\n\ntypestate KeyValue[K, V]:\n  states EmptyKV[K, V], HasKey[K, V], HasBoth[K, V]\n  transitions:\n    EmptyKV[K, V] -&gt; HasKey[K, V]\n    HasKey[K, V] -&gt; HasBoth[K, V]\n    HasBoth[K, V] -&gt; EmptyKV[K, V]\n\nproc setKey[K, V](kv: EmptyKV[K, V], key: K): HasKey[K, V] {.transition.} =\n  var obj = KeyValue[K, V](kv)\n  obj.key = key\n  result = HasKey[K, V](obj)\n\nproc setValue[K, V](kv: HasKey[K, V], value: V): HasBoth[K, V] {.transition.} =\n  var obj = KeyValue[K, V](kv)\n  obj.value = value\n  result = HasBoth[K, V](obj)\n</code></pre>"},{"location":"guide/generics/#non-transitions-with-generics","title":"Non-Transitions with Generics","text":"<p>Use <code>{.notATransition.}</code> for operations that don't change state:</p> <pre><code>proc peek[T](c: Full[T]): T {.notATransition.} =\n  Container[T](c).value\n\nproc size[K, V](kv: HasBoth[K, V]): int {.notATransition.} =\n  1  # Always contains one key-value pair\n</code></pre>"},{"location":"guide/generics/#type-conversion-syntax","title":"Type Conversion Syntax","text":"<p>When converting between distinct generic types, use <code>Type[params](value)</code> syntax:</p> <pre><code># Correct - explicit generic parameters\nvar cont = Container[T](c)        # From distinct to base\nresult = Full[T](cont)            # From base to distinct\n\n# Wrong - method call syntax doesn't work with generics\n# var cont = c.Container[T]       # Compile error\n</code></pre>"},{"location":"guide/generics/#generated-helpers","title":"Generated Helpers","text":"<p>For generic typestates, helper types (enum, union, state procs) are not generated because the type parameters aren't in scope for the generated code. The core validation still works.</p> <p>For non-generic typestates, these are generated:</p> Helper Example Generated For Generics? State enum <code>ContainerState = enum fsEmpty, fsFull</code> No Union type <code>ContainerStates = Empty | Full</code> No State procs <code>proc state(c: Empty): ContainerState</code> No <p>You can create your own helpers if needed:</p> <pre><code>proc isEmptyState[T](c: Empty[T]): bool = true\nproc isEmptyState[T](c: Full[T]): bool = false\n\nproc isFull[T](c: Empty[T]): bool = false\nproc isFull[T](c: Full[T]): bool = true\n</code></pre>"},{"location":"guide/generics/#supported-type-expressions","title":"Supported Type Expressions","text":"<p>Generic typestates support various type expressions:</p> Type Expression Example Notes Simple generics <code>Container[T]</code> Single type parameter Multi-param generics <code>Map[K, V]</code> Multiple type parameters Nested generics <code>Container[seq[T]]</code> Generic of generic Constrained generics <code>Container[T: SomeInteger]</code> With type bounds"},{"location":"guide/generics/#pattern-builder-with-required-fields","title":"Pattern: Builder with Required Fields","text":"<p>Use generics to track which fields have been set:</p> <pre><code>type\n  UserBuilder = object\n    name: string\n    email: string\n\n  NeedsBoth = distinct UserBuilder\n  NeedsEmail = distinct UserBuilder\n  Complete = distinct UserBuilder\n\ntypestate UserBuilder:\n  states NeedsBoth, NeedsEmail, Complete\n  transitions:\n    NeedsBoth -&gt; NeedsEmail\n    NeedsEmail -&gt; Complete\n\nproc withName(b: NeedsBoth, name: string): NeedsEmail {.transition.} =\n  var builder = UserBuilder(b)\n  builder.name = name\n  result = NeedsEmail(builder)\n\nproc withEmail(b: NeedsEmail, email: string): Complete {.transition.} =\n  var builder = UserBuilder(b)\n  builder.email = email\n  result = Complete(builder)\n\nproc build(b: Complete): User {.notATransition.} =\n  let builder = UserBuilder(b)\n  User(name: builder.name, email: builder.email)\n</code></pre>"},{"location":"guide/generics/#pattern-resource-wrapper","title":"Pattern: Resource Wrapper","text":"<p>Wrap any resource type with acquire/release protocol:</p> <pre><code>type\n  Resource[T] = object\n    handle: T\n  Released[T] = distinct Resource[T]\n  Acquired[T] = distinct Resource[T]\n\ntypestate Resource[T]:\n  states Released[T], Acquired[T]\n  transitions:\n    Released[T] -&gt; Acquired[T]\n    Acquired[T] -&gt; Released[T]\n\nproc acquire[T](r: Released[T], handle: T): Acquired[T] {.transition.} =\n  var res = Resource[T](r)\n  res.handle = handle\n  result = Acquired[T](res)\n\nproc release[T](r: Acquired[T]): Released[T] {.transition.} =\n  result = Released[T](Resource[T](r))\n\nproc use[T](r: Acquired[T]): T {.notATransition.} =\n  Resource[T](r).handle\n</code></pre>"},{"location":"guide/generics/#limitations","title":"Limitations","text":"<ol> <li>No helper generation: Generic typestates don't get enum/union/state proc helpers</li> <li>Same base name: All states in a generic typestate must have distinct base names (e.g., <code>Empty[T]</code> and <code>Empty[V]</code> would conflict)</li> </ol>"},{"location":"guide/generics/#next-steps","title":"Next Steps","text":"<ul> <li>DSL Reference - Complete syntax reference</li> <li>Examples - More usage patterns</li> </ul>"},{"location":"guide/getting-started/","title":"Getting Started","text":""},{"location":"guide/getting-started/#getting-started","title":"Getting Started","text":"<p>This guide walks through building a typestate-validated file handle from scratch.</p>"},{"location":"guide/getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Nim 2.0 or later</li> <li>Basic familiarity with Nim's type system</li> </ul>"},{"location":"guide/getting-started/#installation","title":"Installation","text":"<pre><code>nimble install typestates\n</code></pre>"},{"location":"guide/getting-started/#step-1-define-your-base-type","title":"Step 1: Define Your Base Type","text":"<p>Start with a regular object type that holds your data:</p> <pre><code>type\n  File = object\n    path: string\n    handle: int  # OS file descriptor\n</code></pre>"},{"location":"guide/getting-started/#step-2-define-state-types","title":"Step 2: Define State Types","text":"<p>Create distinct types for each state. Using <code>distinct</code> ensures the compiler treats them as different types:</p> <pre><code>type\n  File = object\n    path: string\n    handle: int\n\n  Closed = distinct File\n  Open = distinct File\n</code></pre> <p>Now <code>Closed</code> and <code>Open</code> are incompatible types - you can't pass a <code>Closed</code> where an <code>Open</code> is expected.</p>"},{"location":"guide/getting-started/#step-3-declare-the-typestate","title":"Step 3: Declare the Typestate","text":"<p>Import the library and declare valid transitions:</p> <pre><code>import typestates\n\ntype\n  File = object\n    path: string\n    handle: int\n  Closed = distinct File\n  Open = distinct File\n\ntypestate File:\n  states Closed, Open\n  transitions:\n    Closed -&gt; Open\n    Open -&gt; Closed\n</code></pre> <p>This tells the compiler:</p> <ul> <li><code>File</code> has two states: <code>Closed</code> and <code>Open</code></li> <li><code>Closed</code> can transition to <code>Open</code></li> <li><code>Open</code> can transition to <code>Closed</code></li> <li>No other transitions are valid</li> </ul>"},{"location":"guide/getting-started/#step-4-implement-transitions","title":"Step 4: Implement Transitions","text":"<p>Use the <code>{.transition.}</code> pragma to mark state-changing procs:</p> <pre><code>proc open(f: Closed, path: string): Open {.transition.} =\n  ## Open a closed file, returning it in the Open state.\n  var file = f.File  # Access underlying File\n  file.path = path\n  file.handle = 1  # Pretend we opened it\n  result = Open(file)\n\nproc close(f: Open): Closed {.transition.} =\n  ## Close an open file, returning it in the Closed state.\n  var file = f.File\n  file.handle = 0  # Pretend we closed it\n  result = Closed(file)\n</code></pre> <p>The <code>{.transition.}</code> pragma validates at compile time that:</p> <ol> <li>The input type (<code>Closed</code> or <code>Open</code>) is a registered state</li> <li>The return type is a valid transition target</li> <li>The transition is declared in the typestate block</li> </ol>"},{"location":"guide/getting-started/#step-5-use-it","title":"Step 5: Use It","text":"<pre><code># Create a file in the Closed state\nvar f = Closed(File(path: \"\", handle: 0))\n\n# Open it - returns Open type\nlet opened = f.open(\"/tmp/example.txt\")\n\n# Close it - returns Closed type\nlet closed = opened.close()\n\n# This won't compile!\n# let bad = opened.open(\"/other.txt\")\n# Error: Undeclared transition: Open -&gt; Open\n</code></pre>"},{"location":"guide/getting-started/#what-happens-on-invalid-transitions","title":"What Happens on Invalid Transitions?","text":"<p>If you try to implement an undeclared transition:</p> <pre><code>proc lock(f: Open): Locked {.transition.} =\n  discard\n</code></pre> <p>You get a compile-time error:</p> <pre><code>Error: Undeclared transition: Open -&gt; Locked\n  Typestate 'File' does not declare this transition.\n  Valid transitions from 'Open': @[\"Closed\"]\n  Hint: Add 'Open -&gt; Locked' to the transitions block.\n</code></pre>"},{"location":"guide/getting-started/#generated-helpers","title":"Generated Helpers","text":"<p>The <code>typestate</code> macro generates some useful types:</p>"},{"location":"guide/getting-started/#state-enum","title":"State Enum","text":"<pre><code>type FileState* = enum\n  fsClosed, fsOpen\n</code></pre>"},{"location":"guide/getting-started/#union-type","title":"Union Type","text":"<pre><code>type FileStates* = Closed | Open\n</code></pre>"},{"location":"guide/getting-started/#state-procs","title":"State Procs","text":"<pre><code>proc state*(f: Closed): FileState = fsClosed\nproc state*(f: Open): FileState = fsOpen\n</code></pre> <p>Use them for runtime inspection when needed:</p> <pre><code>proc describe[S: FileStates](f: S): string =\n  case f.state\n  of fsClosed: \"File is closed\"\n  of fsOpen: \"File is open\"\n</code></pre>"},{"location":"guide/getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>DSL Reference - Learn about branching, wildcards, and more</li> <li>Examples - See real-world patterns</li> <li>Error Handling - Model errors as states</li> </ul> <p>For details on what the compiler verifies, see Formal Guarantees.</p>"},{"location":"guide/strict-mode/","title":"Strict Mode","text":""},{"location":"guide/strict-mode/#strict-mode","title":"Strict Mode","text":"<p>nim-typestates uses strict defaults to catch bugs early.</p>"},{"location":"guide/strict-mode/#default-behavior","title":"Default Behavior","text":"<p>By default, typestates have:</p> <ul> <li><code>strictTransitions = true</code> - All procs with state params must be marked</li> </ul>"},{"location":"guide/strict-mode/#stricttransitions","title":"strictTransitions","text":"<p>When enabled, any proc with a state type as its first parameter MUST have either:</p> <ul> <li><code>{.transition.}</code> - for state-changing operations</li> <li><code>{.notATransition.}</code> - for read-only operations</li> </ul> <pre><code>typestate File:\n  states Closed, Open\n  transitions:\n    Closed -&gt; Open\n\nproc open(f: Closed): Open {.transition.} = ...     # OK\nproc read(f: Open): string {.notATransition.} = ... # OK\nproc helper(f: Open): int = ...                     # ERROR!\n</code></pre>"},{"location":"guide/strict-mode/#opting-out","title":"Opting Out","text":"<pre><code>typestate LegacyFile:\n  strictTransitions = false\n  states Closed, Open\n  ...\n</code></pre>"},{"location":"guide/strict-mode/#module-boundaries","title":"Module Boundaries","text":"<p>Typestates can only be defined once, in a single module. All states and transitions must be declared together:</p> <pre><code># library.nim\ntypestate Payment:\n  states Created, Captured\n  transitions:\n    Created -&gt; Captured\n\n# user_code.nim\nimport library\n\nproc check(p: Created): bool {.notATransition.} = ...  # OK - read-only\nproc hack(p: Created): Captured {.transition.} = ...   # ERROR - can't add transitions from external module\n</code></pre> <p>This ensures the typestate's behavior is fully defined where it's declared, preventing accidental or malicious modification from other modules.</p>"},{"location":"guide/verification/","title":"Verification","text":""},{"location":"guide/verification/#verification","title":"Verification","text":"<p>The typestates library provides multiple verification layers.</p>"},{"location":"guide/verification/#compile-time-checking","title":"Compile-Time Checking","text":"<p>The <code>{.transition.}</code> and <code>{.notATransition.}</code> pragmas validate at compile time:</p> <ul> <li>Transitions match declared state machine</li> <li>Sealed typestates block external transitions</li> </ul>"},{"location":"guide/verification/#verifytypestates-macro","title":"verifyTypestates() Macro","text":"<p>For comprehensive in-module verification:</p> <pre><code>import typestates\n\ntypestate File:\n  states Closed, Open\n  ...\n\nproc open(...) {.transition.} = ...\nproc close(...) {.transition.} = ...\n\nverifyTypestates()  # Validates everything above\n</code></pre>"},{"location":"guide/verification/#cli-tool","title":"CLI Tool","text":"<p>The <code>typestates</code> CLI provides project-wide verification and visualization:</p> <pre><code>typestates verify src/     # Check all procs are properly marked\ntypestates dot src/        # Generate GraphViz diagrams\n</code></pre> <p>See CLI Reference for complete usage and Visualization for diagram generation.</p>"},{"location":"guide/visualization/","title":"Visualization","text":""},{"location":"guide/visualization/#visualization","title":"Visualization","text":"<p>The <code>typestates dot</code> command generates GraphViz DOT output for visualizing state machines as diagrams.</p>"},{"location":"guide/visualization/#basic-usage","title":"Basic Usage","text":"<pre><code># Generate DOT output\ntypestates dot src/\n\n# Save to file\ntypestates dot src/ &gt; states.dot\n\n# Generate PNG directly\ntypestates dot src/ | dot -Tpng -o states.png\n\n# Generate SVG for web\ntypestates dot src/ | dot -Tsvg -o states.svg\n</code></pre>"},{"location":"guide/visualization/#example-file-state-machine","title":"Example: File State Machine","text":"<p>Given this typestate definition:</p> <pre><code>import typestates\n\ntype\n  File = object\n    path: string\n  Closed = distinct File\n  Open = distinct File\n\ntypestate File:\n  states Closed, Open\n  transitions:\n    Closed -&gt; Open\n    Open -&gt; Closed\n</code></pre> <p>Running <code>typestates dot src/</code> produces:</p> <pre><code>digraph File {\n  rankdir=LR;\n  node [shape=box];\n\n  Closed;\n  Open;\n\n  Closed -&gt; Open;\n  Open -&gt; Closed;\n}\n</code></pre> <p>Rendered as a diagram:</p> <p></p>"},{"location":"guide/visualization/#example-payment-processing","title":"Example: Payment Processing","text":"<p>A more complex example with branching transitions:</p> <pre><code>typestate Payment:\n  states Created, Authorized, Captured, PartiallyRefunded, FullyRefunded, Settled, Voided\n  transitions:\n    Created -&gt; Authorized\n    Authorized -&gt; Captured | Voided as AuthResult\n    Captured -&gt; PartiallyRefunded | FullyRefunded | Settled as CaptureResult\n    PartiallyRefunded -&gt; PartiallyRefunded | FullyRefunded | Settled as RefundResult\n    FullyRefunded -&gt; Settled\n</code></pre> <p>DOT output:</p> <pre><code>digraph Payment {\n  rankdir=LR;\n  node [shape=box];\n\n  Created;\n  Authorized;\n  Captured;\n  PartiallyRefunded;\n  FullyRefunded;\n  Settled;\n  Voided;\n\n  Created -&gt; Authorized;\n  Authorized -&gt; Captured;\n  Authorized -&gt; Voided;\n  Captured -&gt; PartiallyRefunded;\n  Captured -&gt; FullyRefunded;\n  Captured -&gt; Settled;\n  PartiallyRefunded -&gt; PartiallyRefunded;\n  PartiallyRefunded -&gt; FullyRefunded;\n  PartiallyRefunded -&gt; Settled;\n  FullyRefunded -&gt; Settled;\n}\n</code></pre> <p></p>"},{"location":"guide/visualization/#example-wildcard-transitions","title":"Example: Wildcard Transitions","text":"<p>Wildcard transitions (<code>* -&gt; State</code>) are rendered with dashed edges:</p> <pre><code>typestate DbConnection:\n  states Pooled, CheckedOut, InTransaction, Closed\n  transitions:\n    Pooled -&gt; CheckedOut | Closed as PoolResult\n    CheckedOut -&gt; Pooled | InTransaction | Closed as CheckoutResult\n    InTransaction -&gt; CheckedOut\n    * -&gt; Closed\n</code></pre> <p>DOT output:</p> <pre><code>digraph DbConnection {\n  rankdir=LR;\n  node [shape=box];\n\n  Pooled;\n  CheckedOut;\n  InTransaction;\n  Closed;\n\n  Pooled -&gt; CheckedOut;\n  Pooled -&gt; Closed;\n  CheckedOut -&gt; Pooled;\n  CheckedOut -&gt; InTransaction;\n  CheckedOut -&gt; Closed;\n  InTransaction -&gt; CheckedOut;\n  Pooled -&gt; Closed [style=dashed];\n  CheckedOut -&gt; Closed [style=dashed];\n  InTransaction -&gt; Closed [style=dashed];\n  Closed -&gt; Closed [style=dashed];\n}\n</code></pre> <p></p> <p>The dashed edges indicate transitions that apply from any state (wildcard).</p>"},{"location":"guide/visualization/#installing-graphviz","title":"Installing GraphViz","text":"<p>The DOT output can be rendered with GraphViz. Install it for your platform:</p> macOSUbuntu/DebianWindows <pre><code>brew install graphviz\n</code></pre> <pre><code>sudo apt install graphviz\n</code></pre> <pre><code>choco install graphviz\n</code></pre>"},{"location":"guide/visualization/#output-formats","title":"Output Formats","text":"<p>GraphViz supports many output formats:</p> Format Command Use Case PNG <code>dot -Tpng</code> Documentation, README SVG <code>dot -Tsvg</code> Web, scalable graphics PDF <code>dot -Tpdf</code> Print, documentation DOT (raw output) Further processing"},{"location":"guide/visualization/#customizing-output","title":"Customizing Output","text":"<p>You can post-process the DOT output for custom styling:</p> <pre><code># Add custom colors\ntypestates dot src/ | sed 's/shape=box/shape=box, fillcolor=lightblue, style=filled/' | dot -Tpng -o colored.png\n\n# Change layout direction (top-to-bottom)\ntypestates dot src/ | sed 's/rankdir=LR/rankdir=TB/' | dot -Tpng -o vertical.png\n</code></pre>"},{"location":"guide/visualization/#generating-documentation-images","title":"Generating Documentation Images","text":"<p>To include diagrams in your documentation:</p> <pre><code># Create images directory\nmkdir -p docs/assets/images\n\n# Generate all typestate diagrams\ntypestates dot src/ | csplit -f docs/assets/images/state- -b '%02d.dot' - '/^digraph/' '{*}'\n\n# Convert each to SVG\nfor f in docs/assets/images/state-*.dot; do\n  dot -Tsvg \"$f\" -o \"${f%.dot}.svg\"\ndone\n</code></pre>"},{"location":"guide/visualization/#multiple-typestates","title":"Multiple Typestates","text":"<p>If your project has multiple typestates, the <code>dot</code> command outputs them all sequentially:</p> <pre><code>$ typestates dot src/\ndigraph File {\n  ...\n}\n\ndigraph Payment {\n  ...\n}\n\ndigraph Session {\n  ...\n}\n</code></pre> <p>You can split them into separate files with tools like <code>csplit</code> or process them programmatically.</p>"}]}