{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#nim-typestates","title":"nim-typestates","text":"<p>Compile-time typestate validation for Nim.</p>"},{"location":"#what-is-this","title":"What is this?","text":"<p>nim-typestates is a Nim library that enforces state machine patterns at compile time. Define your valid states and transitions, and the compiler ensures your code follows them.</p> <pre><code>import typestates\n\ntype\n  File = object\n    path: string\n  Closed = distinct File\n  Open = distinct File\n\ntypestate File:\n  states Closed, Open\n  transitions:\n    Closed -&gt; Open\n    Open -&gt; Closed\n\nproc open(f: Closed): Open {.transition.} =\n  result = Open(f)\n\nproc close(f: Open): Closed {.transition.} =\n  result = Closed(f)\n\n# This works:\nlet f = Closed(File(path: \"/tmp/test\"))\nlet opened = f.open()\nlet closed = opened.close()\n\n# This won't compile - Open can't transition to Open!\n# let bad = opened.open()\n</code></pre> <p>The compiler verifies that your code follows the declared protocol. If it compiles, invalid state transitions are impossible. See Formal Guarantees for details.</p>"},{"location":"#why-typestates","title":"Why typestates?","text":"<p>Traditional runtime state machines have problems:</p> <ul> <li>Runtime errors: Invalid transitions cause crashes or bugs</li> <li>Defensive code: You write <code>if state == X</code> checks everywhere</li> <li>Documentation drift: State diagrams don't match code</li> </ul> <p>Typestates solve this by encoding states in the type system:</p> <ul> <li>Compile-time errors: Invalid transitions don't compile</li> <li>Self-documenting: Types show valid operations</li> <li>Zero runtime cost: It's just types</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>Compile-time validation - Invalid transitions fail at compile time with clear error messages</li> <li>Branching transitions - <code>Closed -&gt; Open | Errored</code></li> <li>Wildcard transitions - <code>* -&gt; Closed</code> (any state can close)</li> <li>Generated helpers - <code>FileState</code> enum, <code>FileStates</code> union type</li> <li>GraphViz export - Visualize your state machine</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>nimble install nim_typestates\n</code></pre> <p>Or add to your <code>.nimble</code> file:</p> <pre><code>requires \"nim_typestates &gt;= 0.1.0\"\n</code></pre>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>Getting Started - Tutorial walkthrough</li> <li>DSL Reference - Complete syntax documentation</li> <li>Examples - Real-world patterns</li> <li>API Reference - Generated API docs</li> </ul>"},{"location":"#references","title":"References","text":"<ul> <li>Typestate Pattern in Rust - Excellent introduction to typestates</li> <li>typestate crate for Rust - Similar macro-based approach in Rust</li> <li>Plaid Language - CMU's typestate-oriented programming language</li> <li>Typestate: A Programming Language Concept (Strom &amp; Yemini, 1986) - Original paper introducing typestates</li> </ul>"},{"location":"#license","title":"License","text":"<p>MIT</p>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#api-reference","title":"API Reference","text":"<p>Auto-generated API documentation from source code.</p>"},{"location":"api/#main-module","title":"Main Module","text":""},{"location":"api/#typestates","title":"typestates","text":"<p>Compile-time state machine verification for Nim.</p> <p>This library enforces state machine protocols at compile time through Nim's type system. Programs that compile have been verified to contain no invalid state transitions.</p> <p>This approach is known as correctness by construction: invalid states become unrepresentable rather than checked at runtime.</p> <p>Exports:</p> <ul> <li><code>typestate</code> macro - Declare states and transitions</li> <li><code>{.transition.}</code> pragma - Mark and validate transition procs</li> <li><code>{.notATransition.}</code> pragma - Mark non-transition procs</li> </ul>          Generated with mkdocstrings-nim"},{"location":"api/#typestate","title":"typestate","text":"<pre><code>macro typestate(name: untyped; body: untyped): untyped</code></pre> <p>Define a typestate with states and valid transitions.</p> <p>The typestate block declares:</p> <ul> <li>states: The distinct types that represent each state</li> <li>transitions: Which state changes are allowed</li> </ul> <p>:param name: The base type name (must match your type definition) :param body: The states and transitions declarations :returns: Generated helper types (enum, union, state procs)</p> <p>Basic syntax:</p> <pre><code>typestate File:\n  states Closed, Open, Errored\n  transitions:\n    Closed -&gt; Open | Errored    # Branching\n    Open -&gt; Closed\n    * -&gt; Closed                 # Wildcard\n</code></pre> <p>What it generates:</p> <ul> <li><code>FileState</code> enum with <code>fsClosed</code>, <code>fsOpen</code>, <code>fsErrored</code></li> <li><code>FileStates</code> union type for generic procs</li> <li><code>state()</code> procs for runtime inspection</li> </ul> <p>Transition syntax:</p> <ul> <li><code>A -&gt; B</code> - Simple transition</li> <li><code>A -&gt; B | C</code> - Branching (can go to B or C)</li> <li><code>* -&gt; X</code> - Wildcard (any state can go to X)</li> </ul> <p>See also: <code>{.transition.}</code> pragma for implementing transitions</p> Parameters <ul> <li> <code>name</code>               (<code>untyped</code>)                \u2013 The base type name (must match your type definition)             </li> <li> <code>body</code>               (<code>untyped</code>)                \u2013 The states and transitions declarations             </li> </ul> Returns <p><code>untyped</code> \u2013 Generated helper types (enum, union, state procs) Basic syntax:  ```nim typestate File:   states Closed, Open, Errored   transitions:     Closed -&gt; Open | Errored    # Branching     Open -&gt; Closed     * -&gt; Closed                 # Wildcard ```  What it generates:  - `FileState` enum with `fsClosed`, `fsOpen`, `fsErrored` - `FileStates` union type for generic procs - `state()` procs for runtime inspection  Transition syntax:  - `A -&gt; B` - Simple transition - `A -&gt; B | C` - Branching (can go to B or C) - `* -&gt; X` - Wildcard (any state can go to X)  See also: `{.transition.}` pragma for implementing transitions</p> Source:              src/typestates.nim:21"},{"location":"api/#module-overview","title":"Module Overview","text":""},{"location":"api/#typestates_1","title":"<code>typestates</code>","text":"<p>The main module. Import this to use the library.</p> <p>Exports:</p> <ul> <li><code>typestate</code> macro - Declare states and transitions</li> <li><code>transition</code> pragma - Mark and validate transition procs</li> <li><code>notATransition</code> pragma - Mark non-transition procs</li> </ul>"},{"location":"api/#typestatestypes","title":"<code>typestates/types</code>","text":"<p>Core type definitions (internal).</p> <ul> <li><code>State</code> - Represents a single state</li> <li><code>Transition</code> - Represents a valid transition</li> <li><code>TypestateGraph</code> - Complete typestate definition</li> </ul>"},{"location":"api/#typestatesparser","title":"<code>typestates/parser</code>","text":"<p>DSL parser (internal).</p> <ul> <li><code>parseTypestateBody</code> - Parse typestate block into graph</li> <li><code>parseStates</code> - Parse states declaration</li> <li><code>parseTransition</code> - Parse single transition</li> </ul>"},{"location":"api/#typestatesregistry","title":"<code>typestates/registry</code>","text":"<p>Compile-time typestate storage (internal).</p> <ul> <li><code>typestateRegistry</code> - Global registry</li> <li><code>registerTypestate</code> - Add typestate to registry</li> <li><code>findTypestateForState</code> - Look up typestate by state name</li> </ul>"},{"location":"api/#typestatespragmas","title":"<code>typestates/pragmas</code>","text":"<p>Pragma implementations.</p> <ul> <li><code>transition</code> macro - Validates state transitions</li> <li><code>notATransition</code> template - Marks non-transitions</li> </ul>"},{"location":"api/#typestatescodegen","title":"<code>typestates/codegen</code>","text":"<p>Code generation (internal).</p> <ul> <li><code>generateStateEnum</code> - Generate <code>FileState</code> enum</li> <li><code>generateUnionType</code> - Generate <code>FileStates</code> union</li> <li><code>generateStateProcs</code> - Generate <code>state()</code> procs</li> </ul>"},{"location":"api/#typestatescli","title":"<code>typestates/cli</code>","text":"<p>Command-line tool functionality.</p> <ul> <li><code>parseTypestates</code> - Parse typestate definitions from source files</li> <li><code>generateDot</code> - Generate GraphViz DOT from parsed typestates</li> <li><code>verify</code> - Verify typestate rules in source files</li> </ul>"},{"location":"api/#quick-reference","title":"Quick Reference","text":""},{"location":"api/#typestate-declaration","title":"Typestate Declaration","text":"<pre><code>typestate TypeName:\n  states State1, State2, State3\n  transitions:\n    State1 -&gt; State2\n    State2 -&gt; State1 | State3\n    * -&gt; State1\n</code></pre>"},{"location":"api/#transition-proc","title":"Transition Proc","text":"<pre><code>proc doThing(s: State1): State2 {.transition.} =\n  result = State2(s.TypeName)\n</code></pre>"},{"location":"api/#non-transition-proc","title":"Non-Transition Proc","text":"<pre><code>proc sideEffect(s: State1) {.notATransition.} =\n  # Does something but doesn't change state\n  discard\n</code></pre>"},{"location":"api/#generated-types","title":"Generated Types","text":"<p>For <code>typestate File:</code> with states <code>Closed</code>, <code>Open</code>:</p> <pre><code># Enum\ntype FileState* = enum fsClosed, fsOpen\n\n# Union\ntype FileStates* = Closed | Open\n\n# Procs\nproc state*(f: Closed): FileState\nproc state*(f: Open): FileState\n</code></pre>"},{"location":"guide/dsl-reference/","title":"DSL Reference","text":""},{"location":"guide/dsl-reference/#dsl-reference","title":"DSL Reference","text":"<p>Complete reference for the nim-typestates DSL syntax.</p>"},{"location":"guide/dsl-reference/#typestate-block","title":"Typestate Block","text":"<pre><code>typestate TypeName:\n  states State1, State2, State3\n  transitions:\n    State1 -&gt; State2\n    State2 -&gt; State3\n</code></pre>"},{"location":"guide/dsl-reference/#states-declaration","title":"States Declaration","text":"<p>List all state types that participate in this typestate:</p> <pre><code>states Closed, Open, Reading, Writing, Errored\n</code></pre> <p>Each state must be a <code>distinct</code> type of the base type:</p> <pre><code>type\n  File = object\n    # ...\n  Closed = distinct File\n  Open = distinct File\n</code></pre>"},{"location":"guide/dsl-reference/#transitions-block","title":"Transitions Block","text":"<p>Declare valid state transitions using <code>-&gt;</code> syntax:</p> <pre><code>transitions:\n  Closed -&gt; Open\n  Open -&gt; Closed\n</code></pre>"},{"location":"guide/dsl-reference/#transition-syntax","title":"Transition Syntax","text":""},{"location":"guide/dsl-reference/#simple-transitions","title":"Simple Transitions","text":"<p>One source state to one destination:</p> <pre><code>Closed -&gt; Open\n</code></pre>"},{"location":"guide/dsl-reference/#branching-transitions","title":"Branching Transitions","text":"<p>One source state to multiple possible destinations using <code>|</code>:</p> <pre><code>Closed -&gt; Open | Errored\n</code></pre> <p>This means a proc taking <code>Closed</code> can return either <code>Open</code> or <code>Errored</code>.</p>"},{"location":"guide/dsl-reference/#wildcard-transitions","title":"Wildcard Transitions","text":"<p>Any state can transition to a destination using <code>*</code>:</p> <pre><code>* -&gt; Closed\n</code></pre> <p>Wildcards are useful for \"reset\" or \"cleanup\" operations that work from any state.</p>"},{"location":"guide/dsl-reference/#pragmas","title":"Pragmas","text":""},{"location":"guide/dsl-reference/#transition","title":"<code>{.transition.}</code>","text":"<p>Mark a proc as a state transition. The compiler validates that the transition is declared.</p> <pre><code>proc open(f: Closed): Open {.transition.} =\n  result = Open(f)\n</code></pre> <p>Validation rules:</p> <ul> <li>First parameter must be a registered state type</li> <li>Return type must be a valid transition target</li> <li>Transition must be declared in the typestate block</li> <li>Must have <code>{.raises: [].}</code> - errors should be states, not exceptions</li> </ul> <p>See Error Handling for patterns on modeling errors as states.</p> <p>Error on invalid transition:</p> <pre><code>Error: Undeclared transition: Open -&gt; Locked\n  Typestate 'File' does not declare this transition.\n  Valid transitions from 'Open': @[\"Closed\"]\n  Hint: Add 'Open -&gt; Locked' to the transitions block.\n</code></pre>"},{"location":"guide/dsl-reference/#notatransition","title":"<code>{.notATransition.}</code>","text":"<p>Mark a proc as intentionally NOT a transition. Use for procs that operate on state types but don't change state:</p> <pre><code>proc write(f: Open, data: string) {.notATransition.} =\n  # Writes data but stays in Open state\n  rawWrite(f.File.handle, data)\n\nproc read(f: Open, count: int): string {.notATransition.} =\n  # Reads data but stays in Open state\n  result = rawRead(f.File.handle, count)\n</code></pre> <p>For pure functions (no side effects), use <code>func</code> instead - no pragma needed:</p> <pre><code>func path(f: Open): string =\n  f.File.path\n</code></pre>"},{"location":"guide/dsl-reference/#generated-types","title":"Generated Types","text":"<p>For <code>typestate File:</code> with states <code>Closed</code>, <code>Open</code>, <code>Errored</code>:</p>"},{"location":"guide/dsl-reference/#state-enum","title":"State Enum","text":"<pre><code>type FileState* = enum\n  fsClosed, fsOpen, fsErrored\n</code></pre> <p>Enum values are prefixed with <code>fs</code> (for \"file state\") to avoid name collisions.</p>"},{"location":"guide/dsl-reference/#union-type","title":"Union Type","text":"<pre><code>type FileStates* = Closed | Open | Errored\n</code></pre> <p>Useful for generic procs that accept any state:</p> <pre><code>proc describe[S: FileStates](f: S): string =\n  case f.state\n  of fsClosed: \"closed\"\n  of fsOpen: \"open\"\n  of fsErrored: \"errored\"\n</code></pre>"},{"location":"guide/dsl-reference/#state-procs","title":"State Procs","text":"<pre><code>proc state*(f: Closed): FileState = fsClosed\nproc state*(f: Open): FileState = fsOpen\nproc state*(f: Errored): FileState = fsErrored\n</code></pre>"},{"location":"guide/dsl-reference/#complete-example","title":"Complete Example","text":"<pre><code>import typestates\n\ntype\n  Connection = object\n    host: string\n    port: int\n    socket: int\n\n  Disconnected = distinct Connection\n  Connecting = distinct Connection\n  Connected = distinct Connection\n  Errored = distinct Connection\n\ntypestate Connection:\n  states Disconnected, Connecting, Connected, Errored\n  transitions:\n    Disconnected -&gt; Connecting\n    Connecting -&gt; Connected | Errored\n    Connected -&gt; Disconnected\n    Errored -&gt; Disconnected\n    * -&gt; Disconnected  # Can always disconnect\n\nproc connect(c: Disconnected, host: string, port: int): Connecting {.transition.} =\n  var conn = c.Connection\n  conn.host = host\n  conn.port = port\n  result = Connecting(conn)\n\nproc waitForConnection(c: Connecting): Connected | Errored {.transition.} =\n  # In real code, this would do async I/O\n  if true:  # Pretend success\n    result = Connected(c.Connection)\n  else:\n    result = Errored(c.Connection)\n\nproc disconnect[S: ConnectionStates](c: S): Disconnected {.transition.} =\n  var conn = c.Connection\n  conn.socket = 0\n  result = Disconnected(conn)\n\nproc send(c: Connected, data: string) {.notATransition.} =\n  # Send data, stay connected\n  discard\n</code></pre>"},{"location":"guide/dsl-reference/#tips","title":"Tips","text":""},{"location":"guide/dsl-reference/#accessing-the-base-type","title":"Accessing the Base Type","text":"<p>State types are <code>distinct</code>, so you need to convert to access fields:</p> <pre><code>proc path(f: Open): string =\n  f.File.path  # Convert Open to File to access .path\n</code></pre>"},{"location":"guide/dsl-reference/#returning-union-types","title":"Returning Union Types","text":"<p>For branching transitions, return a union:</p> <pre><code>proc tryOpen(f: Closed): Open | Errored {.transition.} =\n  if success:\n    result = Open(f.File)\n  else:\n    result = Errored(f.File)\n</code></pre>"},{"location":"guide/dsl-reference/#generic-over-all-states","title":"Generic Over All States","text":"<p>Use the generated union type for generic procs:</p> <pre><code>proc forceClose[S: FileStates](f: S): Closed =\n  Closed(f.File)\n</code></pre>"},{"location":"guide/error-handling/","title":"Error Handling","text":""},{"location":"guide/error-handling/#error-handling","title":"Error Handling","text":"<p>Typestates model errors as states, not exceptions. If an operation can fail, the failure is a state the object transitions to.</p>"},{"location":"guide/error-handling/#the-rule","title":"The Rule","text":"<p>All <code>{.transition.}</code> procs must have <code>{.raises: [].}</code> - either explicitly declared or inferred. The library enforces this at compile time.</p>"},{"location":"guide/error-handling/#why","title":"Why?","text":"<p>Exceptions bypass the state machine. If a transition raises an exception, the caller never receives the promised state. The object's logical state becomes undefined.</p> <p>Error states are explicit and trackable. The type system knows about them, and callers must handle them.</p>"},{"location":"guide/error-handling/#example","title":"Example","text":"<pre><code># Wrong: exception bypasses state machine\nproc open(f: Closed, path: string): Open {.transition.} =\n  if not fileExists(path):\n    raise newException(IOError, \"not found\")  # Compile error!\n  ...\n\n# Right: error is a state\nproc open(f: Closed, path: string): Open | OpenFailed {.transition.} =\n  if not fileExists(path):\n    return OpenFailed(f.File)\n  ...\n</code></pre>"},{"location":"guide/error-handling/#defects-vs-exceptions","title":"Defects vs Exceptions","text":"<p>Nim distinguishes between Defects (bugs) and CatchableErrors (recoverable errors).</p>"},{"location":"guide/error-handling/#defects","title":"Defects","text":"<p>Programming errors that should not be caught:</p> <ul> <li><code>IndexDefect</code> - array/seq index out of bounds</li> <li><code>DivByZeroDefect</code> - division by zero</li> <li><code>AssertionDefect</code> - failed assertion</li> </ul> <p>Defects are NOT tracked by the <code>{.raises.}</code> pragma. A proc can have <code>{.raises: [].}</code> but still trigger a Defect if there's a bug.</p>"},{"location":"guide/error-handling/#catchableerrors","title":"CatchableErrors","text":"<p>Recoverable errors that callers can handle:</p> <ul> <li><code>IOError</code> - file/network operations</li> <li><code>ValueError</code> - parsing, conversion</li> <li><code>OSError</code> - system calls</li> </ul> <p>These ARE tracked by <code>{.raises.}</code>. Our enforcement prevents transitions from raising them.</p>"},{"location":"guide/error-handling/#what-typestates-guarantee","title":"What Typestates Guarantee","text":"<p>The library guarantees protocol correctness - you cannot call operations in the wrong state. It does NOT guarantee implementation correctness - your transition body might still have bugs that trigger Defects.</p> <p>Recommendation: Avoid Defect-prone operations in transitions, or guard them:</p> <pre><code># Risky: seq[i] can raise IndexDefect\nproc getItem(c: HasItems): Item {.transition, raises: [].} =\n  result = c.items[0]  # Bug if items is empty!\n\n# Safer: check first, return error state\nproc getItem(c: HasItems): Item | Empty {.transition, raises: [].} =\n  if c.items.len == 0:\n    return Empty(c.Container)\n  result = Item(c.items[0])\n</code></pre>"},{"location":"guide/error-handling/#patterns","title":"Patterns","text":""},{"location":"guide/error-handling/#union-return-types","title":"Union Return Types","text":"<p>Declare all possible outcomes in the return type:</p> <pre><code>typestate Connection:\n  states Disconnected, Connected, ConnectionFailed\n  transitions:\n    Disconnected -&gt; Connected | ConnectionFailed\n    Connected -&gt; Disconnected\n    ConnectionFailed -&gt; Disconnected\n\nproc connect(c: Disconnected, host: string): Connected | ConnectionFailed {.transition, raises: [].} =\n  try:\n    let socket = connectSocket(host)\n    result = Connected(c.Connection)\n    result.Connection.socket = socket\n  except OSError:\n    result = ConnectionFailed(c.Connection)\n</code></pre>"},{"location":"guide/error-handling/#wrap-external-calls","title":"Wrap External Calls","text":"<p>Create <code>{.raises: [].}</code> wrappers for exception-throwing APIs:</p> <pre><code>proc tryReadFile(path: string): Option[string] {.raises: [].} =\n  try:\n    result = some(readFile(path))\n  except IOError:\n    result = none(string)\n\nproc load(f: Empty, path: string): Loaded | LoadFailed {.transition, raises: [].} =\n  let content = tryReadFile(path)\n  if content.isNone:\n    return LoadFailed(f.Document)\n  result = Loaded(f.Document)\n  result.Document.content = content.get\n</code></pre>"},{"location":"guide/error-handling/#result-types","title":"Result Types","text":"<p>Use Result[T, E] for structured error handling:</p> <pre><code>proc load(f: Empty, path: string): Loaded | LoadFailed {.transition, raises: [].} =\n  let content = readFileResult(path)  # returns Result[string, IOError]\n  if content.isErr:\n    return LoadFailed(f.Document)\n  result = Loaded(f.Document)\n  result.Document.content = content.get\n</code></pre>"},{"location":"guide/examples/","title":"Examples","text":""},{"location":"guide/examples/#examples","title":"Examples","text":"<p>Real-world patterns where typestates prevent expensive bugs.</p> <p>Running the Examples</p> <p>All examples in this guide are available as complete, runnable files in the <code>examples/</code> directory.</p>"},{"location":"guide/examples/#payment-processing","title":"Payment Processing","text":"<p>Payment processing requires strict ordering: authorize before capture, capture before refund. Typestates prevent costly mistakes like double-capture or refunds before capture.</p> <pre><code>import typestates\n\ntype\n  Payment = object\n    id: string\n    amount: int           # cents, to avoid float issues\n    authCode: string\n    refundedAmount: int\n\n  Created = distinct Payment\n  Authorized = distinct Payment\n  Captured = distinct Payment\n  PartiallyRefunded = distinct Payment\n  FullyRefunded = distinct Payment\n  Settled = distinct Payment\n\ntypestate Payment:\n  states Created, Authorized, Captured, PartiallyRefunded, FullyRefunded, Settled\n  transitions:\n    Created -&gt; Authorized\n    Authorized -&gt; Captured\n    Captured -&gt; PartiallyRefunded | FullyRefunded | Settled\n    PartiallyRefunded -&gt; PartiallyRefunded | FullyRefunded | Settled\n    FullyRefunded -&gt; Settled\n\nproc authorize(p: Created, cardToken: string): Authorized {.transition.} =\n  var payment = p.Payment\n  payment.authCode = \"AUTH_\" &amp; payment.id\n  echo \"Authorized $\", payment.amount\n  result = Authorized(payment)\n\nproc capture(p: Authorized): Captured {.transition.} =\n  echo \"Captured $\", p.Payment.amount\n  result = Captured(p.Payment)\n\nproc partialRefund(p: Captured, amount: int): PartiallyRefunded {.transition.} =\n  var payment = p.Payment\n  payment.refundedAmount = amount\n  echo \"Refunded $\", amount\n  result = PartiallyRefunded(payment)\n\nproc settle(p: Captured): Settled {.transition.} =\n  echo \"Settled $\", p.Payment.amount\n  result = Settled(p.Payment)\n\n# Usage\nvar payment = Created(Payment(id: \"pay_123\", amount: 9999))\nlet authed = payment.authorize(\"card_tok_visa\")\nlet captured = authed.capture()\nlet settled = captured.settle()\n\n# COMPILE ERRORS - The bugs we prevent:\n# payment.capture()        # Can't capture without auth\n# captured.capture()       # Can't capture twice\n# authed.partialRefund(50) # Can't refund before capture\n</code></pre> <p>Bugs prevented:</p> <ul> <li>Capturing before authorization</li> <li>Double-capture</li> <li>Refunding before capture</li> <li>Operations on settled payments</li> </ul>"},{"location":"guide/examples/#database-connection-pool","title":"Database Connection Pool","text":"<p>Connection pools have invariants that are easy to violate: don't query pooled connections, don't return connections mid-transaction, don't commit without a transaction.</p> <pre><code>import typestates\n\ntype\n  DbConnection = object\n    id: int\n    inTransaction: bool\n\n  Pooled = distinct DbConnection\n  CheckedOut = distinct DbConnection\n  InTransaction = distinct DbConnection\n  Closed = distinct DbConnection\n\ntypestate DbConnection:\n  states Pooled, CheckedOut, InTransaction, Closed\n  transitions:\n    Pooled -&gt; CheckedOut | Closed\n    CheckedOut -&gt; Pooled | InTransaction | Closed\n    InTransaction -&gt; CheckedOut\n    * -&gt; Closed\n\nproc checkout(conn: Pooled): CheckedOut {.transition.} =\n  echo \"Checked out connection #\", conn.DbConnection.id\n  result = CheckedOut(conn.DbConnection)\n\nproc release(conn: CheckedOut): Pooled {.transition.} =\n  echo \"Released connection #\", conn.DbConnection.id\n  result = Pooled(conn.DbConnection)\n\nproc beginTransaction(conn: CheckedOut): InTransaction {.transition.} =\n  echo \"BEGIN TRANSACTION\"\n  result = InTransaction(conn.DbConnection)\n\nproc commit(conn: InTransaction): CheckedOut {.transition.} =\n  echo \"COMMIT\"\n  result = CheckedOut(conn.DbConnection)\n\nproc execute(conn: CheckedOut, sql: string): CheckedOut {.notATransition.} =\n  echo \"Execute: \", sql\n  result = conn\n\nproc execute(conn: InTransaction, sql: string): InTransaction {.notATransition.} =\n  echo \"Execute (in tx): \", sql\n  result = conn\n\n# Usage\nvar pooledConn = Pooled(DbConnection(id: 42))\nlet conn = pooledConn.checkout()\nlet tx = conn.beginTransaction()\nlet tx2 = tx.execute(\"INSERT INTO users VALUES (1, 'alice')\")\nlet afterTx = tx2.commit()\nlet returned = afterTx.release()\n\n# COMPILE ERRORS:\n# returned.execute(\"SELECT 1\")  # Can't query pooled connection\n# tx.release()                  # Can't release during transaction\n# conn.commit()                 # Can't commit without transaction\n</code></pre> <p>Bugs prevented:</p> <ul> <li>Query on pooled (not checked out) connection</li> <li>Returning connection while in transaction</li> <li>Committing without starting transaction</li> <li>Nested transactions</li> </ul>"},{"location":"guide/examples/#http-request-lifecycle","title":"HTTP Request Lifecycle","text":"<p>HTTP requests follow a strict sequence: set headers, send headers, send body, await response. Typestates enforce this ordering at compile time.</p> <pre><code>import typestates\n\ntype\n  HttpRequest = object\n    path: string\n    headers: seq[(string, string)]\n    body: string\n    responseCode: int\n\n  Building = distinct HttpRequest\n  HeadersSent = distinct HttpRequest\n  RequestSent = distinct HttpRequest\n  ResponseReceived = distinct HttpRequest\n\ntypestate HttpRequest:\n  states Building, HeadersSent, RequestSent, ResponseReceived\n  transitions:\n    Building -&gt; HeadersSent\n    HeadersSent -&gt; RequestSent\n    RequestSent -&gt; ResponseReceived\n    ResponseReceived -&gt; Building  # Keep-alive\n\nproc header(req: Building, key, value: string): Building {.notATransition.} =\n  var r = req.HttpRequest\n  r.headers.add((key, value))\n  result = Building(r)\n\nproc sendHeaders(req: Building): HeadersSent {.transition.} =\n  echo \"&gt;&gt;&gt; Sending headers\"\n  result = HeadersSent(req.HttpRequest)\n\nproc sendBody(req: HeadersSent, body: string): RequestSent {.transition.} =\n  echo \"&gt;&gt;&gt; Sending body (\", body.len, \" bytes)\"\n  result = RequestSent(req.HttpRequest)\n\nproc finish(req: HeadersSent): RequestSent {.transition.} =\n  echo \"&gt;&gt;&gt; Request complete (no body)\"\n  result = RequestSent(req.HttpRequest)\n\nproc awaitResponse(req: RequestSent): ResponseReceived {.transition.} =\n  var r = req.HttpRequest\n  r.responseCode = 200\n  echo \"&lt;&lt;&lt; Response: \", r.responseCode\n  result = ResponseReceived(r)\n\nfunc statusCode(resp: ResponseReceived): int =\n  resp.HttpRequest.responseCode\n\n# Usage\nlet req = Building(HttpRequest(path: \"/api/users\"))\n  .header(\"Accept\", \"application/json\")\n  .header(\"Authorization\", \"Bearer token\")\n  .sendHeaders()\n  .finish()\n  .awaitResponse()\n\necho \"Status: \", req.statusCode()\n\n# COMPILE ERRORS:\n# headersSent.header(\"X-Late\", \"header\")  # Can't add headers after sent\n# building.sendBody(\"data\")               # Can't send body before headers\n# headersSent.statusCode()                # Can't read response yet\n</code></pre> <p>Bugs prevented:</p> <ul> <li>Adding headers after they're sent</li> <li>Sending body before headers</li> <li>Reading response before request complete</li> </ul>"},{"location":"guide/examples/#oauth-authentication","title":"OAuth Authentication","text":"<p>OAuth requires authenticated tokens for API calls and refresh tokens to renew expired access. Typestates prevent calls with missing or expired credentials.</p> <pre><code>import typestates\n\ntype\n  OAuthSession = object\n    accessToken: string\n    refreshToken: string\n    expiresAt: int64\n\n  Unauthenticated = distinct OAuthSession\n  AwaitingCallback = distinct OAuthSession\n  Authenticated = distinct OAuthSession\n  TokenExpired = distinct OAuthSession\n\ntypestate OAuthSession:\n  states Unauthenticated, AwaitingCallback, Authenticated, TokenExpired\n  transitions:\n    Unauthenticated -&gt; AwaitingCallback\n    AwaitingCallback -&gt; Authenticated\n    Authenticated -&gt; TokenExpired\n    TokenExpired -&gt; Authenticated\n    * -&gt; Unauthenticated\n\nproc startAuth(session: Unauthenticated): AwaitingCallback {.transition.} =\n  echo \"Redirect to: https://auth.example.com/authorize?...\"\n  result = AwaitingCallback(session.OAuthSession)\n\nproc handleCallback(session: AwaitingCallback, code: string): Authenticated {.transition.} =\n  var s = session.OAuthSession\n  s.accessToken = \"eyJhbGc...\" &amp; code\n  s.refreshToken = \"refresh_\" &amp; code\n  echo \"Tokens received\"\n  result = Authenticated(s)\n\nproc callApi(session: Authenticated, endpoint: string): string {.notATransition.} =\n  echo \"GET \", endpoint, \" (Bearer \", session.OAuthSession.accessToken[0..10], \"...)\"\n  result = \"\"\"{\"status\": \"ok\"}\"\"\"\n\nproc tokenExpired(session: Authenticated): TokenExpired {.transition.} =\n  echo \"Token expired!\"\n  result = TokenExpired(session.OAuthSession)\n\nproc refresh(session: TokenExpired): Authenticated {.transition.} =\n  echo \"Refreshing token...\"\n  result = Authenticated(session.OAuthSession)\n\n# Usage\nlet session = Unauthenticated(OAuthSession())\n  .startAuth()\n  .handleCallback(\"auth_code_xyz\")\n\nlet data = session.callApi(\"/api/user/me\")\nlet expired = session.tokenExpired()\nlet refreshed = expired.refresh()\n\n# COMPILE ERRORS:\n# Unauthenticated(OAuthSession()).callApi(\"/api\")  # Can't call API unauthenticated\n# expired.callApi(\"/api\")                          # Can't call API with expired token\n# session.refresh()                                # Can't refresh non-expired token\n</code></pre> <p>Bugs prevented:</p> <ul> <li>API calls without authentication</li> <li>API calls with expired token</li> <li>Refreshing non-expired token</li> <li>Handling callback twice</li> </ul>"},{"location":"guide/examples/#robot-arm-controller","title":"Robot Arm Controller","text":"<p>Hardware control requires strict operation sequences. Moving without homing can crash into limits; powering off during movement can damage motors.</p> <pre><code>import typestates\n\ntype\n  RobotArm = object\n    x, y, z: float\n\n  PoweredOff = distinct RobotArm\n  NeedsHoming = distinct RobotArm\n  Homing = distinct RobotArm\n  Ready = distinct RobotArm\n  Moving = distinct RobotArm\n  EmergencyStop = distinct RobotArm\n\ntypestate RobotArm:\n  states PoweredOff, NeedsHoming, Homing, Ready, Moving, EmergencyStop\n  transitions:\n    PoweredOff -&gt; NeedsHoming\n    NeedsHoming -&gt; Homing\n    Homing -&gt; Ready\n    Ready -&gt; Moving | PoweredOff\n    Moving -&gt; Ready | EmergencyStop\n    EmergencyStop -&gt; NeedsHoming | PoweredOff\n\nproc powerOn(arm: PoweredOff): NeedsHoming {.transition.} =\n  echo \"Powering on... Position unknown!\"\n  result = NeedsHoming(arm.RobotArm)\n\nproc startHoming(arm: NeedsHoming): Homing {.transition.} =\n  echo \"Finding home position...\"\n  result = Homing(arm.RobotArm)\n\nproc homingComplete(arm: Homing): Ready {.transition.} =\n  echo \"Homing complete. Ready!\"\n  result = Ready(arm.RobotArm)\n\nproc moveTo(arm: Ready, x, y, z: float): Moving {.transition.} =\n  echo \"Moving to (\", x, \", \", y, \", \", z, \")...\"\n  result = Moving(arm.RobotArm)\n\nproc moveComplete(arm: Moving): Ready {.transition.} =\n  echo \"Move complete\"\n  result = Ready(arm.RobotArm)\n\nproc emergencyStop(arm: Moving, reason: string): EmergencyStop {.transition.} =\n  echo \"!!! EMERGENCY STOP: \", reason\n  result = EmergencyStop(arm.RobotArm)\n\nproc powerOff(arm: Ready): PoweredOff {.transition.} =\n  echo \"Powering off safely\"\n  result = PoweredOff(arm.RobotArm)\n\n# Usage\nvar arm = PoweredOff(RobotArm())\nlet ready = arm.powerOn().startHoming().homingComplete()\nlet moving = ready.moveTo(100.0, 50.0, 20.0)\nlet done = moving.moveComplete()\nlet off = done.powerOff()\n\n# COMPILE ERRORS - These could damage equipment!\n# arm.moveTo(100, 0, 0)     # Can't move without homing!\n# moving.powerOff()         # Can't power off while moving!\n# ready.startHoming()       # Already homed!\n</code></pre> <p>Bugs prevented:</p> <ul> <li>Moving without homing (could crash into limits)</li> <li>Power off while moving (motor damage)</li> <li>Continuing after emergency stop</li> <li>Skip initialization</li> </ul>"},{"location":"guide/examples/#order-fulfillment","title":"Order Fulfillment","text":"<p>Order fulfillment has a fixed sequence: place, pay, ship, deliver. Typestates ensure orders can't be shipped before payment or shipped twice.</p> <pre><code>import typestates\n\ntype\n  Order = object\n    id: string\n    items: seq[string]\n    paymentId: string\n    trackingNumber: string\n\n  Cart = distinct Order\n  Placed = distinct Order\n  Paid = distinct Order\n  Shipped = distinct Order\n  Delivered = distinct Order\n\ntypestate Order:\n  states Cart, Placed, Paid, Shipped, Delivered\n  transitions:\n    Cart -&gt; Placed\n    Placed -&gt; Paid\n    Paid -&gt; Shipped\n    Shipped -&gt; Delivered\n\nproc addItem(order: Cart, item: string): Cart {.notATransition.} =\n  var o = order.Order\n  o.items.add(item)\n  result = Cart(o)\n\nproc placeOrder(order: Cart): Placed {.transition.} =\n  echo \"Order placed\"\n  result = Placed(order.Order)\n\nproc pay(order: Placed, paymentId: string): Paid {.transition.} =\n  var o = order.Order\n  o.paymentId = paymentId\n  echo \"Payment received: \", paymentId\n  result = Paid(o)\n\nproc ship(order: Paid, tracking: string): Shipped {.transition.} =\n  var o = order.Order\n  o.trackingNumber = tracking\n  echo \"Shipped! Tracking: \", tracking\n  result = Shipped(o)\n\nproc confirmDelivery(order: Shipped): Delivered {.transition.} =\n  echo \"Delivered!\"\n  result = Delivered(order.Order)\n\n# Usage\nlet order = Cart(Order())\n  .addItem(\"Laptop\")\n  .addItem(\"Mouse\")\n  .placeOrder()\n  .pay(\"pay_ch_123\")\n  .ship(\"1Z999AA10123456784\")\n  .confirmDelivery()\n\n# COMPILE ERRORS:\n# Cart(Order()).ship(\"TRACK\")  # Can't ship cart!\n# placed.ship(\"TRACK\")         # Can't ship without payment!\n# shipped.ship(\"TRACK2\")       # Can't ship twice!\n</code></pre> <p>Bugs prevented:</p> <ul> <li>Ship before payment</li> <li>Double-ship</li> <li>Operations on unplaced cart</li> </ul>"},{"location":"guide/examples/#document-workflow","title":"Document Workflow","text":"<p>Document publishing enforces a review process: draft, review, approve, publish. Typestates prevent publishing without approval or editing published content.</p> <pre><code>import typestates\n\ntype\n  Document = object\n    title: string\n    content: string\n    approver: string\n\n  Draft = distinct Document\n  InReview = distinct Document\n  Approved = distinct Document\n  Published = distinct Document\n\ntypestate Document:\n  states Draft, InReview, Approved, Published\n  transitions:\n    Draft -&gt; InReview\n    InReview -&gt; Approved | Draft  # Approve or request changes\n    Approved -&gt; Published\n    Published -&gt; Draft  # New version\n\nproc edit(doc: Draft, content: string): Draft {.notATransition.} =\n  var d = doc.Document\n  d.content = content\n  result = Draft(d)\n\nproc submitForReview(doc: Draft): InReview {.transition.} =\n  echo \"Submitted for review\"\n  result = InReview(doc.Document)\n\nproc approve(doc: InReview, approver: string): Approved {.transition.} =\n  var d = doc.Document\n  d.approver = approver\n  echo \"Approved by: \", approver\n  result = Approved(d)\n\nproc requestChanges(doc: InReview): Draft {.transition.} =\n  echo \"Changes requested\"\n  result = Draft(doc.Document)\n\nproc publish(doc: Approved): Published {.transition.} =\n  echo \"Published!\"\n  result = Published(doc.Document)\n\n# Usage\nlet doc = Draft(Document(title: \"Q4 Strategy\"))\n  .edit(\"Our goals for Q4...\")\n  .submitForReview()\n  .approve(\"carol@company.com\")\n  .publish()\n\n# COMPILE ERRORS:\n# draft.publish()          # Can't publish without approval!\n# inReview.publish()       # Review not complete!\n# published.edit(\"hack\")   # Can't edit published content!\n</code></pre> <p>Bugs prevented:</p> <ul> <li>Publishing without approval</li> <li>Editing published content</li> <li>Skipping review process</li> </ul>"},{"location":"guide/examples/#generic-patterns","title":"Generic Patterns","text":"<p>The following examples show reusable typestate patterns using generics. See Generic Typestates for more on generic support.</p>"},{"location":"guide/examples/#resourcet-pattern","title":"Resource[T] Pattern","text":"<p>A reusable pattern for any resource requiring acquire/release semantics. Works with file handles, locks, connections, memory allocations, or any RAII-style resource.</p> <pre><code>import typestates\n\ntype\n  Resource[T] = object\n    handle: T\n    name: string\n\n  Released[T] = distinct Resource[T]\n  Acquired[T] = distinct Resource[T]\n\ntypestate Resource[T]:\n  states Released[T], Acquired[T]\n  transitions:\n    Released[T] -&gt; Acquired[T]\n    Acquired[T] -&gt; Released[T]\n\nproc acquire[T](r: Released[T], handle: T): Acquired[T] {.transition.} =\n  var res = Resource[T](r)\n  res.handle = handle\n  result = Acquired[T](res)\n\nproc release[T](r: Acquired[T]): Released[T] {.transition.} =\n  result = Released[T](Resource[T](r))\n\nproc use[T](r: Acquired[T]): T {.notATransition.} =\n  Resource[T](r).handle\n</code></pre> <p>Use with any resource type:</p> <pre><code># File handles\ntype FileHandle = object\n  fd: int\n  path: string\n\nvar file = Released[FileHandle](Resource[FileHandle](name: \"config\"))\nlet acquired = file.acquire(FileHandle(fd: 42, path: \"/etc/config\"))\necho acquired.use().path  # OK\nlet released = acquired.release()\n# released.use()  # COMPILE ERROR: can't use released resource\n\n# Database connections\ntype DbConn = object\n  connString: string\n\nvar db = Released[DbConn](Resource[DbConn](name: \"postgres\"))\nlet conn = db.acquire(DbConn(connString: \"postgresql://localhost/mydb\"))\n# ...use connection...\ndiscard conn.release()\n\n# Locks\ntype Lock = object\n  id: int\n\nvar mutex = Released[Lock](Resource[Lock](name: \"mutex\"))\nlet locked = mutex.acquire(Lock(id: 1))\n# ...critical section...\ndiscard locked.release()\n</code></pre> <p>Pattern benefits:</p> <ul> <li>Compile-time prevention of use-after-release</li> <li>Works with any resource type</li> <li>Enforces acquire-before-use</li> <li>Clean RAII semantics</li> </ul>"},{"location":"guide/examples/#pipelinet-pattern","title":"Pipeline[T] Pattern","text":"<p>A reusable pattern for entities that progress through a fixed sequence of stages. Works for orders, documents, builds, deployments, or any linear workflow.</p> <pre><code>import typestates\n\ntype\n  Pipeline[T] = object\n    entity: T\n\n  Stage1[T] = distinct Pipeline[T]\n  Stage2[T] = distinct Pipeline[T]\n  Stage3[T] = distinct Pipeline[T]\n  Stage4[T] = distinct Pipeline[T]\n\ntypestate Pipeline[T]:\n  states Stage1[T], Stage2[T], Stage3[T], Stage4[T]\n  transitions:\n    Stage1[T] -&gt; Stage2[T]\n    Stage2[T] -&gt; Stage3[T]\n    Stage3[T] -&gt; Stage4[T]\n\nproc start[T](entity: T): Stage1[T] =\n  Stage1[T](Pipeline[T](entity: entity))\n\nproc advance12[T](p: Stage1[T]): Stage2[T] {.transition.} =\n  Stage2[T](Pipeline[T](p))\n\nproc advance23[T](p: Stage2[T]): Stage3[T] {.transition.} =\n  Stage3[T](Pipeline[T](p))\n\nproc advance34[T](p: Stage3[T]): Stage4[T] {.transition.} =\n  Stage4[T](Pipeline[T](p))\n\nproc entity[T](p: Stage1[T]): T {.notATransition.} = Pipeline[T](p).entity\nproc entity[T](p: Stage2[T]): T {.notATransition.} = Pipeline[T](p).entity\nproc entity[T](p: Stage3[T]): T {.notATransition.} = Pipeline[T](p).entity\nproc entity[T](p: Stage4[T]): T {.notATransition.} = Pipeline[T](p).entity\n</code></pre> <p>Apply to different domains with semantic aliases:</p> <pre><code># Order fulfillment\ntype Order = object\n  id: string\n  items: seq[string]\n\ntype\n  OrderCart = Stage1[Order]      # Cart\n  OrderPaid = Stage2[Order]      # Paid\n  OrderShipped = Stage3[Order]   # Shipped\n  OrderDelivered = Stage4[Order] # Delivered\n\nlet order = start(Order(id: \"ORD-001\"))\nlet paid = order.advance12()      # Cart -&gt; Paid\nlet shipped = paid.advance23()    # Paid -&gt; Shipped\nlet delivered = shipped.advance34() # Shipped -&gt; Delivered\n\n# order.advance23()  # COMPILE ERROR: can't skip Paid stage\n\n# CI/CD builds\ntype Build = object\n  repo: string\n  commit: string\n\ntype\n  BuildQueued = Stage1[Build]\n  BuildCompiling = Stage2[Build]\n  BuildTesting = Stage3[Build]\n  BuildDeployed = Stage4[Build]\n\n# Document review\ntype Document = object\n  title: string\n  content: string\n\ntype\n  DocDraft = Stage1[Document]\n  DocInReview = Stage2[Document]\n  DocApproved = Stage3[Document]\n  DocPublished = Stage4[Document]\n</code></pre> <p>Pattern benefits:</p> <ul> <li>Enforces stage ordering at compile time</li> <li>Prevents skipping stages</li> <li>Single definition works for any entity type</li> <li>Domain-specific naming via type aliases</li> </ul>"},{"location":"guide/examples/#tips-for-designing-typestates","title":"Tips for Designing Typestates","text":""},{"location":"guide/examples/#1-start-with-the-state-diagram","title":"1. Start with the State Diagram","text":"<p>Draw your states and transitions first. Each arrow becomes a transition declaration.</p>"},{"location":"guide/examples/#2-one-responsibility-per-state","title":"2. One Responsibility Per State","text":"<p>Each state should represent one clear condition. If a state has multiple meanings, split it.</p>"},{"location":"guide/examples/#3-use-wildcards-sparingly","title":"3. Use Wildcards Sparingly","text":"<p><code>* -&gt; X</code> is powerful but can hide bugs. Use it only for truly universal operations like \"reset\" or \"emergency stop\".</p>"},{"location":"guide/examples/#4-consider-error-states","title":"4. Consider Error States","text":"<p>Many real systems need error/failure states. Plan for them upfront.</p>"},{"location":"guide/examples/#5-document-state-meanings","title":"5. Document State Meanings","text":"<p>Even with types enforcing transitions, document what each state means:</p> <pre><code>type\n  Pending = distinct Order\n    ## Order placed but not paid\n\n  Paid = distinct Order\n    ## Payment received, awaiting fulfillment\n\n  Shipped = distinct Order\n    ## Order shipped to customer\n</code></pre>"},{"location":"guide/formal-guarantees/","title":"Formal Guarantees","text":""},{"location":"guide/formal-guarantees/#formal-guarantees","title":"Formal Guarantees","text":"<p>This page explains the verification properties that nim-typestates provides and how they relate to formal methods concepts.</p>"},{"location":"guide/formal-guarantees/#correctness-by-construction","title":"Correctness by Construction","text":"<p>nim-typestates implements a form of correctness by construction: rather than testing for state machine violations at runtime, the type system makes them impossible to express.</p> <p>The Nim compiler acts as a verifier. If compilation succeeds, the program has been proven to contain no invalid state transitions.</p>"},{"location":"guide/formal-guarantees/#what-is-verified","title":"What is Verified","text":""},{"location":"guide/formal-guarantees/#temporal-safety","title":"Temporal Safety","text":"<p>Standard type systems verify data safety: a variable declared as <code>int</code> cannot be used as a <code>string</code>. Typestates extend this to temporal safety: an object in state <code>Closed</code> cannot be used where state <code>Open</code> is required.</p> <p>This prevents a class of bugs where operations are called in the wrong order or on objects in invalid states.</p>"},{"location":"guide/formal-guarantees/#protocol-adherence","title":"Protocol Adherence","text":"<p>Each <code>{.transition.}</code> proc is checked against the declared state graph. The compiler rejects any proc that:</p> <ul> <li>Takes a state type not registered in a typestate</li> <li>Returns a state not reachable from the input state</li> <li>Implements an undeclared transition</li> </ul>"},{"location":"guide/formal-guarantees/#state-exclusivity","title":"State Exclusivity","text":"<p>Distinct types ensure an object cannot satisfy multiple state types simultaneously. The type <code>Closed</code> is incompatible with <code>Open</code> at the type level, not just the value level.</p>"},{"location":"guide/formal-guarantees/#limitations","title":"Limitations","text":""},{"location":"guide/formal-guarantees/#specification-correctness","title":"Specification Correctness","text":"<p>The compiler verifies that code follows the declared state machine. It does not verify that the state machine correctly models the intended protocol.</p> <p>If the specification is wrong, the implementation will be \"correctly wrong.\"</p>"},{"location":"guide/formal-guarantees/#functional-correctness","title":"Functional Correctness","text":"<p>Typestates verify when operations can be called, not what they do. A <code>{.transition.}</code> proc from <code>Closed</code> to <code>Open</code> is verified to be callable only on <code>Closed</code> values and to return <code>Open</code> values. The proc body itself is not verified.</p>"},{"location":"guide/formal-guarantees/#runtime-behavior","title":"Runtime Behavior","text":"<p>Typestates operate at compile time. Runtime properties such as performance, memory safety, or exception behavior are outside their scope.</p> <p>For guidance on modeling errors as states rather than exceptions, see Error Handling.</p>"},{"location":"guide/formal-guarantees/#comparison-to-full-formal-verification","title":"Comparison to Full Formal Verification","text":"Aspect nim-typestates Full Formal Methods (TLA+, Coq) What is verified Protocol adherence Functional correctness Verification method Type checking Theorem proving Effort required Automatic Manual proofs Typical use Application protocols Safety-critical systems <p>nim-typestates occupies a practical middle ground: stronger guarantees than testing, lower cost than full formal verification.</p>"},{"location":"guide/formal-guarantees/#further-reading","title":"Further Reading","text":"<ul> <li>Typestate Analysis (Wikipedia)</li> <li>Formal Verification (Wikipedia)</li> <li>Typestates for Objects (Aldrich et al., 2009)</li> <li>Typestate: A Programming Language Concept (Strom &amp; Yemini, 1986)</li> <li>The Typestate Pattern in Rust</li> <li>Plaid Programming Language</li> </ul>"},{"location":"guide/generics/","title":"Generic Typestates","text":""},{"location":"guide/generics/#generic-typestates","title":"Generic Typestates","text":"<p>nim-typestates supports generic type parameters, enabling reusable typestate patterns.</p>"},{"location":"guide/generics/#basic-generic-typestate","title":"Basic Generic Typestate","text":"<p>Define a typestate with type parameters:</p> <pre><code>import typestates\n\ntype\n  Container[T] = object\n    value: T\n  Empty[T] = distinct Container[T]\n  Full[T] = distinct Container[T]\n\ntypestate Container[T]:\n  states Empty[T], Full[T]\n  transitions:\n    Empty[T] -&gt; Full[T]\n    Full[T] -&gt; Empty[T]\n</code></pre> <p>Implement transitions using generic procs:</p> <pre><code>proc fill[T](c: Empty[T], val: T): Full[T] {.transition.} =\n  var cont = Container[T](c)\n  cont.value = val\n  result = Full[T](cont)\n\nproc empty[T](c: Full[T]): Empty[T] {.transition.} =\n  result = Empty[T](Container[T](c))\n</code></pre> <p>Use with any type:</p> <pre><code># With int\nlet e = Empty[int](Container[int](value: 0))\nlet f = e.fill(42)\nlet e2 = f.empty()\n\n# With string\nlet s = Empty[string](Container[string](value: \"\"))\nlet s2 = s.fill(\"hello\")\n</code></pre>"},{"location":"guide/generics/#multiple-type-parameters","title":"Multiple Type Parameters","text":"<p>Typestates can have multiple type parameters:</p> <pre><code>type\n  KeyValue[K, V] = object\n    key: K\n    value: V\n  EmptyKV[K, V] = distinct KeyValue[K, V]\n  HasKey[K, V] = distinct KeyValue[K, V]\n  HasBoth[K, V] = distinct KeyValue[K, V]\n\ntypestate KeyValue[K, V]:\n  states EmptyKV[K, V], HasKey[K, V], HasBoth[K, V]\n  transitions:\n    EmptyKV[K, V] -&gt; HasKey[K, V]\n    HasKey[K, V] -&gt; HasBoth[K, V]\n    HasBoth[K, V] -&gt; EmptyKV[K, V]\n\nproc setKey[K, V](kv: EmptyKV[K, V], key: K): HasKey[K, V] {.transition.} =\n  var obj = KeyValue[K, V](kv)\n  obj.key = key\n  result = HasKey[K, V](obj)\n\nproc setValue[K, V](kv: HasKey[K, V], value: V): HasBoth[K, V] {.transition.} =\n  var obj = KeyValue[K, V](kv)\n  obj.value = value\n  result = HasBoth[K, V](obj)\n</code></pre>"},{"location":"guide/generics/#non-transitions-with-generics","title":"Non-Transitions with Generics","text":"<p>Use <code>{.notATransition.}</code> for operations that don't change state:</p> <pre><code>proc peek[T](c: Full[T]): T {.notATransition.} =\n  Container[T](c).value\n\nproc size[K, V](kv: HasBoth[K, V]): int {.notATransition.} =\n  1  # Always contains one key-value pair\n</code></pre>"},{"location":"guide/generics/#type-conversion-syntax","title":"Type Conversion Syntax","text":"<p>When converting between distinct generic types, use <code>Type[params](value)</code> syntax:</p> <pre><code># Correct - explicit generic parameters\nvar cont = Container[T](c)        # From distinct to base\nresult = Full[T](cont)            # From base to distinct\n\n# Wrong - method call syntax doesn't work with generics\n# var cont = c.Container[T]       # Compile error\n</code></pre>"},{"location":"guide/generics/#generated-helpers","title":"Generated Helpers","text":"<p>For generic typestates, helper types (enum, union, state procs) are not generated because the type parameters aren't in scope for the generated code. The core validation still works.</p> <p>For non-generic typestates, these are generated:</p> Helper Example Generated For Generics? State enum <code>ContainerState = enum fsEmpty, fsFull</code> No Union type <code>ContainerStates = Empty | Full</code> No State procs <code>proc state(c: Empty): ContainerState</code> No <p>You can create your own helpers if needed:</p> <pre><code>proc isEmptyState[T](c: Empty[T]): bool = true\nproc isEmptyState[T](c: Full[T]): bool = false\n\nproc isFull[T](c: Empty[T]): bool = false\nproc isFull[T](c: Full[T]): bool = true\n</code></pre>"},{"location":"guide/generics/#supported-type-expressions","title":"Supported Type Expressions","text":"<p>Generic typestates support various type expressions:</p> Type Expression Example Notes Simple generics <code>Container[T]</code> Single type parameter Multi-param generics <code>Map[K, V]</code> Multiple type parameters Nested generics <code>Container[seq[T]]</code> Generic of generic Constrained generics <code>Container[T: SomeInteger]</code> With type bounds"},{"location":"guide/generics/#pattern-builder-with-required-fields","title":"Pattern: Builder with Required Fields","text":"<p>Use generics to track which fields have been set:</p> <pre><code>type\n  UserBuilder = object\n    name: string\n    email: string\n\n  NeedsBoth = distinct UserBuilder\n  NeedsEmail = distinct UserBuilder\n  Complete = distinct UserBuilder\n\ntypestate UserBuilder:\n  states NeedsBoth, NeedsEmail, Complete\n  transitions:\n    NeedsBoth -&gt; NeedsEmail\n    NeedsEmail -&gt; Complete\n\nproc withName(b: NeedsBoth, name: string): NeedsEmail {.transition.} =\n  var builder = UserBuilder(b)\n  builder.name = name\n  result = NeedsEmail(builder)\n\nproc withEmail(b: NeedsEmail, email: string): Complete {.transition.} =\n  var builder = UserBuilder(b)\n  builder.email = email\n  result = Complete(builder)\n\nproc build(b: Complete): User {.notATransition.} =\n  let builder = UserBuilder(b)\n  User(name: builder.name, email: builder.email)\n</code></pre>"},{"location":"guide/generics/#pattern-resource-wrapper","title":"Pattern: Resource Wrapper","text":"<p>Wrap any resource type with acquire/release protocol:</p> <pre><code>type\n  Resource[T] = object\n    handle: T\n  Released[T] = distinct Resource[T]\n  Acquired[T] = distinct Resource[T]\n\ntypestate Resource[T]:\n  states Released[T], Acquired[T]\n  transitions:\n    Released[T] -&gt; Acquired[T]\n    Acquired[T] -&gt; Released[T]\n\nproc acquire[T](r: Released[T], handle: T): Acquired[T] {.transition.} =\n  var res = Resource[T](r)\n  res.handle = handle\n  result = Acquired[T](res)\n\nproc release[T](r: Acquired[T]): Released[T] {.transition.} =\n  result = Released[T](Resource[T](r))\n\nproc use[T](r: Acquired[T]): T {.notATransition.} =\n  Resource[T](r).handle\n</code></pre>"},{"location":"guide/generics/#limitations","title":"Limitations","text":"<ol> <li>No helper generation: Generic typestates don't get enum/union/state proc helpers</li> <li>Same base name: All states in a generic typestate must have distinct base names (e.g., <code>Empty[T]</code> and <code>Empty[V]</code> would conflict)</li> </ol>"},{"location":"guide/generics/#next-steps","title":"Next Steps","text":"<ul> <li>DSL Reference - Complete syntax reference</li> <li>Examples - More usage patterns</li> </ul>"},{"location":"guide/getting-started/","title":"Getting Started","text":""},{"location":"guide/getting-started/#getting-started","title":"Getting Started","text":"<p>This guide walks through building a typestate-validated file handle from scratch.</p>"},{"location":"guide/getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Nim 2.0 or later</li> <li>Basic familiarity with Nim's type system</li> </ul>"},{"location":"guide/getting-started/#installation","title":"Installation","text":"<pre><code>nimble install nim_typestates\n</code></pre>"},{"location":"guide/getting-started/#step-1-define-your-base-type","title":"Step 1: Define Your Base Type","text":"<p>Start with a regular object type that holds your data:</p> <pre><code>type\n  File = object\n    path: string\n    handle: int  # OS file descriptor\n</code></pre>"},{"location":"guide/getting-started/#step-2-define-state-types","title":"Step 2: Define State Types","text":"<p>Create distinct types for each state. Using <code>distinct</code> ensures the compiler treats them as different types:</p> <pre><code>type\n  File = object\n    path: string\n    handle: int\n\n  Closed = distinct File\n  Open = distinct File\n</code></pre> <p>Now <code>Closed</code> and <code>Open</code> are incompatible types - you can't pass a <code>Closed</code> where an <code>Open</code> is expected.</p>"},{"location":"guide/getting-started/#step-3-declare-the-typestate","title":"Step 3: Declare the Typestate","text":"<p>Import the library and declare valid transitions:</p> <pre><code>import typestates\n\ntype\n  File = object\n    path: string\n    handle: int\n  Closed = distinct File\n  Open = distinct File\n\ntypestate File:\n  states Closed, Open\n  transitions:\n    Closed -&gt; Open\n    Open -&gt; Closed\n</code></pre> <p>This tells the compiler:</p> <ul> <li><code>File</code> has two states: <code>Closed</code> and <code>Open</code></li> <li><code>Closed</code> can transition to <code>Open</code></li> <li><code>Open</code> can transition to <code>Closed</code></li> <li>No other transitions are valid</li> </ul>"},{"location":"guide/getting-started/#step-4-implement-transitions","title":"Step 4: Implement Transitions","text":"<p>Use the <code>{.transition.}</code> pragma to mark state-changing procs:</p> <pre><code>proc open(f: Closed, path: string): Open {.transition.} =\n  ## Open a closed file, returning it in the Open state.\n  var file = f.File  # Access underlying File\n  file.path = path\n  file.handle = 1  # Pretend we opened it\n  result = Open(file)\n\nproc close(f: Open): Closed {.transition.} =\n  ## Close an open file, returning it in the Closed state.\n  var file = f.File\n  file.handle = 0  # Pretend we closed it\n  result = Closed(file)\n</code></pre> <p>The <code>{.transition.}</code> pragma validates at compile time that:</p> <ol> <li>The input type (<code>Closed</code> or <code>Open</code>) is a registered state</li> <li>The return type is a valid transition target</li> <li>The transition is declared in the typestate block</li> </ol>"},{"location":"guide/getting-started/#step-5-use-it","title":"Step 5: Use It","text":"<pre><code># Create a file in the Closed state\nvar f = Closed(File(path: \"\", handle: 0))\n\n# Open it - returns Open type\nlet opened = f.open(\"/tmp/example.txt\")\n\n# Close it - returns Closed type\nlet closed = opened.close()\n\n# This won't compile!\n# let bad = opened.open(\"/other.txt\")\n# Error: Undeclared transition: Open -&gt; Open\n</code></pre>"},{"location":"guide/getting-started/#what-happens-on-invalid-transitions","title":"What Happens on Invalid Transitions?","text":"<p>If you try to implement an undeclared transition:</p> <pre><code>proc lock(f: Open): Locked {.transition.} =\n  discard\n</code></pre> <p>You get a compile-time error:</p> <pre><code>Error: Undeclared transition: Open -&gt; Locked\n  Typestate 'File' does not declare this transition.\n  Valid transitions from 'Open': @[\"Closed\"]\n  Hint: Add 'Open -&gt; Locked' to the transitions block.\n</code></pre>"},{"location":"guide/getting-started/#generated-helpers","title":"Generated Helpers","text":"<p>The <code>typestate</code> macro generates some useful types:</p>"},{"location":"guide/getting-started/#state-enum","title":"State Enum","text":"<pre><code>type FileState* = enum\n  fsClosed, fsOpen\n</code></pre>"},{"location":"guide/getting-started/#union-type","title":"Union Type","text":"<pre><code>type FileStates* = Closed | Open\n</code></pre>"},{"location":"guide/getting-started/#state-procs","title":"State Procs","text":"<pre><code>proc state*(f: Closed): FileState = fsClosed\nproc state*(f: Open): FileState = fsOpen\n</code></pre> <p>Use them for runtime inspection when needed:</p> <pre><code>proc describe[S: FileStates](f: S): string =\n  case f.state\n  of fsClosed: \"File is closed\"\n  of fsOpen: \"File is open\"\n</code></pre>"},{"location":"guide/getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>DSL Reference - Learn about branching, wildcards, and more</li> <li>Examples - See real-world patterns</li> <li>Error Handling - Model errors as states</li> </ul> <p>For details on what the compiler verifies, see Formal Guarantees.</p>"},{"location":"guide/strict-mode/","title":"Strict Mode","text":""},{"location":"guide/strict-mode/#strict-mode","title":"Strict Mode","text":"<p>nim-typestates uses strict defaults to catch bugs early.</p>"},{"location":"guide/strict-mode/#default-behavior","title":"Default Behavior","text":"<p>By default, typestates have: - <code>strictTransitions = true</code> - All procs with state params must be marked - <code>isSealed = true</code> - External modules cannot add transitions</p>"},{"location":"guide/strict-mode/#stricttransitions","title":"strictTransitions","text":"<p>When enabled, any proc with a state type as its first parameter MUST have either: - <code>{.transition.}</code> - for state-changing operations - <code>{.notATransition.}</code> - for read-only operations</p> <pre><code>typestate File:\n  states Closed, Open\n  transitions:\n    Closed -&gt; Open\n\nproc open(f: Closed): Open {.transition.} = ...     # OK\nproc read(f: Open): string {.notATransition.} = ... # OK\nproc helper(f: Open): int = ...                     # ERROR!\n</code></pre>"},{"location":"guide/strict-mode/#opting-out","title":"Opting Out","text":"<pre><code>typestate LegacyFile:\n  strictTransitions = false\n  states Closed, Open\n  ...\n</code></pre>"},{"location":"guide/strict-mode/#issealed","title":"isSealed","text":"<p>When enabled: 1. Other modules cannot extend the typestate 2. Other modules cannot define <code>{.transition.}</code> procs 3. Other modules MUST use <code>{.notATransition.}</code> for any state operations</p> <pre><code># library.nim\ntypestate Payment:\n  # isSealed = true (default)\n  states Created, Captured\n\n# user_code.nim\nimport library\n\nproc check(p: Created): bool {.notATransition.} = ...  # OK\nproc hack(p: Created): Captured {.transition.} = ...   # ERROR!\n</code></pre>"},{"location":"guide/strict-mode/#opting-out_1","title":"Opting Out","text":"<pre><code>typestate ExtensiblePayment:\n  isSealed = false\n  ...\n</code></pre>"},{"location":"guide/verification/","title":"Verification","text":""},{"location":"guide/verification/#verification","title":"Verification","text":"<p>nim-typestates provides multiple verification layers.</p>"},{"location":"guide/verification/#compile-time-checking","title":"Compile-Time Checking","text":"<p>The <code>{.transition.}</code> and <code>{.notATransition.}</code> pragmas validate at compile time:</p> <ul> <li>Transitions match declared state machine</li> <li>Sealed typestates block external transitions</li> </ul>"},{"location":"guide/verification/#verifytypestates-macro","title":"verifyTypestates() Macro","text":"<p>For comprehensive in-module verification:</p> <pre><code>import typestates\n\ntypestate File:\n  states Closed, Open\n  ...\n\nproc open(...) {.transition.} = ...\nproc close(...) {.transition.} = ...\n\nverifyTypestates()  # Validates everything above\n</code></pre>"},{"location":"guide/verification/#cli-tool","title":"CLI Tool","text":"<p>The library installs a <code>nim-typestates</code> binary for project-wide verification and visualization.</p> <p>The CLI uses Nim's AST parser for accurate extraction of typestate definitions, correctly handling comments, whitespace, and complex syntax.</p> <p>Important: Files must be valid Nim syntax. Syntax errors cause verification to fail immediately with a clear error message. This is intentional - a verification tool should not silently skip files it cannot parse.</p>"},{"location":"guide/verification/#verify","title":"Verify","text":"<p>Check that all procs on state types are properly marked:</p> <pre><code>nim-typestates verify src/\nnim-typestates verify src/ tests/\n</code></pre>"},{"location":"guide/verification/#generate-graphviz-dot","title":"Generate GraphViz DOT","text":"<p>Export state machine diagrams:</p> <pre><code>nim-typestates dot src/ &gt; typestates.dot\nnim-typestates dot src/ | dot -Tpng -o typestates.png\n</code></pre>"},{"location":"guide/verification/#adding-a-nimble-task","title":"Adding a Nimble Task","text":"<p>Add this to your project's <code>.nimble</code> file:</p> <pre><code>task verify, \"Verify typestate rules\":\n  exec \"nim-typestates verify src/\"\n</code></pre> <p>Then run:</p> <pre><code>nimble verify\n</code></pre>"},{"location":"guide/verification/#ci-integration","title":"CI Integration","text":"<pre><code># GitHub Actions\n- name: Verify typestates\n  run: nim-typestates verify src/\n\n# CircleCI\n- run:\n    name: Verify typestates\n    command: nim-typestates verify src/\n</code></pre>"},{"location":"guide/verification/#output","title":"Output","text":"<p>Successful verification:</p> <pre><code>Checked 15 files, 42 transitions\n\nAll checks passed!\n</code></pre> <p>Errors found:</p> <pre><code>Checked 15 files, 42 transitions\nWARNING: src/legacy.nim:45 - Unmarked proc on state 'Open'\nERROR: src/user.nim:23 - Unmarked proc on sealed state 'Payment'\n\n1 error(s) found\n</code></pre> <p>Syntax errors:</p> <pre><code>ERROR: Parse error in src/broken.nim: invalid indentation\n</code></pre>"}]}